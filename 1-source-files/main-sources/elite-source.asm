; ******************************************************************************
;
; APPLE II ELITE GAME SOURCE
;
; Apple II Elite was written by Ian Bell and David Braben and is copyright
; D. Braben and I. Bell 1986
;
; The code on this site is identical to the source disks released on Ian Bell's
; personal website at http://www.elitehomepage.org/ (it's just been reformatted
; to be more readable)
;
; The commentary is copyright Mark Moxon, and any misunderstandings or mistakes
; in the documentation are entirely my fault
;
; The terminology and notations used in this commentary are explained at
; https://elite.bbcelite.com/terminology
;
; The deep dive articles referred to in this commentary can be found at
; https://elite.bbcelite.com/deep_dives
;
; ------------------------------------------------------------------------------
;
; This source file produces the following binary files:
;
;   * ELTA.bin
;   * ELTB.bin
;   * ELTC.bin
;   * ELTD.bin
;   * ELTE.bin
;   * ELTF.bin
;   * ELTG.bin
;   * ELTH.bin
;   * ELTI.bin
;   * ELTJ.bin
;   * ELTK.bin
;
; ******************************************************************************

 INCLUDE "1-source-files/main-sources/elite-build-options.asm"

 _IB_DISK                   = (_VARIANT = 1)
 _SOURCE_DISK_BUILD         = (_VARIANT = 2)
 _SOURCE_DISK_CODE_FILES    = (_VARIANT = 3)
 _SOURCE_DISK_ELT_FILES     = (_VARIANT = 4)

; ******************************************************************************
;
; Configuration variables
;
; ******************************************************************************

 CODE% = $4000          ; The address where the code will be run

 LOAD% = $4000          ; The address where the code will be loaded

IF _IB_DISK

 STORE = $0200          ; The address where the dashboard image is loaded ???

 CODE2 = $2000          ; The address where the dashboard image is run ???

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 STORE = $D000          ; The address where the dashboard image is loaded ???

 CODE2 = $9000          ; The address where the dashboard image is run ???

ENDIF

 D% = $A300             ; The address where the ship data will be loaded
                        ; (i.e. XX21)

 Q% = _MAX_COMMANDER    ; Set Q% to TRUE to max out the default commander, FALSE
                        ; for the standard default commander

 USA% = FALSE           ; ???

 NOST = 12              ; The number of stardust particles in normal space (this
                        ; goes down to 3 in witchspace)

 NOSH = 8               ; The maximum number of ships in our local bubble of
                        ; universe

 NTY = 32               ; The number of different ship types

 MSL = 1                ; Ship type for a missile

 SST = 2                ; Ship type for a Coriolis space station

 ESC = 3                ; Ship type for an escape pod

 PLT = 4                ; Ship type for an alloy plate

 OIL = 5                ; Ship type for a cargo canister

 AST = 7                ; Ship type for an asteroid

 SPL = 8                ; Ship type for a splinter

 SHU = 9                ; Ship type for a Shuttle

 CYL = 11               ; Ship type for a Cobra Mk III

 ANA = 14               ; Ship type for an Anaconda

 HER = 15               ; Ship type for a rock hermit (asteroid)

 COPS = 16              ; Ship type for a Viper

 SH3 = 17               ; Ship type for a Sidewinder

 KRA = 19               ; Ship type for a Krait

 ADA = 20               ; Ship type for an Adder

 WRM = 23               ; Ship type for a Worm

 CYL2 = 24              ; Ship type for a Cobra Mk III (pirate)

 ASP = 25               ; Ship type for an Asp Mk II

 THG = 29               ; Ship type for a Thargoid

 TGL = 30               ; Ship type for a Thargon

 CON = 31               ; Ship type for a Constrictor

 DOD = 32               ; Ship type for a Dodecahedron ("Dodo") space station

 JL = ESC               ; Junk is defined as starting from the escape pod

 JH = SHU+2             ; Junk is defined as ending before the Cobra Mk III
                        ;
                        ; So junk is defined as the following: escape pod,
                        ; alloy plate, cargo canister, asteroid, splinter,
                        ; Shuttle or Transporter

 PACK = SH3             ; The first of the eight pack-hunter ships, which tend
                        ; to spawn in groups. With the default value of PACK the
                        ; pack-hunters are the Sidewinder, Mamba, Krait, Adder,
                        ; Gecko, Cobra Mk I, Worm and Cobra Mk III (pirate)

 POW = 15               ; Pulse laser power

 Mlas = 50              ; Mining laser power

 Armlas = INT(128.5 + 1.5*POW)  ; Military laser power

 NI% = 37               ; The number of bytes in each ship's data block (as
                        ; stored in INWK and K%)

 X = 128                ; The centre x-coordinate of the 256 x 136 space view

 Y = 68                 ; The centre y-coordinate of the 256 x 136 space view

 conhieght = 80         ; The size of the gap left for the rotating Constrictor
                        ; at the top of the briefing for mission 1

 GCYT = 19              ; The y-coordinate of the top of the Long-range Chart

 GCYB = GCYT + 0.75*128 ; The y-coordinate of the bottom of the Long-range chart

 f0 = $31               ; ASCII number for key "1" (Launch, Front)

 f1 = $32               ; ASCII number for key "1" (Buy Cargo)

 f2 = $33               ; ASCII number for key "2" (Sell Cargo)

 f3 = $34               ; ASCII number for key "3" (Equip Ship)

 f4 = $35               ; ASCII number for key "4" (Long-range Chart)

 f5 = $36               ; ASCII number for key "5" (Short-range Chart)

 f6 = $37               ; ASCII number for key "6" (Data on System)

 f7 = $38               ; ASCII number for key "7" (Market Price)

 f8 = $39               ; ASCII number for key "8" (Status Mode)

 f9 = $30               ; ASCII number for key "9" (Inventory)

 f12 = $32              ; ASCII number for key "2" (Rear)

 f22 = $33              ; ASCII number for key "3" (Left)

 f32 = $34              ; ASCII number for key "4" (Right)

 VIOLET = 4             ; ???
 GREEN = 8
 WHITE = 12
 BLUE = 16
 RED = 20
 FUZZY = 24
 BLACK = 0
 CYAN = WHITE
 MAG = WHITE

 sfxplas = 0            ; ???
 sfxelas = 1
 sfxhit = 2
 sfxexpl = 3
 sfxwhosh = 4
 sfxbeep = 5
 sfxboop = 6
 sfxhyp1 = 7
 sfxeng = 8
 sfxecm = 9
 sfxblas = 10
 sfxalas = 11
 sfxmlas = 12
 sfxbomb = 13
 sfxtrib = 14
 sfxelas2 = 15

 NRU% = 0               ; The number of planetary systems with extended system
                        ; description overrides in the RUTOK table
                        ;
                        ; NRU% is set to 0 in the original source, but this is a
                        ; bug, as it should match the number of entries in the
                        ; RUGAL table
                        ;
                        ; This bug causes the Data on System screen to crash the
                        ; game for a small number of systems - for example, the
                        ; game will freeze if you bring up the Data on System
                        ; screen after docking at Biarge in the first galaxy
                        ; during the Constrictor mission

 RE = $23               ; The obfuscation byte used to hide the recursive tokens
                        ; table from crackers viewing the binary code

 VE = $57               ; The obfuscation byte used to hide the extended tokens
                        ; table from crackers viewing the binary code

 KEY1 = $15             ; The seed for encrypting CODE1 and CODE2 from G% to R%,
                        ; where CODE1 is the portion of ELTA-ELTK up to memory
                        ; location $9000, and CODE2 is the portion from $9000
                        ; onwards

 KEY2 = $69             ; The seed for encrypting DATA from WORDS to $2000,
                        ; which is the whole data file

 LL = 30                ; The length of lines (in characters) of justified text
                        ; in the extended tokens system

 BUF = $0100            ; The line buffer used by DASC to print justified text

 BRKV = $03F0           ; The break vector that we intercept to enable us to
                        ; handle and display system errors

 IRQV = $03FE           ; The IRQV vector that we intercept to implement the
                        ; split-screen mode ???

 CHRV = $0036           ; The CHRV vector that we intercept with our custom
                        ; text printing routine

 NMIV = $03FC           ; ???

 QQ18 = $0B60           ; The address of the text token table, as set in
                        ; elite-data.asm

 SNE = $0F20            ; The address of the sine lookup table, as set in
                        ; elite-data.asm

 TKN1 = $0F40           ; The address of the extended token table, as set in
                        ; elite-data.asm

 RUPLA = TKN1 + $B1E    ; The address of the extended system description system
                        ; number table, as set in elite-data.asm

 RUGAL = TKN1 + $B38    ; The address of the extended system description galaxy
                        ; number table, as set in elite-data.asm

 RUTOK = TKN1 + $B52    ; The address of the extended system description token
                        ; table, as set in elite-data.asm

 LS% = $0B5F            ; The start of the descending ship line heap

 TAP% = LS% - 111       ; The staging area where we copy files after loading and
                        ; before saving (though this isn't actually used in this
                        ; version, and is left-over Commodore 64 code)

 FONT = $1D00           ; The address of the game's text font

 SCBASE = $2000         ; The address of screen memory

 DLOC% = SCBASE         ; ???

 R% = $BFFF             ; The address of the last byte of game code

 comsiz  =  110         ; Commander file size (1-252 bytes)
 comfil  =  TAP%-20     ; Commander file (must not exceed 252 bytes)
 comfil2 =  comfil+comsiz-4
 buffer  =  $0800       ; K%, 256 byte sector buffer
 buffr2  =  $0800+256   ; K%+256, 342 6 bit 'nibble' buffer
 fretrk  =  buffer+$30  ; last allocated track
 dirtrk  =  buffer+$31  ; direction of track allocation (+1 or -1)
 tracks  =  buffer+$34  ; number of tracks per disc
 bitmap  =  buffer+$38  ; bit map of free sectors in track 0

                        ; Disc Controller Addresses

 phsoff  =  $C080       ; stepper motor phase 0 off
 mtroff  =  $C088       ; turn motor off
 mtron   =  $C089       ; turn motor on
 drv1en  =  $C08A       ; enable drive 1
 drv2en  =  $C08B       ; enable drive 2
 Q6L     =  $C08C       ; strobe data latch for I/O
 Q6H     =  $C08D       ; load data latch
 Q7L     =  $C08E       ; prepare latch for input
 Q7H     =  $C08F       ; prepare latch for output

 track   =  buffr2+350  ; ???
 sector  =  track+1
 curtrk  =  sector+1
 tsltrk  =  curtrk+1
 tslsct  =  tsltrk+1
 filtrk  =  tslsct+1
 filsct  =  filtrk+1
 mtimel  =  filsct+1
 mtimeh  =  mtimel+1
 seeks   =  mtimeh+1
 recals  =  seeks+1
 slot16  =  recals+1
 atemp0  =  slot16+1
 stkptr  =  atemp0+1
 idfld   =  stkptr+1

; ******************************************************************************
;
;       Name: ZP
;       Type: Workspace
;    Address: $0000 to $00E2
;   Category: Workspaces
;    Summary: Lots of important variables are stored in the zero page workspace
;             as it is quicker and more space-efficient to access memory here
;
; ******************************************************************************

 ORG $0000

.ZP

 SKIP 0                 ; The start of the zero page workspace

 SKIP 2                 ; These bytes appear to be unused

.RAND

 SKIP 4                 ; Four 8-bit seeds for the random number generation
                        ; system implemented in the DORND routine

.T1

 SKIP 1                 ; Temporary storage, used in a number of places

.T2

 SKIP 1                 ; This byte appears to be unused

.T3

 SKIP 1                 ; This byte appears to be unused

.T4

 SKIP 1                 ; This byte appears to be unused

.SC

 SKIP 1                 ; Screen address (low byte)
                        ;
                        ; Elite draws on-screen by poking bytes directly into
                        ; screen memory, and SC(1 0) is typically set to the
                        ; address of the character block containing the pixel

.SCH

 SKIP 1                 ; Screen address (high byte)

.XX1

 SKIP 0                 ; This is an alias for INWK that is used in the main
                        ; ship-drawing routine at LL9

.INWK

 SKIP 33                ; The zero-page internal workspace for the current ship
                        ; data block
                        ;
                        ; As operations on zero page locations are faster and
                        ; have smaller opcodes than operations on the rest of
                        ; the addressable memory, Elite tends to store oft-used
                        ; data here. A lot of the routines in Elite need to
                        ; access and manipulate ship data, so to make this an
                        ; efficient exercise, the ship data is first copied from
                        ; the ship data blocks at K% into INWK (or, when new
                        ; ships are spawned, from the blueprints at XX21). See
                        ; the deep dive on "Ship data blocks" for details of
                        ; what each of the bytes in the INWK data block
                        ; represents

.XX19

 SKIP NI% - 34          ; XX19(1 0) shares its location with INWK(34 33), which
                        ; contains the address of the ship line heap

.NEWB

 SKIP 1                 ; The ship's "new byte flags" (or NEWB flags)
                        ;
                        ; Contains details about the ship's type and associated
                        ; behaviour, such as whether they are a trader, a bounty
                        ; hunter, a pirate, currently hostile, in the process of
                        ; docking, inside the hold having been scooped, and so
                        ; on. The default values for each ship type are taken
                        ; from the table at E%, and you can find out more detail
                        ; in the deep dive on "Advanced tactics with the NEWB
                        ; flags"

.P

 SKIP 3                 ; Temporary storage, used in a number of places

.XC

 SKIP 1                 ; The x-coordinate of the text cursor (i.e. the text
                        ; column), which can be from 0 to 32
                        ;
                        ; A value of 0 denotes the leftmost column and 32 the
                        ; rightmost column, but because the top part of the
                        ; screen (the space view) has a white border that
                        ; clashes with columns 0 and 32, text is only shown
                        ; in columns 1-31

.COL

 SKIP 1                 ; Temporary storage, used to store colour information
                        ; when drawing pixels in the dashboard

.YC

 SKIP 1                 ; The y-coordinate of the text cursor (i.e. the text
                        ; row), which can be from 0 to 23
                        ;
                        ; The screen actually has 31 character rows if you
                        ; include the dashboard, but the text printing routines
                        ; only work on the top part (the space view), so the
                        ; text cursor only goes up to a maximum of 23, the row
                        ; just before the screen splits
                        ;
                        ; A value of 0 denotes the top row, but because the
                        ; top part of the screen has a white border that clashes
                        ; with row 0, text is always shown at row 1 or greater

.QQ17

 SKIP 1                 ; Contains a number of flags that affect how text tokens
                        ; are printed, particularly capitalisation:
                        ;
                        ;   * If all bits are set (255) then text printing is
                        ;     disabled
                        ;
                        ;   * Bit 7: 0 = ALL CAPS
                        ;            1 = Sentence Case, bit 6 determines the
                        ;                case of the next letter to print
                        ;
                        ;   * Bit 6: 0 = print the next letter in upper case
                        ;            1 = print the next letter in lower case
                        ;
                        ;   * Bits 0-5: If any of bits 0-5 are set, print in
                        ;               lower case
                        ;
                        ; So:
                        ;
                        ;   * QQ17 = 0 means case is set to ALL CAPS
                        ;
                        ;   * QQ17 = %10000000 means Sentence Case, currently
                        ;            printing upper case
                        ;
                        ;   * QQ17 = %11000000 means Sentence Case, currently
                        ;            printing lower case
                        ;
                        ;   * QQ17 = %11111111 means printing is disabled

.K3

 SKIP 0                 ; Temporary storage, used in a number of places

.XX2

 SKIP 14                ; Temporary storage, used to store the visibility of the
                        ; ship's faces during the ship-drawing routine at LL9

.K4

 SKIP 2                 ; Temporary storage, used in a number of places

.XX16

 SKIP 18                ; Temporary storage for a block of values, used in a
                        ; number of places

.XX0

 SKIP 2                 ; Temporary storage, used to store the address of a ship
                        ; blueprint. For example, it is used when we add a new
                        ; ship to the local bubble in routine NWSHP, and it
                        ; contains the address of the current ship's blueprint
                        ; as we loop through all the nearby ships in the main
                        ; flight loop

.INF

 SKIP 2                 ; Temporary storage, typically used for storing the
                        ; address of a ship's data block, so it can be copied
                        ; to and from the internal workspace at INWK

.V

 SKIP 2                 ; Temporary storage, typically used for storing an
                        ; address pointer

.XX

 SKIP 2                 ; Temporary storage, typically used for storing a 16-bit
                        ; x-coordinate

.YY

 SKIP 2                 ; Temporary storage, typically used for storing a 16-bit
                        ; y-coordinate

.SUNX

 SKIP 2                 ; The 16-bit x-coordinate of the vertical centre axis
                        ; of the sun (which might be off-screen)

.BETA

 SKIP 1                 ; The current pitch angle beta, which is reduced from
                        ; JSTY to a sign-magnitude value between -8 and +8
                        ;
                        ; This describes how fast we are pitching our ship, and
                        ; determines how fast the universe pitches around us
                        ;
                        ; The sign bit is also stored in BET2, while the
                        ; opposite sign is stored in BET2+1

.BET1

 SKIP 1                 ; The magnitude of the pitch angle beta, i.e. |beta|,
                        ; which is a positive value between 0 and 8

.QQ22

 SKIP 2                 ; The two hyperspace countdown counters
                        ;
                        ; Before a hyperspace jump, both QQ22 and QQ22+1 are
                        ; set to 15
                        ;
                        ; QQ22 is an internal counter that counts down by 1
                        ; each time TT102 is called, which happens every
                        ; iteration of the main game loop. When it reaches
                        ; zero, the on-screen counter in QQ22+1 gets
                        ; decremented, and QQ22 gets set to 5 and the countdown
                        ; continues (so the first tick of the hyperspace counter
                        ; takes 15 iterations to happen, but subsequent ticks
                        ; take 5 iterations each)
                        ;
                        ; QQ22+1 contains the number that's shown on-screen
                        ; during the countdown. It counts down from 15 to 1, and
                        ; when it hits 0, the hyperspace engines kick in

.ECMA

 SKIP 1                 ; The E.C.M. countdown timer, which determines whether
                        ; an E.C.M. system is currently operating:
                        ;
                        ;   * 0 = E.C.M. is off
                        ;
                        ;   * Non-zero = E.C.M. is on and is counting down
                        ;
                        ; The counter starts at 32 when an E.C.M. is activated,
                        ; either by us or by an opponent, and it decreases by 1
                        ; in each iteration of the main flight loop until it
                        ; reaches zero, at which point the E.C.M. switches off.
                        ; Only one E.C.M. can be active at any one time, so
                        ; there is only one counter

.ALP1

 SKIP 1                 ; Magnitude of the roll angle alpha, i.e. |alpha|,
                        ; which is a positive value between 0 and 31

.ALP2

 SKIP 2                 ; Bit 7 of ALP2 = sign of the roll angle in ALPHA
                        ;
                        ; Bit 7 of ALP2+1 = opposite sign to ALP2 and ALPHA

.XX15

 SKIP 0                 ; Temporary storage, typically used for storing screen
                        ; coordinates in line-drawing routines
                        ;
                        ; There are six bytes of storage, from XX15 TO XX15+5.
                        ; The first four bytes have the following aliases:
                        ;
                        ;   X1 = XX15
                        ;   Y1 = XX15+1
                        ;   X2 = XX15+2
                        ;   Y2 = XX15+3
                        ;
                        ; These are typically used for describing lines in terms
                        ; of screen coordinates, i.e. (X1, Y1) to (X2, Y2)
                        ;
                        ; The last two bytes of XX15 do not have aliases

.ztemp0

 SKIP 0                 ; ???

.X1

 SKIP 1                 ; Temporary storage, typically used for x-coordinates in
                        ; line-drawing routines

.ztemp1

 SKIP 0                 ; ???

.Y1

 SKIP 1                 ; Temporary storage, typically used for y-coordinates in
                        ; line-drawing routines

.ztemp2

 SKIP 0                 ; ???

.X2

 SKIP 1                 ; Temporary storage, typically used for x-coordinates in
                        ; line-drawing routines

.ztemp3

 SKIP 0                 ; ???

.Y2

 SKIP 1                 ; Temporary storage, typically used for y-coordinates in
                        ; line-drawing routines

 SKIP 2                 ; The last two bytes of the XX15 block

.XX12

 SKIP 6                 ; Temporary storage for a block of values, used in a
                        ; number of places

.K

 SKIP 4                 ; Temporary storage, used in a number of places

.LAS

 SKIP 1                 ; Contains the laser power of the laser fitted to the
                        ; current space view (or 0 if there is no laser fitted
                        ; to the current view)
                        ;
                        ; This gets set to bits 0-6 of the laser power byte from
                        ; the commander data block, which contains the laser's
                        ; power (bit 7 doesn't denote laser power, just whether
                        ; or not the laser pulses, so that is not stored here)

.MSTG

 SKIP 1                 ; The current missile lock target
                        ;
                        ;   * $FF = no target
                        ;

.KEYLOOK

 SKIP 0                 ; KEYLOOK, KLO, KL and thiskey all share the same
                        ; address

.KLO

 SKIP 0                 ; KEYLOOK, KLO, KL and thiskey all share the same
                        ; address

.thiskey

 SKIP 0                 ; The following bytes implement a key logger that
                        ; enables Elite to scan for concurrent key presses of
                        ; the primary flight keys, plus a secondary flight key
                        ;
                        ; See the deep dive on "The key logger" for more details
                        ;
                        ; If a key is being pressed that is not in the keyboard
                        ; table at KYTB, it can be stored here (as seen in
                        ; routine DK4, for example)

.KL

 SKIP 1                 ; The following bytes implement a key logger that
                        ; enables Elite to scan for concurrent key presses of
                        ; the primary flight keys, plus a secondary flight key
                        ;
                        ; See the deep dive on "The key logger" for more details
                        ;
                        ; If a key is being pressed that is not in the keyboard
                        ; table at KYTB, it can be stored here (as seen in
                        ; routine DK4, for example)

.KY1

 SKIP 1                 ; "?" is being pressed
                        ;
                        ;   * 0 = no
                        ;
                        ;   * Non-zero = yes

.KY2

 SKIP 1                 ; Space is being pressed
                        ;
                        ;   * 0 = no
                        ;
                        ;   * Non-zero = yes

.KY3

 SKIP 1                 ; "<" is being pressed
                        ;
                        ;   * 0 = no
                        ;
                        ;   * Non-zero = yes

.KY4

 SKIP 1                 ; ">" is being pressed
                        ;
                        ;   * 0 = no
                        ;
                        ;   * Non-zero = yes

.KY5

 SKIP 1                 ; "X" is being pressed
                        ;
                        ;   * 0 = no
                        ;
                        ;   * Non-zero = yes

.KY6

 SKIP 1                 ; "S" is being pressed
                        ;
                        ;   * 0 = no
                        ;
                        ;   * Non-zero = yes

.KY7

 SKIP 1                 ; "A" is being pressed
                        ;
                        ;   * 0 = no
                        ;
                        ;   * Non-zero = yes
                        ;
                        ; This is also set when the joystick fire button has
                        ; been pressed

.KY12

 SKIP 1                 ; "B" is being pressed
                        ;
                        ;   * 0 = no
                        ;
                        ;   * Non-zero = yes

.KY13

 SKIP 1                 ; ESCAPE is being pressed
                        ;
                        ;   * 0 = no
                        ;
                        ;   * Non-zero = yes

.KY14

 SKIP 1                 ; "T" is being pressed
                        ;
                        ;   * 0 = no
                        ;
                        ;   * Non-zero = yes

.KY15

 SKIP 1                 ; "U" is being pressed
                        ;
                        ;   * 0 = no
                        ;
                        ;   * Non-zero = yes

.KY16

 SKIP 1                 ; "M" is being pressed
                        ;
                        ;   * 0 = no
                        ;
                        ;   * Non-zero = yes

.KY17

 SKIP 1                 ; "E" is being pressed
                        ;
                        ;   * 0 = no
                        ;
                        ;   * Non-zero = yes

.KY18

 SKIP 1                 ; "J" is being pressed
                        ;
                        ;   * 0 = no
                        ;
                        ;   * Non-zero = yes

.KY19

 SKIP 1                 ; "C" is being pressed
                        ;
                        ;   * 0 = no
                        ;
                        ;   * Non-zero = yes

.KY20

 SKIP 1                 ; "P" is being pressed
                        ;
                        ;   * 0 = no
                        ;
                        ;   * Non-zero = yes

.LSP

 SKIP 1                 ; The ball line heap pointer, which contains the number
                        ; of the first free byte after the end of the LSX2 and
                        ; LSY2 heaps (see the deep dive on "The ball line heap"
                        ; for details)

.QQ15

 SKIP 6                 ; The three 16-bit seeds for the selected system, i.e.
                        ; the one in the crosshairs in the Short-range Chart
                        ;
                        ; See the deep dives on "Galaxy and system seeds" and
                        ; "Twisting the system seeds" for more details

.K5

 SKIP 0                 ; Temporary storage used to store segment coordinates
                        ; across successive calls to BLINE, the ball line
                        ; routine

.XX18

 SKIP 4                 ; Temporary storage used to store coordinates in the
                        ; LL9 ship-drawing routine

.K6

 SKIP 5                 ; Temporary storage, typically used for storing
                        ; coordinates during vector calculations

.QQ19

 SKIP 6                 ; Temporary storage, used in a number of places

.BET2

 SKIP 2                 ; Bit 7 of BET2 = sign of the pitch angle in BETA
                        ;
                        ; Bit 7 of BET2+1 = opposite sign to BET2 and BETA

.DELTA

 SKIP 1                 ; Our current speed, in the range 1-40

.DELT4

 SKIP 2                 ; Our current speed * 64 as a 16-bit value
                        ;
                        ; This is stored as DELT4(1 0), so the high byte in
                        ; DELT4+1 therefore contains our current speed / 4

.U

 SKIP 1                 ; Temporary storage, used in a number of places

.Q

 SKIP 1                 ; Temporary storage, used in a number of places

.R

 SKIP 1                 ; Temporary storage, used in a number of places

.S

 SKIP 1                 ; Temporary storage, used in a number of places

.XSAV

 SKIP 1                 ; Temporary storage for saving the value of the X
                        ; register, used in a number of places

.YSAV

 SKIP 1                 ; Temporary storage for saving the value of the Y
                        ; register, used in a number of places

.XX17

 SKIP 1                 ; Temporary storage, used in BPRNT to store the number
                        ; of characters to print, and as the edge counter in the
                        ; main ship-drawing routine

.QQ11

 SKIP 1                 ; The type of the current view:
                        ;
                        ;   0   = Space view
                        ;   1   = Title screen
                        ;         Get commander name ("@", save/load commander)
                        ;         In-system jump just arrived ("J")
                        ;         Data on System screen (key "7")
                        ;   2   = Buy Cargo screen (key "2")
                        ;   3   = Mis-jump just arrived (witchspace)
                        ;   4   = Sell Cargo screen (key "3")
                        ;   6   = Death screen
                        ;   8   = Status Mode screen (key "9")
                        ;         Inventory screen (key "0")
                        ;   13  = Rotating ship view (title or mission screen)
                        ;   16  = Market Price screen (key "8")
                        ;   32  = Equip Ship screen (key "4")
                        ;   64  = Long-range Chart (key "5")
                        ;   128 = Short-range Chart (key "6")
                        ;   255 = Launch view
                        ;
                        ; This value is typically set by calling routine TT66

.ZZ

 SKIP 1                 ; Temporary storage, typically used for distance values

.XX13

 SKIP 1                 ; Temporary storage, typically used in the line-drawing
                        ; routines

.MCNT

 SKIP 1                 ; The main loop counter
                        ;
                        ; This counter determines how often certain actions are
                        ; performed within the main loop. See the deep dive on
                        ; "Scheduling tasks with the main loop counter" for more
                        ; details

.DL

 SKIP 1                 ; Vertical sync flag
                        ;
                        ; DL gets set to 30 every time we reach vertical sync on
                        ; the video system, which happens 50 times a second
                        ; (50Hz). The WSCAN routine uses this to pause until the
                        ; vertical sync, by setting DL to 0 and then monitoring
                        ; its value until it changes to 30

.TYPE

 SKIP 1                 ; The current ship type
                        ;
                        ; This is where we store the current ship type for when
                        ; we are iterating through the ships in the local bubble
                        ; as part of the main flight loop. See the table at XX21
                        ; for information about ship types

.ALPHA

 SKIP 1                 ; The current roll angle alpha, which is reduced from
                        ; JSTX to a sign-magnitude value between -31 and +31
                        ;
                        ; This describes how fast we are rolling our ship, and
                        ; determines how fast the universe rolls around us
                        ;
                        ; The sign bit is also stored in ALP2, while the
                        ; opposite sign is stored in ALP2+1

;.PBUP                  ; These instructions are commented out in the original
;                       ; source
;SKIP 1

;.HBUP                  ; These instructions are commented out in the original
;                       ; source
;SKIP 1

;.LBUP                  ; These instructions are commented out in the original
;                       ; source
;SKIP 1

.QQ12

 SKIP 1                 ; Our "docked" status
                        ;
                        ;   * 0 = we are not docked
                        ;
                        ;   * $FF = we are docked

.TGT

 SKIP 1                 ; Temporary storage, typically used as a target value
                        ; for counters when drawing explosion clouds and partial
                        ; circles

.FLAG

 SKIP 1                 ; A flag that's used to define whether this is the first
                        ; call to the ball line routine in BLINE, so it knows
                        ; whether to wait for the second call before storing
                        ; segment data in the ball line heap

.CNT

 SKIP 1                 ; Temporary storage, typically used for storing the
                        ; number of iterations required when looping

.CNT2

 SKIP 1                 ; Temporary storage, used in the planet-drawing routine
                        ; to store the segment number where the arc of a partial
                        ; circle should start

.STP

 SKIP 1                 ; The step size for drawing circles
                        ;
                        ; Circles in Elite are split up into 64 points, and the
                        ; step size determines how many points to skip with each
                        ; straight-line segment, so the smaller the step size,
                        ; the smoother the circle. The values used are:
                        ;
                        ;   * 2 for big planets and the circles on the charts
                        ;   * 4 for medium planets and the launch tunnel
                        ;   * 8 for small planets and the hyperspace tunnel
                        ;
                        ; As the step size increases we move from smoother
                        ; circles at the top to more polygonal at the bottom.
                        ; See the CIRCLE2 routine for more details

.XX4

 SKIP 1                 ; Temporary storage, used in a number of places

.XX20

 SKIP 1                 ; Temporary storage, used in a number of places

.LSNUM

 SKIP 1                 ; The pointer to the current position in the ship line
                        ; heap as we work our way through the new ship's edges
                        ; (and the corresponding old ship's edges) when drawing
                        ; the ship in the main ship-drawing routine at LL9

.LSNUM2

 SKIP 1                 ; The size of the existing ship line heap for the ship
                        ; we are drawing in LL9, i.e. the number of lines in the
                        ; old ship that is currently shown on-screen and which
                        ; we need to erase

.RAT

 SKIP 1                 ; Used to store different signs depending on the current
                        ; space view, for use in calculating stardust movement

.RAT2

 SKIP 1                 ; Temporary storage, used to store the pitch and roll
                        ; signs when moving objects and stardust

.K2

 SKIP 4                 ; Temporary storage, used in a number of places

.widget

 SKIP 1                 ; Temporary storage, used to store the original argument
                        ; in A in the logarithmic FMLTU and LL28 routines

.dontclip

 SKIP 1                 ; This is set to 0 in the RES2 routine, but the value is
                        ; never actually read

.Yx2M1

 SKIP 1                 ; This is used to store the number of pixel rows in the
                        ; space view minus 1, which is also the y-coordinate of
                        ; the bottom pixel row of the space view (it is set to
                        ; 191 in the RES2 routine)

.text                   ; ???

 SKIP 1

.messXC

 SKIP 1                 ; Temporary storage, used to store the text column
                        ; of the in-flight message in MESS, so it can be erased
                        ; from the screen at the correct time

.newzp

 SKIP 1                 ; This is used by the STARS2 routine for storing the
                        ; stardust particle's delta_x value

.T

 SKIP 1                 ; Temporary storage, used in a number of places

.JSTX

 SKIP 1                 ; Our current roll rate
                        ;
                        ; This value is shown in the dashboard's RL indicator,
                        ; and determines the rate at which we are rolling
                        ;
                        ; The value ranges from 1 to 255 with 128 as the centre
                        ; point, so 1 means roll is decreasing at the maximum
                        ; rate, 128 means roll is not changing, and 255 means
                        ; roll is increasing at the maximum rate
                        ;
                        ; This value is updated by "<" and ">" key presses, or
                        ; if joysticks are enabled, from the joystick. If
                        ; keyboard damping is enabled (which it is by default),
                        ; the value is slowly moved towards the centre value of
                        ; 128 (no roll) if there are no key presses or joystick
                        ; movement

.JSTY

 SKIP 1                 ; Our current pitch rate
                        ;
                        ; This value is shown in the dashboard's DC indicator,
                        ; and determines the rate at which we are pitching
                        ;
                        ; The value ranges from 1 to 255 with 128 as the centre
                        ; point, so 1 means pitch is decreasing at the maximum
                        ; rate, 128 means pitch is not changing, and 255 means
                        ; pitch is increasing at the maximum rate
                        ;
                        ; This value is updated by "S" and "X" key presses, or
                        ; if joysticks are enabled, from the joystick. If
                        ; keyboard damping is enabled (which it is by default),
                        ; the value is slowly moved towards the centre value of
                        ; 128 (no pitch) if there are no key presses or joystick
                        ; movement

.LSX

 SKIP 1                 ; LSX contains the status of the sun line heap at LSO
                        ;
                        ;   * $FF indicates the sun line heap is empty
                        ;
                        ;   * Otherwise the LSO heap contains the line data for
                        ;     the sun

.FSH

 SKIP 1                 ; Forward shield status
                        ;
                        ;   * 0 = empty
                        ;
                        ;   * $FF = full

.ASH

 SKIP 1                 ; Aft shield status
                        ;
                        ;   * 0 = empty
                        ;
                        ;   * $FF = full

.ENERGY

 SKIP 1                 ; Energy bank status
                        ;
                        ;   * 0 = empty
                        ;
                        ;   * $FF = full

.QQ3

 SKIP 1                 ; The selected system's economy (0-7)
                        ;
                        ;   * 0 = Rich Industrial
                        ;   * 1 = Average Industrial
                        ;   * 2 = Poor Industrial
                        ;   * 3 = Mainly Industrial
                        ;   * 4 = Mainly Agricultural
                        ;   * 5 = Rich Agricultural
                        ;   * 6 = Average Agricultural
                        ;   * 7 = Poor Agricultural
                        ;
                        ; See the deep dive on "Generating system data" for more
                        ; information on economies

.QQ4

 SKIP 1                 ; The selected system's government (0-7)
                        ;
                        ; See the deep dive on "Generating system data" for more
                        ; details of the various government types

.QQ5

 SKIP 1                 ; The selected system's tech level (0-14)
                        ;
                        ; See the deep dive on "Generating system data" for more
                        ; information on tech levels

.QQ6

 SKIP 2                 ; The selected system's population in billions * 10
                        ; (1-71), so the maximum population is 7.1 billion
                        ;
                        ; See the deep dive on "Generating system data" for more
                        ; details on population levels

.QQ7

 SKIP 2                 ; The selected system's productivity in M CR (96-62480)
                        ;
                        ; See the deep dive on "Generating system data" for more
                        ; details about productivity levels

.QQ8

 SKIP 2                 ; The distance from the current system to the selected
                        ; system in light years * 10, stored as a 16-bit number
                        ;
                        ; The distance will be 0 if the selected system is the
                        ; current system
                        ;
                        ; The galaxy chart is 102.4 light years wide and 51.2
                        ; light years tall (see the intra-system distance
                        ; calculations in routine TT111 for details), which
                        ; equates to 1024 x 512 in terms of QQ8

.QQ9

 SKIP 1                 ; The galactic x-coordinate of the crosshairs in the
                        ; galaxy chart (and, most of the time, the selected
                        ; system's galactic x-coordinate)

.QQ10

 SKIP 1                 ; The galactic y-coordinate of the crosshairs in the
                        ; galaxy chart (and, most of the time, the selected
                        ; system's galactic y-coordinate)

.NOSTM

 SKIP 1                 ; The number of stardust particles shown on screen,
                        ; which is 12 (#NOST) for normal space, and 3 for
                        ; witchspace

 PRINT "ZP workspace from ", ~ZP, "to ", ~P%-1, "inclusive"

; ******************************************************************************
;
;       Name: XX3
;       Type: Workspace
;    Address: $0100 to the top of the descending stack
;   Category: Workspaces
;    Summary: Temporary storage space for complex calculations
;
; ------------------------------------------------------------------------------
;
; Used as heap space for storing temporary data during calculations. Shared with
; the descending 6502 stack, which works down from $01FF.
;
; ******************************************************************************

 ORG $0100

.XX3

 SKIP 256               ; Temporary storage, typically used for storing tables
                        ; of values such as screen coordinates or ship data

; ******************************************************************************
;
;       Name: K%
;       Type: Workspace
;    Address: $0800 to $0927
;   Category: Workspaces
;    Summary: Ship data blocks and ship line heaps
;  Deep dive: Ship data blocks
;             The local bubble of universe
;
; ------------------------------------------------------------------------------
;
;
; See the deep dive on "Ship data blocks" for details on ship data blocks, and
; the deep dive on "The local bubble of universe" for details of how Elite
; stores the local universe in K%, FRIN and UNIV.
;
; ******************************************************************************

 ORG $0800

.K%

 SKIP NOSH * NI%        ; Ship data blocks and ship line heap

 PRINT "K% workspace from ", ~K%, "to ", ~P%-1, "inclusive"

; ******************************************************************************
;
;       Name: UP
;       Type: Workspace
;    Address: $0200 to $0301
;   Category: Workspaces
;    Summary: Configuration variables
;
; ******************************************************************************

 ORG $0200

.UP

 SKIP 0                 ; The start of the UP workspace

;.QQ16

 SKIP 65                ; This QQ16 label is present in the original source, but
                        ; it is overridden by the QQ16 label in the Elite A
                        ; section, so this declaration has no effect. BeebAsm
                        ; does not allow labels to be defined twice, so this one
                        ; is commented out

.FRIN

 SKIP NOSH + 1          ; Slots for the ships in the local bubble of universe
                        ;
                        ; There are #NOSH + 1 slots, but the ship-spawning
                        ; routine at NWSHP only populates #NOSH of them, so
                        ; (the last slot is effectively used as a null
                        ; terminator when shuffling the slots down in the
                        ; KILLSHP routine)
                        ;
                        ; See the deep dive on "The local bubble of universe"
                        ; for details of how Elite stores the local universe in
                        ; FRIN, UNIV and K%

.MANY

 SKIP SST               ; The number of ships of each type in the local bubble
                        ; of universe
                        ;
                        ; The number of ships of type X in the local bubble is
                        ; stored at MANY+X
                        ;
                        ; See the deep dive on "Ship blueprints" for a list of
                        ; ship types

.SSPR

 SKIP NTY + 1 - SST     ; "Space station present" flag
                        ;
                        ;   * Non-zero if we are inside the space station's safe
                        ;     zone
                        ;
                        ;
                        ; This flag is at MANY+SST, which is no coincidence, as
                        ; MANY+SST is a count of how many space stations there
                        ; are in our local bubble, which is the same as saying
                        ; "space station present"

.JUNK

 SKIP 1                 ; The amount of junk in the local bubble
                        ;
                        ; "Junk" is defined as being one of these:
                        ;
                        ;   * Escape pod
                        ;   * Alloy plate
                        ;   * Cargo canister
                        ;   * Asteroid
                        ;   * Splinter
                        ;   * Shuttle
                        ;   * Transporter

.auto

 SKIP 1                 ; Docking computer activation status
                        ;
                        ;   * 0 = Docking computer is off
                        ;
                        ;   * Non-zero = Docking computer is running

.ECMP

 SKIP 1                 ; Our E.C.M. status
                        ;
                        ;   * 0 = E.C.M. is off
                        ;
                        ;   * Non-zero = E.C.M. is on

.MJ

 SKIP 1                 ; Are we in witchspace (i.e. have we mis-jumped)?
                        ;
                        ;   * 0 = no, we are in normal space
                        ;
                        ;   * $FF = yes, we are in witchspace

.CABTMP

 SKIP 1                 ; Cabin temperature
                        ;
                        ; The ambient cabin temperature in deep space is 30,
                        ; which is displayed as one notch on the dashboard bar
                        ;
                        ; We get higher temperatures closer to the sun
                        ;
                        ; CABTMP shares a location with MANY, but that's OK as
                        ; MANY+0 would contain the number of ships of type 0,
                        ; and as there is no ship type 0 (they start at 1), the
                        ; byte at MANY+0 is not used for storing a ship type
                        ; and can be used for the cabin temperature instead

.LAS2

 SKIP 1                 ; Laser power for the current laser
                        ;
                        ;   * Bits 0-6 contain the laser power of the current
                        ;     space view
                        ;
                        ;   * Bit 7 denotes whether or not the laser pulses:
                        ;
                        ;     * 0 = pulsing laser
                        ;
                        ;     * 1 = beam laser (i.e. always on)

.MSAR

 SKIP 1                 ; The targeting state of our leftmost missile
                        ;
                        ;   * 0 = missile is not looking for a target, or it
                        ;     already has a target lock (indicator is not
                        ;     yellow/white)
                        ;
                        ;   * Non-zero = missile is currently looking for a
                        ;     target (indicator is yellow/white)

.VIEW

 SKIP 1                 ; The number of the current space view
                        ;
                        ;   * 0 = front
                        ;   * 1 = rear
                        ;   * 2 = left
                        ;   * 3 = right

.LASCT

 SKIP 1                 ; The laser pulse count for the current laser
                        ;
                        ; This is a counter that defines the gap between the
                        ; pulses of a pulse laser. It is set as follows:
                        ;
                        ;   * 0 for a beam laser
                        ;
                        ;   * 10 for a pulse laser
                        ;
                        ;
                        ; In comparison, beam lasers fire continuously as the
                        ; value of LASCT is always 0

.GNTMP

 SKIP 1                 ; Laser temperature (or "gun temperature")
                        ;
                        ; If the laser temperature exceeds 242 then the laser
                        ; overheats and cannot be fired again until it has
                        ; cooled down

.HFX

 SKIP 1                 ; This flag is unused in this version of Elite. In the
                        ; other versions, setting HFX to a non-zero value makes
                        ; the hyperspace rings multi-coloured, but ???

.EV

 SKIP 1                 ; The "extra vessels" spawning counter
                        ;
                        ; This counter is set to 0 on arrival in a system and
                        ; following an in-system jump, and is bumped up when we
                        ; spawn bounty hunters or pirates (i.e. "extra vessels")
                        ;
                        ; It decreases by 1 each time we consider spawning more
                        ; "extra vessels" in part 4 of the main game loop, so
                        ; increasing the value of EV has the effect of delaying
                        ; the spawning of more vessels
                        ;
                        ; In other words, this counter stops bounty hunters and
                        ; pirates from continually appearing, and ensures that
                        ; there's a delay between spawnings

.DLY

 SKIP 1                 ; In-flight message delay
                        ;
                        ; This counter is used to keep an in-flight message up
                        ; for a specified time before it gets removed. The value
                        ; in DLY is decremented each time we start another
                        ; iteration of the main game loop at TT100

.de

 SKIP 1                 ; Equipment destruction flag
                        ;
                        ;   * Bit 1 denotes whether or not the in-flight message
                        ;     about to be shown by the MESS routine is about
                        ;     destroyed equipment:
                        ;
                        ;     * 0 = the message is shown normally
                        ;
                        ;     * 1 = the string " DESTROYED" gets added to the
                        ;       end of the message

.LASX

 SKIP 1                 ; The x-coordinate of the tip of the laser line

.LASY

 SKIP 1                 ; The y-coordinate of the tip of the laser line

.XX24

 SKIP 1                 ; This byte appears to be unused

.ALTIT

 SKIP 1                 ; Our altitude above the surface of the planet or sun
                        ;
                        ;   * 255 = we are a long way above the surface
                        ;
                        ;   * 1-254 = our altitude as the square root of:
                        ;
                        ;       x_hi^2 + y_hi^2 + z_hi^2 - 6^2
                        ;
                        ;     where our ship is at the origin, the centre of the
                        ;     planet/sun is at (x_hi, y_hi, z_hi), and the
                        ;     radius of the planet/sun is 6
                        ;
                        ;   * 0 = we have crashed into the surface

.SWAP

 SKIP 1                 ; Temporary storage, used to store a flag that records
                        ; whether or not we had to swap a line's start and end
                        ; coordinates around when clipping the line in routine
                        ; LL145 (the flag is used in places like BLINE to swap
                        ; them back)

.XP

 SKIP 1                 ; The x-coordinate of the current character as we
                        ; construct the lines for the Star Wars scroll text

.YP

 SKIP 1                 ; The y-coordinate of the current character as we
                        ; construct the lines for the Star Wars scroll text

.YS

 SKIP 1                 ; Temporary storage for saving the index into the TB
                        ; tables in the SLIDE routine

.BALI

 SKIP 1                 ; The progress of the Star Wars scroll text as it
                        ; scrolls, from 254 (off the bottom of the screen) to 2
                        ; (fully scrolled). Can also be thought of as a measure
                        ; of how much of the scroll text has yet to appear
                        ; on-screen

.UPO

 SKIP 1                 ; Used as an index into the UB tables when projecting
                        ; the scroll text lines onto the Star Wars perspective
                        ; view and then onto the screen

.boxsize

 SKIP 1                 ; This byte appears to be unused

.distaway

 SKIP 1                 ; Used to store the nearest distance of the rotating
                        ; ship on the title screen

.XSAV2

 SKIP 1                 ; This byte appears to be unused

.YSAV2

 SKIP 1                 ; This byte appears to be unused

.NAME

 SKIP 8                 ; The current commander name
                        ;
                        ; The commander name can be up to 7 characters (the DFS
                        ; limit for filenames), and is terminated by a carriage
                        ; return

.TP

 SKIP 1                 ; The current mission status
                        ;
                        ;   * Bits 0-1 = Mission 1 status
                        ;
                        ;     * %00 = Mission not started
                        ;     * %01 = Mission in progress, hunting for ship
                        ;     * %11 = Constrictor killed, not debriefed yet
                        ;     * %10 = Mission and debrief complete
                        ;
                        ;   * Bits 2-3 = Mission 2 status
                        ;
                        ;     * %00 = Mission not started
                        ;     * %01 = Mission in progress, plans not picked up
                        ;     * %10 = Mission in progress, plans picked up
                        ;     * %11 = Mission complete

.QQ0

 SKIP 1                 ; The current system's galactic x-coordinate (0-256)

.QQ1

 SKIP 1                 ; The current system's galactic y-coordinate (0-256)

.QQ21

 SKIP 6                 ; The three 16-bit seeds for the current galaxy
                        ;
                        ; These seeds define system 0 in the current galaxy, so
                        ; they can be used as a starting point to generate all
                        ; 256 systems in the galaxy
                        ;
                        ; Using a galactic hyperdrive rotates each byte to the
                        ; left (rolling each byte within itself) to get the
                        ; seeds for the next galaxy, so after eight galactic
                        ; jumps, the seeds roll around to the first galaxy again
                        ;
                        ; See the deep dives on "Galaxy and system seeds" and
                        ; "Twisting the system seeds" for more details

.CASH

 SKIP 4                 ; Our current cash pot
                        ;
                        ; The cash stash is stored as a 32-bit unsigned integer,
                        ; with the most significant byte in CASH and the least
                        ; significant in CASH+3. This is big-endian, which is
                        ; the opposite way round to most of the numbers used in
                        ; Elite - to use our notation for multi-byte numbers,
                        ; the amount of cash is CASH(0 1 2 3)

.QQ14

 SKIP 1                 ; Our current fuel level (0-70)
                        ;
                        ; The fuel level is stored as the number of light years
                        ; multiplied by 10, so QQ14 = 1 represents 0.1 light
                        ; years, and the maximum possible value is 70, for 7.0
                        ; light years

.COK

 SKIP 1                 ; Flags used to generate the competition code
                        ;
                        ; See the deep dive on "The competition code" for
                        ; details of these flags and how they are used in
                        ; generating and decoding the competition code

.GCNT

 SKIP 1                 ; The number of the current galaxy (0-7)
                        ;
                        ; When this is displayed in-game, 1 is added to the
                        ; number, so we start in galaxy 1 in-game, but it's
                        ; stored as galaxy 0 internally
                        ;
                        ; The galaxy number increases by one every time a
                        ; galactic hyperdrive is used, and wraps back around to
                        ; the start after eight galaxies

.LASER

 SKIP 4                 ; The specifications of the lasers fitted to each of the
                        ; four space views:
                        ;
                        ;   * Byte #0 = front view
                        ;   * Byte #1 = rear view
                        ;   * Byte #2 = left view
                        ;   * Byte #3 = right view
                        ;
                        ; For each of the views:
                        ;
                        ;   * 0 = no laser is fitted to this view
                        ;
                        ;   * Non-zero = a laser is fitted to this view, with
                        ;     the following specification:
                        ;
                        ;     * Bits 0-6 contain the laser's power
                        ;
                        ;     * Bit 7 determines whether or not the laser pulses
                        ;       (0 = pulse or mining laser) or is always on
                        ;       (1 = beam or military laser)

 SKIP 2                 ; These bytes appear to be unused (they were originally
                        ; used for up/down lasers, but they were dropped)

.CRGO

 SKIP 1                 ; Our ship's cargo capacity
                        ;
                        ;   * 22 = standard cargo bay of 20 tonnes
                        ;
                        ;   * 37 = large cargo bay of 35 tonnes
                        ;
                        ; The value is two greater than the actual capacity to
                        ; make the maths in tnpr slightly more efficient

.QQ20

 SKIP 17                ; The contents of our cargo hold
                        ;
                        ; The amount of market item X that we have in our hold
                        ; can be found in the X-th byte of QQ20. For example:
                        ;
                        ;   * QQ20 contains the amount of food (item 0)
                        ;
                        ;   * QQ20+7 contains the amount of computers (item 7)
                        ;
                        ; See QQ23 for a list of market item numbers and their
                        ; storage units

.ECM

 SKIP 1                 ; E.C.M. system
                        ;
                        ;   * 0 = not fitted
                        ;
                        ;   * $FF = fitted

.BST

 SKIP 1                 ; Fuel scoops (BST stands for "barrel status")
                        ;
                        ;   * 0 = not fitted
                        ;
                        ;   * $FF = fitted

.BOMB

 SKIP 1                 ; Energy bomb
                        ;
                        ;   * 0 = not fitted
                        ;
                        ;   * $7F = fitted

.ENGY

 SKIP 1                 ; Energy unit
                        ;
                        ;   * 0 = not fitted
                        ;
                        ;   * Non-zero = fitted
                        ;
                        ; The actual value determines the refresh rate of our
                        ; energy banks, as they refresh by ENGY+1 each time (so
                        ; our ship's energy level goes up by 2 each time if we
                        ; have an energy unit fitted, otherwise it goes up by 1)

.DKCMP

 SKIP 1                 ; Docking computer
                        ;
                        ;   * 0 = not fitted
                        ;
                        ;   * $FF = fitted

.GHYP

 SKIP 1                 ; Galactic hyperdrive
                        ;
                        ;   * 0 = not fitted
                        ;
                        ;   * $FF = fitted

.ESCP

 SKIP 1                 ; Escape pod
                        ;
                        ;   * 0 = not fitted
                        ;
                        ;   * $FF = fitted

 SKIP 1                 ; This byte appears to be unused

.TRIBBLE

 SKIP 2                 ; The number of Trumbles in the cargo hold

.TALLYL

 SKIP 1                 ; Combat rank fraction
                        ;
                        ; Contains the fraction part of the kill count, which
                        ; together with the integer in TALLY(1 0) determines our
                        ; combat rank. The fraction is stored as the numerator
                        ; of a fraction with a denominator of 256, so a TALLYL
                        ; of 128 would represent 0.5 (i.e. 128 / 256)

.NOMSL

 SKIP 1                 ; The number of missiles we have fitted (0-4)

.FIST

 SKIP 1                 ; Our legal status (FIST stands for "fugitive/innocent
                        ; status"):
                        ;
                        ;   * 0 = Clean
                        ;
                        ;   * 1-49 = Offender
                        ;
                        ;   * 50+ = Fugitive
                        ;
                        ; You get 64 points if you kill a cop, so that's a fast
                        ; ticket to fugitive status

.AVL

 SKIP 17                ; Market availability in the current system
                        ;
                        ; The available amount of market item X is stored in
                        ; the X-th byte of AVL, so for example:
                        ;
                        ;   * AVL contains the amount of food (item 0)
                        ;
                        ;   * AVL+7 contains the amount of computers (item 7)
                        ;
                        ; See QQ23 for a list of market item numbers and their
                        ; storage units, and the deep dive on "Market item
                        ; prices and availability" for details of the algorithm
                        ; used for calculating each item's availability

.QQ26

 SKIP 1                 ; A random value used to randomise market data
                        ;
                        ; This value is set to a new random number for each
                        ; change of system, so we can add a random factor into
                        ; the calculations for market prices (for details of how
                        ; this is used, see the deep dive on "Market prices")

.TALLY

 SKIP 2                 ; Our combat rank
                        ;
                        ; The combat rank is stored as the number of kills, in a
                        ; 16-bit number TALLY(1 0) - so the high byte is in
                        ; TALLY+1 and the low byte in TALLY
                        ;
                        ; If the high byte in TALLY+1 is 0 then we have between
                        ; 0 and 255 kills, so our rank is Harmless, Mostly
                        ; Harmless, Poor, Average or Above Average, according to
                        ; the value of the low byte in TALLY:
                        ;
                        ;   Harmless        = %00000000 to %00000011 = 0 to 3
                        ;   Mostly Harmless = %00000100 to %00000111 = 4 to 7
                        ;   Poor            = %00001000 to %00001111 = 8 to 15
                        ;   Average         = %00010000 to %00011111 = 16 to 31
                        ;   Above Average   = %00100000 to %11111111 = 32 to 255
                        ;
                        ; If the high byte in TALLY+1 is non-zero then we are
                        ; Competent, Dangerous, Deadly or Elite, according to
                        ; the high byte in TALLY+1:
                        ;
                        ;   Competent       = 1           = 256 to 511 kills
                        ;   Dangerous       = 2 to 9      = 512 to 2559 kills
                        ;   Deadly          = 10 to 24    = 2560 to 6399 kills
                        ;   Elite           = 25 and up   = 6400 kills and up
                        ;
                        ; You can see the rating calculation in the STATUS
                        ; subroutine

.SVC

 SKIP 1                 ; The save count
                        ;
                        ; When a new commander is created, the save count gets
                        ; set to 128. This value gets halved each time the
                        ; commander file is saved, but it is otherwise unused.
                        ; It is presumably part of the security system for the
                        ; competition, possibly another flag to catch out
                        ; entries with manually altered commander files

 SKIP 2                 ; The commander file checksum
                        ;
                        ; These two bytes are reserved for the commander file
                        ; checksum, so when the current commander block is
                        ; copied from here to the last saved commander block at
                        ; NA%, CHK and CHK2 get overwritten

 SKIP 1                 ; The second commander file checksum
                        ;
                        ; This byte is reserved for the second commander file
                        ; checksum in CHK3

 NT% = SVC + 3 - TP     ; This sets the variable NT% to the size of the current
                        ; commander data block, which starts at TP and ends at
                        ; SVC+3 (inclusive), i.e. with the last checksum byte

.MCH

 SKIP 1                 ; The text token number of the in-flight message that is
                        ; currently being shown, and which will be removed by
                        ; the me2 routine when the counter in DLY reaches zero

.COMX

 SKIP 1                 ; The x-coordinate of the compass dot

.COMY

 SKIP 1                 ; The y-coordinate of the compass dot

.dialc

 SKIP 14                ; ???

.QQ24

 SKIP 1                 ; Temporary storage, used to store the current market
                        ; item's price in routine TT151

.QQ25

 SKIP 1                 ; Temporary storage, used to store the current market
                        ; item's availability in routine TT151

.QQ28

 SKIP 1                 ; The current system's economy (0-7)
                        ;
                        ;   * 0 = Rich Industrial
                        ;   * 1 = Average Industrial
                        ;   * 2 = Poor Industrial
                        ;   * 3 = Mainly Industrial
                        ;   * 4 = Mainly Agricultural
                        ;   * 5 = Rich Agricultural
                        ;   * 6 = Average Agricultural
                        ;   * 7 = Poor Agricultural
                        ;
                        ; See the deep dive on "Generating system data" for more
                        ; information on economies

.QQ29

 SKIP 1                 ; Temporary storage, used in a number of places

.gov

 SKIP 1                 ; The current system's government type (0-7)
                        ;
                        ; See the deep dive on "Generating system data" for
                        ; details of the various government types

.tek

 SKIP 1                 ; The current system's tech level (0-14)
                        ;
                        ; See the deep dive on "Generating system data" for more
                        ; information on tech levels

.SLSP

 SKIP 2                 ; The address of the bottom of the ship line heap
                        ;
                        ; The ship line heap is a descending block of memory
                        ; extended downwards by the NWSHP routine when adding
                        ; new ships (and their associated ship line heaps), in
                        ; which case SLSP is lowered to provide more heap space,
                        ; assuming there is enough free memory to do so

.QQ2

 SKIP 6                 ; The three 16-bit seeds for the current system, i.e.
                        ; the one we are currently in
                        ;
                        ; See the deep dives on "Galaxy and system seeds" and
                        ; "Twisting the system seeds" for more details

.safehouse

 SKIP 6                 ; Backup storage for the seeds for the selected system
                        ;
                        ; The seeds for the current system get stored here as
                        ; soon as a hyperspace is initiated, so we can fetch
                        ; them in the hyp1 routine. This fixes a bug in an
                        ; earlier version where you could hyperspace while
                        ; docking and magically appear in your destination
                        ; station

.frump

 SKIP 1                 ; Used to store the number of particles in the explosion
                        ; cloud, though the number is never actually used

 PRINT "UP workspace from ", ~UP, "to ", ~P%-1, "inclusive"

; ******************************************************************************
;
;       Name: WP
;       Type: Workspace
;    Address: $0400 to $0715
;   Category: Workspaces
;    Summary: Variables
;
; ******************************************************************************

 ORG $0400

.WP

 SKIP 0                 ; The start of the WP workspace

.LSX2

 SKIP 256               ; The ball line heap for storing x-coordinates (see the
                        ; deep dive on "The ball line heap" for details)

.LSY2

 SKIP 256               ; The ball line heap for storing y-coordinates (see the
                        ; deep dive on "The ball line heap" for details)

.LSO

 SKIP 200               ; The ship line heap for the space station (see NWSPS)
                        ; and the sun line heap (see SUN)
                        ;
                        ; The spaces can be shared as our local bubble of
                        ; universe can support either the sun or a space
                        ; station, but not both

.SX

 SKIP NOST + 1          ; This is where we store the x_hi coordinates for all
                        ; the stardust particles

.SXL

 SKIP NOST + 1          ; This is where we store the x_lo coordinates for all
                        ; the stardust particles

.SY

 SKIP NOST + 1          ; This is where we store the y_hi coordinates for all
                        ; the stardust particles

.SYL

 SKIP NOST + 1          ; This is where we store the y_lo coordinates for all
                        ; the stardust particles

.SZ

 SKIP NOST + 1          ; This is where we store the z_hi coordinates for all
                        ; the stardust particles

.SZL

 SKIP NOST + 1          ; This is where we store the z_lo coordinates for all
                        ; the stardust particles

 PRINT "WP workspace from ", ~WP, "to ", ~P%-1, "inclusive"

; ******************************************************************************
;
; ELITE A FILE
;
; Produces the binary file ELTA.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 ORG CODE%

 LOAD_A% = LOAD%

 JMP S% ;@@

; ******************************************************************************
;
;       Name: log
;       Type: Variable
;   Category: Maths (Arithmetic)
;    Summary: Binary logarithm table (high byte)
;
; ------------------------------------------------------------------------------
;
; At byte n, the table contains the high byte of:
;
;   $2000 * log10(n) / log10(2) = 32 * 256 * log10(n) / log10(2)
;
; where log10 is the logarithm to base 10. The change-of-base formula says that:
;
;   log2(n) = log10(n) / log10(2)
;
; so byte n contains the high byte of:
;
;   32 * log2(n) * 256
;
; ******************************************************************************

.log

IF _MATCH_ORIGINAL_BINARIES

 EQUB $08               ; This byte appears to be unused and just contains
                        ; random workspace noise left over from the BBC Micro
                        ; assembly process

 FOR I%, 1, 255

  B% = INT($2000 * LOG(I%) / LOG(2) + 0.5)

  EQUB B% DIV 256

 NEXT

ELSE

 SKIP 1

 FOR I%, 1, 255

  B% = INT($2000 * LOG(I%) / LOG(2) + 0.5)

  EQUB B% DIV 256

 NEXT

ENDIF

; ******************************************************************************
;
;       Name: logL
;       Type: Variable
;   Category: Maths (Arithmetic)
;    Summary: Binary logarithm table (low byte)
;
; ------------------------------------------------------------------------------
;
; Byte n contains the low byte of:
;
;   32 * log2(n) * 256
;
; ******************************************************************************

.logL

IF _MATCH_ORIGINAL_BINARIES

 EQUB $03               ; This byte appears to be unused and just contains
                        ; random workspace noise left over from the BBC Micro
                        ; assembly process

 FOR I%, 1, 255

  B% = INT($2000 * LOG(I%) / LOG(2) + 0.5)

  EQUB B% MOD 256

 NEXT

ELSE

 SKIP 1

 FOR I%, 1, 255

  B% = INT($2000 * LOG(I%) / LOG(2) + 0.5)

  EQUB B% MOD 256

 NEXT

ENDIF

; ******************************************************************************
;
;       Name: alogh
;       Type: Variable
;   Category: Maths (Arithmetic)
;    Summary: Binary antilogarithm table
;
; ------------------------------------------------------------------------------
;
; At byte n, the table contains:
;
;   2^((n / 2 + 128) / 16) / 256
;
; which equals:
;
;   2^(n / 32 + 8) / 256
;
; ******************************************************************************

.alogh

 FOR I%, 0, 255

  EQUB INT(2^((I% / 2 + 128) / 16) + 0.5) DIV 256

 NEXT

.SCTBX1

FOR I%, 0, 255

 EQUB (I% + 8) MOD 7

NEXT

.SCTBX2

FOR I%, 0, 255

 EQUB (I% + 8) DIV 7

NEXT

.wtable

 EQUD &9B9A9796
 EQUD &A69F9E9D
 EQUD &ADACABA7
 EQUD &B3B2AFAE
 EQUD &B7B6B5B4
 EQUD &BCBBBAB9
 EQUD &CBBFBEBD
 EQUD &D3CFCECD

 EQUD &DAD9D7D6
 EQUD &DEDDDCDB
 EQUD &E7E6E5DF
 EQUD &ECEBEAE9
 EQUD &F2EFEEED
 EQUD &F6F5F4F3
 EQUD &FBFAF9F7
 EQUD &FFFEFDFC
 
IF (P% - wtable) > (P% AND $FF)
 ERROR "Wtable crosses page bndry."
ENDIF

.COMC

 SKIP 1

.dials

 EQUD 0
 EQUD 0
 EQUD 0
 EQUW 0

.mscol

 EQUD 0

.DFLAG

 SKIP 1

.DNOIZ

 SKIP 1

.DAMP

 SKIP 1 ; D

.DJD

 SKIP 1 ; A

.PATG

 SKIP 1 ; X

.FLH

 SKIP 1 ; F

.JSTGY

IF _IB_DISK

 EQUB $FF

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 SKIP 1 ; Y

ENDIF

.JSTE

 SKIP 1 ; J

.JSTK

 SKIP 1 ; K

.UPTOG

 SKIP 1 ; U

.DISK

 SKIP 1 ; T

.MULIE

 SKIP 1

IF _IB_DISK

 EQUB $0B

ENDIF

.TGINT

 EQUS "DAXFYJKUT"
 RTS  ;checksum here

.S%

IF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 CLD

ENDIF

 LDA #STORE MOD 256
 STA SC
 LDA #STORE DIV 256
 STA SC+1
 LDA #CODE2 MOD 256
 STA P
 LDA #CODE2 DIV 256
 STA P+1

IF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 LDA $C08B ; RAM card

ENDIF

IF _IB_DISK

 LDX #7

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 LDX #($C0-$90)

ENDIF

 LDY #0

.Sept3

 LDA (SC),Y
 STA (P),Y
 INY
 BNE Sept3
 INC SC+1
 INC P+1
 DEX

IF _IB_DISK

 BPL Sept3

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 BNE Sept3

ENDIF

IF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 LDA $C081 ; ROMs

ENDIF

 JSR DEEOR
;JSR Checksum

IF _IB_DISK

 LDA #$30
 STA $8342
 NOP
 NOP

ENDIF

 JSR COLD
 JMP BEGIN
 \

.DEEOR

 LDA #((G%-1)MOD 256)
 STA FRIN
 LDA #((G%-1)DIV 256)
 STA FRIN+1
 LDA #((R%-1)DIV 256)
 LDY #((R%-1)MOD 256)
 LDX #KEY1
 JSR DEEORS
 LDA #((QQ18-1)MOD 256)
 STA FRIN
 LDA #((QQ18-1)DIV 256)
 STA FRIN+1
 LDA #$1F
 LDY #$FF
 LDX #KEY2

.DEEORS

 STX T
 STA SC+1
 LDA #0
 STA SC

.DEEORL

 LDA (SC),Y
 SEC
 SBC T
 STA (SC),Y
 STA T
 TYA
 BNE P%+4
 DEC SC+1
 DEY
 CPY FRIN
 BNE DEEORL
 LDA SC+1
 CMP FRIN+1
 BNE DEEORL
 RTS
 EQUD &2345AAB7 ;red herring
 \

.G%

 \mutilate from here to R%

.DOENTRY

 \after dock
 JSR RES2
 JSR LAUN
 LDA #0
 STA DELTA
;STA ALPHA
;STA BETA
;STA ALP1
;STA BET1
 STA GNTMP
 STA QQ22+1
 LDA #$FF
 STA FSH
 STA ASH
 STA ENERGY
;JSR HALL
 LDY #44
 JSR DELAY
 LDA TP
 AND #3
 BNE EN1
 LDA TALLY+1
 BEQ EN4
 LDA GCNT
 LSR A
 BNE EN4
 JMP BRIEF

.EN1

 CMP #3
 BNE EN2
 JMP DEBRIEF

.EN2

 LDA GCNT
 CMP #2
 BNE EN4
 LDA TP
 AND #$F
 CMP #2
 BNE EN3
 LDA TALLY+1
 CMP #5
 BCC EN4
 JMP BRIEF2

.EN3

 CMP #6
 BNE EN5
 LDA QQ0
 CMP #215
 BNE EN4
 LDA QQ1
 CMP #84
 BNE EN4
 JMP BRIEF3

.EN5

 CMP #10
 BNE EN4
 LDA QQ0
 CMP #63
 BNE EN4
 LDA QQ1
 CMP #72
 BNE EN4
 JMP DEBRIEF2

.EN4

;LDA CASH+2
;CMP #$C4
;BCC EN6
;LDA TP
;AND #$10
;BNE EN6
;JMP TBRIEF
 \.EN6
 JMP BAY

.BRKBK

 LDA #(BRBR MOD 256)
 SEI
 STA BRKV
 LDA #(BRBR DIV 256)
 STA BRKV+1
 CLI
 RTS
;TRIBDIR
;EQUB 0
;EQUB 1
;EQUB $FF
;EQUB 0
;TRIBDIRH
;EQUB 0
;EQUB 0
;EQUB $FF
;EQUB 0

.SPMASK

 EQUW $04FB
 EQUW $08F7
 EQUW $10EF
 EQUW $20DF
 EQUW $40BF
 EQUW $807F
;MVT RIBS
;MVT R1
;nom inus
 \....

.M%

 LDA K%
 STA RAND
;LDA TRIBCT
;BEQ NOMVETR
;JMP MVTRIBS
 \.NOMVETR
 LDX JSTX
 JSR cntr
 JSR cntr
 TXA
 EOR #128
 TAY
 AND #128
 STA ALP2
 STX JSTX
 EOR #128
 STA ALP2+1
 TYA
 BPL P%+7
 EOR #$FF
 CLC
 ADC #1
 LSR A
 LSR A
 CMP #8
 BCS P%+3
 LSR A
 STA ALP1
 ORA ALP2
 STA ALPHA
 LDX JSTY
 JSR cntr
 TXA
 EOR #128
 TAY
 AND #128
 STX JSTY
 STA BET2+1
 EOR #128
 STA BET2
 TYA
 BPL P%+4
 EOR #$FF
 ADC #4
 LSR A
 LSR A
 LSR A
 LSR A
 CMP #3
 BCS P%+3
 LSR A
 STA BET1
 ORA BET2
 STA BETA
 LDA KY2
 BEQ MA17
 LDA DELTA
 CMP #40
 BCS MA17
 INC DELTA

.MA17

 LDA KY1
 BEQ MA4
 DEC DELTA
 BNE MA4
 INC DELTA

.MA4

 LDA KY15
 AND NOMSL
 BEQ MA20
 LDY #GREEN
 JSR ABORT
 JSR BOOP ; @@
 LDA #0
 STA MSAR

.MA20

 LDA MSTG
 BPL MA25
 LDA KY14
 BEQ MA25
 LDX NOMSL
 BEQ MA25
 STA MSAR
 LDY #WHITE
 JSR MSBAR

.MA25

 LDA KY16
 BEQ MA24
 LDA MSTG
 BMI MA64
 JSR FRMIS

.MA24

 LDA KY12
 BEQ MA76

IF _IB_DISK

 LDA $02B9
 BMI MA76

ENDIF

 ASL BOMB
 BEQ MA76
 JSR BOMBON ;@@

.MA76

 LDA KY20
 BEQ MA78
 LDA #0
 STA auto
;JSR stopbd

.MA78

 LDA KY13
 AND ESCP
 BEQ noescp
 LDA MJ
 BNE noescp
 JMP ESCAPE

.noescp

 LDA KY18
 BEQ P%+5
 JSR WARP
 LDA KY17
 AND ECM
 BEQ MA64
 LDA ECMA
 BNE MA64
 DEC ECMP
 JSR ECBLB2

.MA64

 LDA KY19
 AND DKCMP
 BEQ MA68

IF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES

;EOR KLO+$29
;BEQ MA68

ELIF _SOURCE_DISK_CODE_FILES

 EOR KLO+$29
 BEQ MA68

ENDIF

 STA auto
;JSR startbd

.MA68

 \kill phantom Cs
 LDA #0
 STA LAS
 STA DELT4
 LDA DELTA
 LSR A
 ROR DELT4
 LSR A
 ROR DELT4
 STA DELT4+1
 LDA LASCT
 BNE MA3
 LDA KY7
 BEQ MA3
 LDA GNTMP
 CMP #242
 BCS MA3
 LDX VIEW
 LDA LASER,X
 BEQ MA3
 PHA
 AND #127
 STA LAS
 STA LAS2
 JSR LASNOISE
 JSR LASLI
 PLA
 BPL ma1
 LDA #0

.ma1

 AND #$FA
 STA LASCT

.MA3

 LDX #0

.MAL1

 STX XSAV
 LDA FRIN,X
 BNE P%+5
 JMP MA18
 STA TYPE
 JSR GINF
 LDY #(NI%-1)

.MAL2

 LDA (INF),Y
 STA INWK,Y
 DEY
 BPL MAL2
 LDA TYPE
 BMI MA21
 ASL A
 TAY
 LDA XX21-2,Y
 STA XX0
 LDA XX21-1,Y
 STA XX0+1
 LDA BOMB
 BPL MA21
 CPY #2*SST
 BEQ MA21
 CPY #2*THG
 BEQ MA21
 CPY #2*CON
 BCS MA21
 LDA INWK+31
 AND #32
 BNE MA21
 ASL INWK+31
 SEC
 ROR INWK+31
 LDX TYPE
 JSR EXNO2

.MA21

 JSR MVEIT
 LDY #(NI%-1)

.MAL3

 LDA INWK,Y
 STA (INF),Y
 DEY
 BPL MAL3
 LDA INWK+31
 AND #$A0
 JSR MAS4
 BNE MA65
 LDA INWK
 ORA INWK+3
 ORA INWK+6
 BMI MA65
 LDX TYPE
 BMI MA65
 CPX #SST
 BEQ ISDK
 AND #$C0
 BNE MA65
 CPX #MSL
 BEQ MA65
 LDA BST
 AND INWK+5
 BPL MA58
 CPX #OIL
 BEQ oily
 LDY #0
 LDA (XX0),Y
 LSR A
 LSR A
 LSR A
 LSR A
 BEQ MA58
 ADC #1
 BNE slvy2

.oily

 JSR DORND
 AND #7

.slvy2

 JSR tnpr1
 LDY #78
 BCS MA59
 LDY QQ29
 ADC QQ20,Y
 STA QQ20,Y
 TYA
 ADC #208
 JSR MESS
 ASL NEWB
 SEC
 ROR NEWB

.MA65

 JMP MA26

.ISDK

 LDA K%+NI%+36
 AND #4
 BNE MA62
 LDA INWK+14
 CMP #$D6
 BCC MA62
 JSR SPS1
 LDA XX15+2
 CMP #89 ;86
 BCC MA62
 LDA INWK+16
 AND #$7F
 CMP #80
 BCC MA62

.GOIN

;JSR stopbd
 JMP DOENTRY

.MA62

 LDA DELTA
 CMP #5
 BCC MA67
 JMP DEATH

.MA59

 JSR EXNO3

.MA60

 ASL INWK+31
 SEC
 ROR INWK+31

.MA61

 BNE MA26

.MA67

 LDA #1
 STA DELTA
 LDA #5
 BNE MA63

.MA58

 ASL INWK+31
 SEC
 ROR INWK+31
 LDA INWK+35
 SEC
 ROR A

.MA63

 JSR OOPS
 JSR EXNO3

.MA26

 LDA NEWB
 BPL P%+5
 JSR SCAN
 LDA QQ11
 BNE MA15
 JSR PLUT
 JSR HITCH
 BCC MA8
 LDA MSAR
 BEQ MA47
 JSR BEEP
 LDX XSAV
 LDY #RED
 JSR ABORT2

.MA47

 LDA LAS
 BEQ MA8
 LDX #15
 JSR EXNO
 LDA TYPE
 CMP #SST
 BEQ MA14+2
 CMP #CON
 BCC BURN
 LDA LAS
 CMP #(Armlas AND127)
 BNE MA14+2
 LSR LAS
 LSR LAS

.BURN

 LDA INWK+35
 SEC
 SBC LAS
 BCS MA14
 ASL INWK+31
 SEC
 ROR INWK+31
 LDA TYPE
 CMP #AST
 BNE nosp
 LDA LAS
 CMP #Mlas
 BNE nosp
 JSR DORND
 LDX #SPL
 AND #3
 JSR SPIN2

.nosp

 LDY #PLT
 JSR SPIN
 LDY #OIL
 JSR SPIN
 LDX TYPE
 JSR EXNO2

.MA14

 STA INWK+35
 LDA TYPE
 JSR ANGRY

.MA8

 JSR LL9

.MA15

 LDY #35
 LDA INWK+35
 STA (INF),Y
 LDA NEWB
 BMI KS1S
 LDA INWK+31
 BPL MAC1
 AND #$20
 BEQ MAC1
 LDA NEWB
 AND #64
 ORA FIST
 STA FIST
 LDA DLY
 ORA MJ
 BNE KS1S
 LDY #10
 LDA (XX0),Y
 BEQ KS1S
 TAX
 INY
 LDA (XX0),Y
 TAY
 JSR MCASH
 LDA #0
 JSR MESS

.KS1S

 JMP KS1

.MAC1

 LDA TYPE
 BMI MA27
 JSR FAROF
 BCC KS1S

.MA27

 LDY #31
 LDA INWK+31
 STA (INF),Y
 LDX XSAV
 INX
 JMP MAL1

.MA18

 LDA BOMB
 BPL MA77
 JSR BOMBEFF2 ; @@
 ASL BOMB
 BMI MA77
 JSR BOMBOFF

.MA77

 LDA MCNT
 AND #7
 BNE MA22
 LDX ENERGY
 BPL b
 LDX ASH
 JSR SHD
 STX ASH
 LDX FSH
 JSR SHD
 STX FSH

.b

 SEC
 LDA ENGY
 ADC ENERGY
 BCS paen1
 STA ENERGY

.paen1

 LDA MJ
 BNE MA23S
 LDA MCNT
 AND #31
 BNE MA93
 LDA SSPR
 BNE MA23S
 TAY
 JSR MAS2
 BNE MA23S
 LDX #28

.MAL4

 LDA K%,X
 STA INWK,X
 DEX
 BPL MAL4
 INX
 LDY #9
 JSR MAS1
 BNE MA23S
 LDX #3
 LDY #11
 JSR MAS1
 BNE MA23S
 LDX #6
 LDY #13
 JSR MAS1
 BNE MA23S
 LDA #$C0
 JSR FAROF2
 BCC MA23S
 JSR WPLS
 JSR NWSPS

.MA23S

 JMP MA23

.MA22

 LDA MJ
 BNE MA23S
 LDA MCNT
 AND #31

.MA93

 CMP #10
 BNE MA29
 LDA #50
 CMP ENERGY
 BCC P%+6
 ASL A
 JSR MESS
 LDY #$FF
 STY ALTIT
 INY
 JSR m
 BNE MA23
 JSR MAS3
 BCS MA23
 SBC #$24
 BCC MA28
 STA R
 JSR LL5
 LDA Q
 STA ALTIT
 BNE MA23

.MA28

 JMP DEATH

.MA29

 CMP #15
 BNE MA33
 LDA auto
 BEQ MA23
 LDA #123
 BNE MA34

.MA33

 CMP #20
 BNE MA23
 LDA #30
 STA CABTMP
 LDA SSPR
 BNE MA23
 LDY #NI%
 JSR MAS2
 BNE MA23
 JSR MAS3
 EOR #$FF
 ADC #30
 STA CABTMP
 BCS MA28
 CMP #$E0
 BCC MA23
;CMP #$F0
;BCC nokilltr
;LDA #5
;JSR SETL1
;LDA VIC+$15
;AND #$3
;STA VIC+$15
;LDA #4
;JSR SETL1
;LSR TRIBBLE+1
;ROR TRIBBLE
 \.nokilltr
 LDA BST
 BEQ MA23
 LDA DELT4+1
 LSR A
 ADC QQ14
 CMP #70
 BCC P%+4
 LDA #70
 STA QQ14
 LDA #160

.MA34

 JSR MESS  ;--BT

.MA23

 LDA LAS2
 BEQ MA16
 LDA LASCT
 CMP #8
 BCS MA16
 JSR LASLI2
 LDA #0
 STA LAS2

.MA16

 LDA ECMP
 BEQ MA69
 JSR DENGY
 BEQ MA70

.MA69

 LDA ECMA
 BEQ MA66
 LDY #20
 ORA #192
 TAX
 JSR SOBLIP ; @@
 DEC ECMA
 BNE MA66

.MA70

 JSR ECMOF

.MA66

 LDA QQ11
 BNE oh
 JMP STARS
;JMP PBFL

.SPIN

 JSR DORND
 BPL oh
 TYA
 TAX
 LDY #0
 AND (XX0),Y
 AND #15

.SPIN2

 STA CNT

.spl

 BEQ oh
 LDA #0
 JSR SFS1
 DEC CNT
 BNE spl+2

.oh

 RTS

.BOMBOFF

 LDA QQ11
 BNE BOMBR1
 LDY #1
 LDA BOMBTBX
 STA XX12
 LDA BOMBTBY
 STA XX12+1

.BOMBL1

 JSR CLICK
 LDA XX12
 STA X1
 LDA XX12+1
 STA Y1
 LDA BOMBTBX,Y
 STA X2
 STA XX12
 LDA BOMBTBY,Y
 STA Y2
 STA XX12+1
 JSR LOIN
 INY
 CPY #10
 BCC BOMBL1

.BOMBR1

 RTS

.BOMBEFF2

 JSR P%+3
 JSR BOMBEFF

.BOMBEFF

 JSR SOBOMB
 JSR BOMBOFF

.BOMBON

 LDY #0

.BOMBL2

 JSR DORND
 AND #127
 ADC #3
 STA BOMBTBY,Y
 TXA
 AND #31
 CLC
 ADC BOMBPOS,Y
 STA BOMBTBX,Y
 INY
 CPY #10
 BCC BOMBL2
 LDX #0
 STX BOMBTBX+9
 DEX
 STX BOMBTBX
 BCS BOMBOFF

.BOMBPOS

 EQUD &A0C0E0E0
 EQUD &20406080
 EQUW 0

.BOMBTBX

 EQUD 0
 EQUD 0
 EQUW 0

.BOMBTBY

 EQUD 0
 EQUD 0
 EQUW 0

.MT27

 LDA #217
 BNE P%+4

.MT28

 LDA #220
 CLC
 ADC GCNT
 BNE DETOK

.DETOK3

 PHA
 TAX
 TYA
 PHA
 LDA V
 PHA
 LDA V+1
 PHA
 LDA #(RUTOK MOD 256)
 STA V
 LDA #(RUTOK DIV 256)
 BNE DTEN
 \.....................

.DETOK

 PHA
 TAX
 TYA
 PHA
 LDA V
 PHA
 LDA V+1
 PHA
 LDA #(TKN1 MOD 256)
 STA V
 LDA #(TKN1 DIV 256)

.DTEN

 STA V+1
 LDY #0

.DTL1

 LDA (V),Y
 EOR #VE
 BNE DT1
 DEX
 BEQ DTL2

.DT1

 INY
 BNE DTL1
 INC V+1
 BNE DTL1

.DTL2

 INY
 BNE P%+4
 INC V+1
 LDA (V),Y
 EOR #VE
 BEQ DTEX
 JSR DETOK2
 JMP DTL2

.DTEX

 PLA
 STA V+1
 PLA
 STA V
 PLA
 TAY
 PLA
 RTS
 \.............

.DETOK2

 CMP #32
 BCC DT3
 BIT DTW3
 BPL DT8
 TAX
 TYA
 PHA
 LDA V
 PHA
 LDA V+1
 PHA
 TXA
 JSR TT27
 JMP DT7 ;TT27

.DT8

 CMP #91
 BCC DTS
 CMP #129
 BCC DT6
 CMP #215
 BCC DETOK
 SBC #215
 ASL A
 PHA
 TAX
 LDA TKN2,X
 JSR DTS
 PLA
 TAX
 LDA TKN2+1,X ;letter pair

.DTS

 CMP #$41
 BCC DT9
 BIT DTW6
 BMI DT10
 BIT DTW2
 BMI DT5

.DT10

 ORA DTW1

.DT5

 AND DTW8

.DT9

 JMP DASC ;ascii

.DT3

 TAX
 TYA
 PHA
 LDA V
 PHA
 LDA V+1
 PHA  ;Magic
 TXA
 ASL A
 TAX
 LDA JMTB-2,X
 STA DTM+1
 LDA JMTB-1,X
 STA DTM+2
 TXA
 LSR A

.DTM

IF _IB_DISK

 JSR MT19

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 JSR DASC

ENDIF

.DT7

 PLA
 STA V+1
 PLA
 STA V
 PLA
 TAY
 RTS

.DT6

 STA SC
 TYA
 PHA
 LDA V
 PHA
 LDA V+1
 PHA
 JSR DORND
 TAX
 LDA #0
 CPX #51
 ADC #0
 CPX #102
 ADC #0
 CPX #153
 ADC #0
 CPX #204
 LDX SC
 ADC MTIN-91,X
 JSR DETOK
 JMP DT7 ;Multitoken
 \....................

.MT1

 LDA #0
 EQUB $2C

.MT2

 LDA #32
 STA DTW1
 LDA #0
 STA DTW6
 RTS

.MT8

 LDA #6

IF _IB_DISK

 STA XC

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 JSR DOXC

ENDIF

 LDA #$FF
 STA DTW2
 RTS

.MT9

 LDA #1
 STA XC
 JMP TT66

.MT13

 LDA #128
 STA DTW6
 LDA #32
 STA DTW1
 RTS

.MT6

 LDA #128
 STA QQ17
 LDA #$FF
 EQUB $2C

.MT5

 LDA #0
 STA DTW3
 RTS

.MT14

 LDA #128
 EQUB $2C

.MT15

 LDA #0
 STA DTW4
 ASL A
 STA DTW5
 RTS

.MT17

 LDA QQ17
 AND #191
 STA QQ17
 LDA #3
 JSR TT27
 LDX DTW5
 LDA BUF-1,X
 JSR VOWEL
 BCC MT171
 DEC DTW5

.MT171

 LDA #153
 JMP DETOK

.MT18

 JSR MT19
 JSR DORND
 AND #3
 TAY

.MT18L

 JSR DORND
 AND #62
 TAX
 LDA TKN2+2,X
 JSR DTS
 LDA TKN2+3,X
 JSR DTS
 DEY
 BPL MT18L
 RTS

.MT19

 LDA #$DF
 STA DTW8
 RTS

.VOWEL

 ORA #32
 CMP #'a'
 BEQ VRTS
 CMP #'e'
 BEQ VRTS
 CMP #'i'
 BEQ VRTS
 CMP #'o'
 BEQ VRTS
 CMP #'u'
 BEQ VRTS
 CLC

.VRTS

;RTS 

.WHITETEXT

;LDA #32
;JSR DOVDU19
;LDA #RED
;JMP DOCOL
 RTS
 \............

.JMTB

 EQUW MT1
 EQUW MT2
 EQUW TT27
 EQUW TT27
 EQUW MT5
 EQUW MT6
 EQUW DASC
 EQUW MT8
 EQUW MT9
 EQUW DASC
 EQUW NLIN4
 EQUW DASC
 EQUW MT13
 EQUW MT14
 EQUW MT15
 EQUW MT16
 EQUW MT17
 EQUW MT18
 EQUW MT19
 EQUW DASC
 EQUW CLYNS
 EQUW PAUSE
 EQUW MT23
 EQUW PAUSE2
 EQUW BRIS
 EQUW MT26
 EQUW MT27
 EQUW MT28
 EQUW MT29
 EQUW FILEPR
 EQUW OTHERFILEPR
 EQUW DASC
 \.............

.TKN2

 EQUB 12
 EQUB 10
 EQUS "ABOUSEITILETSTONLONUTHNO"

.QQ16

 EQUS "ALLEXEGEZACEBISOUSESARMAINDIREA?ERATENBERALAVETIEDORQUANTEISRION"
 \.............
 EQUS ":0.E."

.NA%

IF _IB_DISK

 EQUS ("JAMESON")

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 EQUS ("jameson")

ENDIF

 EQUB 13
 EQUB 0

IF _IB_DISK

 EQUD &5A4AAD14
 EQUD &B7530248
 EQUD &E8030000
 EQUW $0046
 EQUB 0 ;Fuel-Gal
 EQUD $0F
 EQUW 0
 EQUB $16 ;Laser-Cargo

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 EQUD 0
 EQUD 0 ;Base seed
 EQUD 0 ;Cash
 EQUW 0
 EQUB 0 ;Fuel-Gal
 EQUD 0
 EQUW 0
 EQUB 0 ;Laser-Cargo

ENDIF

 EQUD 0
 EQUD 0
 EQUD 0
 EQUD 0
 EQUB 0 ; crgo
 EQUD 0 ; ECM-ENGY
 EQUW 0
 EQUB 0 ;DCK-escp
 EQUD 0 ; EXPAND

IF _IB_DISK

 EQUB 3 ; MISSILES

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 EQUB 0 ; MISSILES

ENDIF

 EQUB 0 ; FIST
 EQUB 16
 EQUB 15
 EQUB 17
 EQUB 0
 EQUB 3
 EQUB 28
 EQUB 14
 EQUW 0
 EQUB 10
 EQUB 0
 EQUB 17
 EQUB 58
 EQUB 7
 EQUB 9
 EQUB 8
 EQUB 0
 EQUB 0 ;QQ26
 EQUW 0 ;TALLY
 EQUB 128 ;SVC

IF _IB_DISK

.CHK2

 EQUB $AA

.CHK3

 EQUB $27

.CHK

 EQUB $03

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

.CHK2

 EQUB 0

.CHK3

 EQUB 0

.CHK

 EQUB 0

ENDIF

 EQUD 0
 EQUD 0
 EQUD 0
 EQUD 0
 EQUD 0
 \.........

 \ZIP

.S1%

 EQUS ":0.E."

.NA2%

 EQUS ("JAMESON")
 EQUB 13
 EQUB 0
 EQUB 20 ; QQ0
 EQUB 173 ; QQ1
 EQUD &2485A4A ; QQ21
 EQUW $B753 ;Base seed
 EQUD (((&E8030000)AND(NOT(Q%)))+((&CA9A3B)AND Q%))\CASH,&80969800
 EQUB 70 ;fuel
 EQUB Q%AND128 ;COK-UP
 EQUB 0 ;GALACTIC COUNT
 EQUB (Armlas ANDQ%)+(POW AND(NOT(Q%)))
 EQUB (POW)AND Q%
 EQUB (POW+128)AND Q%
 EQUB Mlas AND Q%
 EQUW 0 ;LASER
 EQUB 22+(15 AND Q%) ;37 CRGO
 EQUD 0
 EQUD 0
 EQUD 0
 EQUD 0
 EQUB 0 ; crgo
 EQUB Q% ;ECM
 EQUB Q% ;BST
 EQUB Q%AND127 ;BOMB
 EQUB Q%AND1 ;ENGY++
 EQUB Q% ;DCK COMP
 EQUB Q% ;GHYP
 EQUB Q% ;ESCP
 EQUD FALSE ;EXPAND
 EQUB 3+(Q%AND1) ;MISSILES
 EQUB FALSE ;FIST
 EQUB 16
 EQUB 15
 EQUB 17
 EQUB 0
 EQUB 3
 EQUB 28
 EQUB 14
 EQUW 0
 EQUB 10
 EQUB 0
 EQUB 17
 EQUB 58
 EQUB 7
 EQUB 9
 EQUB 8
 EQUB 0
 EQUB 0 ;QQ26
 EQUW (20000ANDQ%) ;TALLY
 EQUB 128 ;SVC

 \.CHK2

 EQUB $AA

 \.CHK3

 EQUB $27

 \.CHK

 EQUB $03
 EQUD 0
 EQUD 0
 EQUD 0

.NAEND%

 EQUD 0

.scacol

 EQUB 0
 EQUB BLUE
 EQUB BLUE
 EQUB RED
 EQUB RED
 EQUB RED ;barrel
 EQUB RED
 EQUB RED
 EQUB RED
 EQUB CYAN
 EQUB CYAN ;transp
 EQUB CYAN
 EQUB MAG
 EQUB MAG
 EQUB MAG
 EQUB RED
 EQUB CYAN ;Viper
 EQUB CYAN
 EQUB CYAN
 EQUB CYAN
 EQUB CYAN
 EQUB CYAN
 EQUB CYAN
 EQUB BLUE ;Wor
 EQUB CYAN
 EQUB CYAN
 EQUB MAG
 EQUB CYAN
 EQUB CYAN ;Moray
 EQUB FUZZY
 EQUB CYAN
 EQUB CYAN ;Con
 EQUB 0
 EQUB CYAN
 EQUD 0

; ******************************************************************************
;
; Save ELTA.bin
;
; ******************************************************************************

 PRINT "ELITE A"
 PRINT "Assembled at ", ~CODE%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_A%

 PRINT "S.ELTA ", ~CODE%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_A%
 SAVE "3-assembled-output/ELTA.bin", CODE%, P%, LOAD%

; ******************************************************************************
;
; ELITE B FILE
;
; Produces the binary file ELTB.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_B% = P%

 LOAD_B% = LOAD% + P% - CODE%

.UNIV

 FOR I%, 0, NOSH

  EQUW K% + I% * NI%    ; Address of block no. I%, of size NI%, in workspace K%

 NEXT

.NLI4

 LDX #39

.NLL1

 LDA $480,X
 CMP #160
 BEQ NLI5
 LDA #$AD
 STA $500,X

.NLI5

 DEX
 BPL NLL1
 RTS

.FLKB

 BIT $C010
 RTS

.NLIN3

 JSR TT27

.NLIN4

 LDA text
 BMI NLI4
 LDA #19
 BNE NLIN2

.NLIN

 LDA #23

.NLIN5

 JSR INCYC

.NLIN2

 STA Y1
 LDA #BLUE
 STA COL
 LDX #0
 STX X1
 DEX
 STX X2
 JMP HLOIN

.HLOIN2

 JSR EDGES
 STY Y1
 LDA #0
 STA LSO,Y
 JMP HLOIN
 \.........

.PIX1

 JSR ADD
 STA YY+1
 TXA
 STA SYL,Y

.PIXEL2

 LDA X1
 BPL PX1
 EOR #$7F
 CLC
 ADC #1

.PX1

 EOR #128
 TAX
 LDA Y1
 AND #127
 CMP #Y
 BCS PXR1
 LDA Y1
 BPL PX2
 EOR #$7F
 ADC #1

.PX2

 STA T
 LDA #(Y+1)
 SBC T
 \....

.PIXEL

 STY T1
 STA SC+1
 LSR A
 LSR A
 LSR A
 STA T3
 TAY
 LDA SCTBL,Y
 STA SC
 LDA SC+1
 AND #7
 STA T2
 ASL A
 ASL A
 ADC SCTBH,Y
 STA SC+1
 LDA SCTBX1,X
 ASL A
 LDY ZZ
 BMI P%+4
 ADC #14
 CPY #$50
 LDY SCTBX2,X
 TAX
 BCS PX4
 LDA TWOS3,X
 EOR (SC),Y
 STA (SC),Y
 LDA TWOS3+1,X
 BEQ PX3
 INY
 EOR (SC),Y
 STA (SC),Y
 DEY

.PX3

 LDA T2
 BEQ PX6
 LDA SC+1
 SBC #3
 STA SC+1

.PX4

 LDA TWOS3,X
 EOR (SC),Y
 STA (SC),Y
 LDA TWOS3+1,X
 BEQ PX5
 INY
 EOR (SC),Y
 STA (SC),Y

.PX5

 LDY T1

.PXR1

 RTS

.PX6

 STX T2
 LDX T3
 LDA SCTBL-1,X
 STA SC
 LDA SCTBH2-1,X
 STA SC+1
 LDX T2
 JMP PX4
 \....

.TWOS3

 EQUW $0003
 EQUW $0006
 EQUW $000C
 EQUW $0018
 EQUW $0030
 EQUW $0060
 EQUW $0140
 EQUW $0007
 EQUW $000E
 EQUW $001C
 EQUW $0038
 EQUW $0070
 EQUW $0160
 EQUW $0340
 \.........

.BLINE

 TXA
 ADC K4
 STA K6+2
 LDA K4+1
 ADC T
 STA K6+3
 LDA FLAG
 BEQ BL1
 INC FLAG

.BL5

 LDY LSP
 LDA #$FF
 CMP LSY2-1,Y
 BEQ BL7
 STA LSY2,Y
 INC LSP
 BNE BL7

.BL1

 LDA K5
 STA XX15
 LDA K5+1
 STA XX15+1
 LDA K5+2
 STA XX15+2
 LDA K5+3
 STA XX15+3
 LDA K6
 STA XX15+4
 LDA K6+1
 STA XX15+5
 LDA K6+2
 STA XX12
 LDA K6+3
 STA XX12+1
 JSR LL145
 BCS BL5
 LDA SWAP
 BEQ BL9
 LDA X1
 LDY X2
 STA X2
 STY X1
 LDA Y1
 LDY Y2
 STA Y2
 STY Y1

.BL9

 LDY LSP
 LDA LSY2-1,Y
 CMP #$FF
 BNE BL8
 LDA X1
 STA LSX2,Y
 LDA Y1
 STA LSY2,Y
 INY

.BL8

 LDA X2
 STA LSX2,Y
 LDA Y2
 STA LSY2,Y
 INY
 STY LSP
 JSR LOIN
 LDA XX13
 BNE BL5

.BL7

 LDA K6
 STA K5
 LDA K6+1
 STA K5+1
 LDA K6+2
 STA K5+2
 LDA K6+3
 STA K5+3
 LDA CNT
 CLC
 ADC STP
 STA CNT
 RTS

.FLIP

;LDA MJ
;BNE FLIP-1
 LDY NOSTM

.FLL1

 LDX SY,Y
 LDA SX,Y
 STA Y1
 STA SY,Y
 TXA
 STA X1
 STA SX,Y
 LDA SZ,Y
 STA ZZ
 JSR PIXEL2
 DEY
 BNE FLL1
 RTS

.STARS

 LDX VIEW
 BEQ STARS1
 DEX
 BNE ST11
 JMP STARS6

.ST11

 JMP STARS2

.STARS1

 LDY NOSTM

.STL1

 JSR DV42
 LDA R
 LSR P
 ROR A
 LSR P
 ROR A
 ORA #1
 STA Q
 LDA SZL,Y
 SBC DELT4
 STA SZL,Y
 LDA SZ,Y
 STA ZZ
 SBC DELT4+1
 STA SZ,Y
 JSR MLU1
 STA YY+1
 LDA P
 ADC SYL,Y
 STA YY
 STA R
 LDA Y1
 ADC YY+1
 STA YY+1
 STA S
 LDA SX,Y
 STA X1
 JSR MLU2
 STA XX+1
 LDA P
 ADC SXL,Y
 STA XX
 LDA X1
 ADC XX+1
 STA XX+1
 EOR ALP2+1
 JSR MLS1
 JSR ADD
 STA YY+1
 STX YY
 EOR ALP2
 JSR MLS2
 JSR ADD
 STA XX+1
 STX XX
 LDX BET1
 LDA YY+1
 EOR BET2+1
 JSR MULTS-2
 STA Q
 JSR MUT2
 ASL P
 ROL A
 STA T
 LDA #0
 ROR A
 ORA T
 JSR ADD
 STA XX+1
 TXA
 STA SXL,Y
 LDA YY
 STA R
 LDA YY+1
 STA S
;JSR MAD
;STA SSTXR
 LDA #0
 STA P
 LDA BETA
 EOR #128
 JSR PIX1
 LDA XX+1
 STA X1
 STA SX,Y
 AND #127
 CMP #120
 BCS KILL1
 LDA YY+1
 STA SY,Y
 STA Y1
 AND #127
 CMP #120
 BCS KILL1
 LDA SZ,Y
 CMP #16
 BCC KILL1
 STA ZZ

.STC1

 JSR PIXEL2
 DEY
 BEQ P%+5
 JMP STL1
 RTS

.KILL1

 JSR DORND
 ORA #4
 STA Y1
 STA SY,Y
 JSR DORND
 ORA #8
 STA X1
 STA SX,Y
 JSR DORND
 ORA #$90
 STA SZ,Y
 STA ZZ
 LDA Y1
 JMP STC1

.STARS6

 LDY NOSTM

.STL6

 JSR DV42
 LDA R
 LSR P
 ROR A
 LSR P
 ROR A
 ORA #1
 STA Q
 LDA SX,Y
 STA X1
 JSR MLU2
 STA XX+1
 LDA SXL,Y
 SBC P
 STA XX
 LDA X1
 SBC XX+1
 STA XX+1
 JSR MLU1
 STA YY+1
 LDA SYL,Y
 SBC P
 STA YY
 STA R
 LDA Y1
 SBC YY+1
 STA YY+1
 STA S
 LDA SZL,Y
 ADC DELT4
 STA SZL,Y
 LDA SZ,Y
 STA ZZ
 ADC DELT4+1
 STA SZ,Y
 LDA XX+1
 EOR ALP2
 JSR MLS1
 JSR ADD
 STA YY+1
 STX YY
 EOR ALP2+1
 JSR MLS2
 JSR ADD
 STA XX+1
 STX XX
 LDA YY+1
 EOR BET2+1
 LDX BET1
 JSR MULTS-2
 STA Q
 LDA XX+1
 STA S
 EOR #128
 JSR MUT1
 ASL P
 ROL A
 STA T
 LDA #0
 ROR A
 ORA T
 JSR ADD
 STA XX+1
 TXA
 STA SXL,Y
 LDA YY
 STA R
 LDA YY+1
 STA S
;EOR #128
;JSR MAD
;STA SSTXR
 LDA #0
 STA P
 LDA BETA
 JSR PIX1
 LDA XX+1
 STA X1
 STA SX,Y
 LDA YY+1
 STA SY,Y
 STA Y1
 AND #127
 CMP #110
 BCS KILL6
 LDA SZ,Y
 CMP #160
 BCS KILL6
 STA ZZ

.STC6

 JSR PIXEL2
 DEY
 BEQ ST3
 JMP STL6

.ST3

 RTS

.KILL6

 JSR DORND
 AND #127
 ADC #10
 STA SZ,Y
 STA ZZ
 LSR A
 BCS ST4
 LSR A
 LDA #$FC
 ROR A
 STA X1
 STA SX,Y
 JSR DORND
 STA Y1
 STA SY,Y
 JMP STC6

.ST4

 JSR DORND
 STA X1
 STA SX,Y
 LSR A
 LDA #230
 ROR A
 STA Y1
 STA SY,Y
 BNE STC6

.MAS1

 LDA INWK,Y
 ASL A
 STA K+1
 LDA INWK+1,Y
 ROL A
 STA K+2
 LDA #0
 ROR A
 STA K+3
 JSR MVT3
 STA INWK+2,X
 LDY K+1
 STY INWK,X
 LDY K+2
 STY INWK+1,X
 AND #127

.MA9

 RTS

.m

 LDA #0

.MAS2

 ORA K%+2,Y
 ORA K%+5,Y
 ORA K%+8,Y
 AND #127
 RTS

.MAS3

 LDA K%+1,Y
 JSR SQUA2
 STA R
 LDA K%+4,Y
 JSR SQUA2
 ADC R
 BCS MA30
 STA R
 LDA K%+7,Y
 JSR SQUA2
 ADC R
 BCC P%+4

.MA30

 LDA #$FF
 RTS

.wearedocked

 LDA #205
 JSR DETOK
 JSR TT67_copy ; Is TT67 in source, needs to point to high memory version
 JMP st6+3

.st4

 LDX #9
 CMP #25
 BCS st3
 DEX
 CMP #10
 BCS st3
 DEX
 CMP #2
 BCS st3
 DEX
 BNE st3

.STATUS

 LDA #8
 JSR TRADEMODE
 JSR TT111
 LDA #7

IF _IB_DISK

 STA XC

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 JSR DOXC

ENDIF

 LDA #126
 JSR NLIN3
 LDA #15
 LDY QQ12
 BNE wearedocked
 LDA #230
 LDY JUNK
 LDX FRIN+2,Y
 BEQ st6
 LDY ENERGY
 CPY #128
 ADC #1

.st6

 JSR plf
 LDA #125
 JSR spc
 LDA #19
 LDY FIST
 BEQ st5
 CPY #50
 ADC #1

.st5

 JSR plf
 LDA #16
 JSR spc
 LDA TALLY+1
 BNE st4
 TAX
 LDA TALLY
 LSR A
 LSR A
 INX
 LSR A
 BNE P%-2

.st3

 TXA
 CLC
 ADC #21
 JSR plf
 LDA #18
 JSR plf2
 LDA ESCP
 BEQ P%+7
 LDA #112
 JSR plf2
 LDA BST
 BEQ P%+7
 LDA #111
 JSR plf2
 LDA ECM
 BEQ P%+7
 LDA #$6C
 JSR plf2
 LDA #113
 STA XX4

.stqv

 TAY
 LDX BOMB-113,Y
 BEQ P%+5
 JSR plf2
 INC XX4
 LDA XX4
 CMP #117
 BCC stqv
 LDX #0

.st

 STX CNT
 LDY LASER,X
 BEQ st1
 TXA
 CLC
 ADC #96
 JSR spc
 LDA #103
 LDX CNT
 LDY LASER,X
 CPY #128+POW
 BNE P%+4
 LDA #104
 CPY #Armlas
 BNE P%+4
 LDA #117
 CPY #Mlas
 BNE P%+4
 LDA #118
 JSR plf2

.st1

 LDX CNT
 INX
 CPX #4
 BCC st
 RTS

.plf2

 JSR plf
 LDA #6

IF _IB_DISK

 STA XC
 RTS

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 JMP DOXC

ENDIF

.MVT3

 LDA K+3
 STA S
 AND #128
 STA T
 EOR INWK+2,X
 BMI MV13
 LDA K+1
 CLC
 ADC INWK,X
 STA K+1
 LDA K+2
 ADC INWK+1,X
 STA K+2
 LDA K+3
 ADC INWK+2,X
 AND #127
 ORA T
 STA K+3
 RTS

.MV13

 LDA S
 AND #127
 STA S
 LDA INWK,X
 SEC
 SBC K+1
 STA K+1
 LDA INWK+1,X
 SBC K+2
 STA K+2
 LDA INWK+2,X
 AND #127
 SBC S
 ORA #128
 EOR T
 STA K+3
 BCS MV14
 LDA #1
 SBC K+1
 STA K+1
 LDA #0
 SBC K+2
 STA K+2
 LDA #0
 SBC K+3
 AND #127
 ORA T
 STA K+3

.MV14

 RTS

.MVS5

 LDA INWK+1,X
 AND #127
 LSR A
 STA T
 LDA INWK,X
 SEC
 SBC T
 STA R
 LDA INWK+1,X
 SBC #0
 STA S
 LDA INWK,Y
 STA P
 LDA INWK+1,Y
 AND #128
 STA T
 LDA INWK+1,Y
 AND #127
 LSR A
 ROR P
 LSR A
 ROR P
 LSR A
 ROR P
 LSR A
 ROR P
 ORA T
 EOR RAT2
 STX Q
 JSR ADD
 STA K+1
 STX K
 LDX Q
 LDA INWK+1,Y
 AND #127
 LSR A
 STA T
 LDA INWK,Y
 SEC
 SBC T
 STA R
 LDA INWK+1,Y
 SBC #0
 STA S
 LDA INWK,X
 STA P
 LDA INWK+1,X
 AND #128
 STA T
 LDA INWK+1,X
 AND #127
 LSR A
 ROR P
 LSR A
 ROR P
 LSR A
 ROR P
 LSR A
 ROR P
 ORA T
 EOR #128
 EOR RAT2
 STX Q
 JSR ADD
 STA INWK+1,Y
 STX INWK,Y
 LDX Q
 LDA K
 STA INWK,X
 LDA K+1
 STA INWK+1,X
 RTS

.TENS

 EQUD &E87648

.pr2

 LDA #3
 LDY #0

.TT11

 STA U
 LDA #0
 STA K
 STA K+1
 STY K+2
 STX K+3

.BPRNT

 LDX #11
 STX T
 PHP
 BCC TT30
 DEC T
 DEC U

.TT30

 LDA #11
 SEC
 STA XX17
 SBC U
 STA U
 INC U
 LDY #0
 STY S
 JMP TT36

.TT35

 ASL K+3
 ROL K+2
 ROL K+1
 ROL K
 ROL S
 LDX #3

.tt35

 LDA K,X
 STA XX15,X
 DEX
 BPL tt35
 LDA S
 STA XX15+4
 ASL K+3
 ROL K+2
 ROL K+1
 ROL K
 ROL S
 ASL K+3
 ROL K+2
 ROL K+1
 ROL K
 ROL S
 CLC
 LDX #3

.tt36

 LDA K,X
 ADC XX15,X
 STA K,X
 DEX
 BPL tt36
 LDA XX15+4
 ADC S
 STA S
 LDY #0

.TT36

 LDX #3
 SEC

.tt37

 LDA K,X
 SBC TENS,X
 STA XX15,X
 DEX
 BPL tt37
 LDA S
 SBC #23
 STA XX15+4
 BCC TT37
 LDX #3

.tt38

 LDA XX15,X
 STA K,X
 DEX
 BPL tt38
 LDA XX15+4
 STA S
 INY
 JMP TT36

.TT37

 TYA
 BNE TT32
 LDA T
 BEQ TT32
 DEC U
 BPL TT34
 LDA #32
 BNE tt34

.TT32

 LDY #0
 STY T
 CLC
 ADC #'0'

.tt34

 JSR TT26

.TT34

 DEC T
 BPL P%+4
 INC T
 DEC XX17
 BMI rT10
 BNE P%+10
 PLP
 BCC P%+7
 LDA #$2E
 JSR TT26
 JMP TT35

.rT10

 RTS

.DTW1

 EQUB 32

.DTW2

IF _IB_DISK

 EQUB 0

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 EQUB $FF

ENDIF

.DTW3

 EQUB 0

.DTW4

 SKIP 1

.DTW5

 EQUB 0

.DTW6

 EQUB 0

.DTW8

 EQUB $FF

.FEED

 LDA #12
 EQUB $2C

.MT16

 LDA #65

 DTW7 = MT16+1

 \ New TT26 entry for right justified text

.DASC 

.TT26

 STX SC
 LDX #$FF
 STX DTW8
 CMP #'.'
 BEQ DA8
 CMP #':'
 BEQ DA8
 CMP #10
 BEQ DA8
 CMP #12
 BEQ DA8
 CMP #32
 BEQ DA8
 INX

.DA8

 STX DTW2
 LDX SC
 BIT DTW4
 BMI P%+5
 JMP CHPR
 BIT DTW4
 BVS P%+6
 CMP #12
 BEQ DA1
 LDX DTW5
 STA BUF,X
 LDX SC
 INC DTW5
 CLC
 RTS

.DA1

 TXA
 PHA
 TYA
 PHA

.DA5

 LDX DTW5
 BEQ DA6+3
 CPX #(LL+1)
 BCC DA6
 LSR SC+1

.DA11

 LDA SC+1
 BMI P%+6
 LDA #64
 STA SC+1
 LDY #(LL-1)

.DAL1

 LDA BUF+LL
 CMP #32
 BEQ DA2

.DAL2

 DEY
 BMI DA11
 BEQ DA11
 LDA BUF,Y
 CMP #32
 BNE DAL2
 ASL SC+1
 BMI DAL2
 STY SC
 LDY DTW5

.DAL6

 LDA BUF,Y
 STA BUF+1,Y
 DEY
 CPY SC
 BCS DAL6
 INC DTW5
;LDA #32

.DAL3

 CMP BUF,Y
 BNE DAL1
 DEY
 BPL DAL3
 BMI DA11

.DA2

 LDX #LL
 JSR DAS1
 LDA #12
 JSR CHPR
 LDA DTW5
;CLC 
 SBC #LL
 STA DTW5
 TAX
 BEQ DA6+3
 LDY #0
 INX

.DAL4

 LDA BUF+LL+1,Y
 STA BUF,Y
 INY
 DEX
 BNE DAL4
 BEQ DA5

.DAS1

 LDY #0

.DAL5

 LDA BUF,Y
 JSR CHPR
 INY
 DEX
 BNE DAL5

.dec27

 RTS

.DA6

 JSR DAS1
 STX DTW5
 PLA
 TAY
 PLA
 TAX
 LDA #12

.DA7

 EQUB $2C

.BELL

 LDA #7
 JMP CHPR
 \..........
 \ ............... DIALS .......................... 

.DIALS

 LDY #0
 LDA #210
 STA K
 LDX #RED
 LDA MCNT
 AND #8
 AND FLH
 BEQ P%+4
 LDX #WHITE
 STX K+2
 LDA DELTA
 JSR DIS2
 LDA #WHITE
 STA COL
 LDA ALP1
 LSR A
 BIT ALP2+1
 JSR DIS5
 LDA BET1
 ASL A
 BIT BET2
 JSR DIS5
 LDA ENERGY
 LSR A

.DIL1

 STA K+1
 JSR DIS2
 LDA K+1
 SEC
 SBC #32
 BCS P%+4
 LDA #0
 CPY #7
 BNE DIL1
 LDA #16
 STA K
 LDA FSH
 JSR DIS1
 LDA ASH
 JSR DIS1
 LDA QQ14
 JSR DIS1+2
 LDA ALTIT
 JSR DIS1
 LDA CABTMP
 JSR DIS1
 LDA GNTMP
 JSR DIS1
 JMP COMPAS
 \....

.DIS1

 LSR A
 LSR A
 LSR A

.DIS2

 CMP #32
 BCC P%+4
 LDA #31
 LDX dialc1,Y
 CMP dialle,Y
 BCC DI3
 LDX dialc2,Y

.DI3

 CPX #$FF
 BNE DI4
 LDX K+2
 CLC

.DI4

 INY
 PHA
 CMP dials-1,Y
 BNE DI6
 TXA
 CMP dialc-1,Y
 BEQ DI8

.DI6

 TXA
 LDX dialc-1,Y
 STA dialc-1,Y
 LDA dials-1,Y
 JSR DIS7
 LDX dialc-1,Y
 PLA
 STA dials-1,Y

.DIS7

 STX COL
 LDX dialY-1,Y
 STX Y1
 LDX K
 STX X1
 CLC
 ADC K
 AND #$FE
 STA X2
 JSR P%+3
 JMP MSBARS

.DI8

 PLA

.DIR1

 RTS
 \....

.DIS5

 BPL DI9
 EOR #$FF
 CLC
 ADC #1

.DI9

 INY
 CLC
 ADC #224
 CMP dials-1,Y
 BEQ DIR1
 PHA
 LDA dials-1,Y
 BEQ P%+5
 JSR DIS6
 PLA
 STA dials-1,Y

.DIS6

 STA X1
 LDA dialY-1,Y
 STA Y1
 CLC
 ADC #6
 STA Y2
 JMP VLOIN
 \....
 \...

.dialY

 EQUB $89
 EQUB $90
 EQUB $98
 EQUB $B9
 EQUB $B1
 EQUB $A9
 EQUB $A1
 EQUB $89
 EQUB $91
 EQUB $99
 EQUB $B1
 EQUB $A1
 EQUB $A9

.dialle

 EQUB 28
 EQUB  0
 EQUB  0
 EQUB 16
 EQUB  0
 EQUB  0
 EQUB  0
 EQUB  8
 EQUB  8
 EQUB  0
 EQUB  8
 EQUB 24
 EQUB 24

.dialc1

 EQUB WHITE
 EQUB WHITE
 EQUB WHITE
 EQUB $FF
 EQUB VIOLET
 EQUB VIOLET
 EQUB VIOLET
 EQUB $FF
 EQUB $FF
 EQUB GREEN
 EQUB $FF
 EQUB BLUE
 EQUB BLUE

.dialc2

 EQUB $FF
 EQUB WHITE
 EQUB WHITE
 EQUB VIOLET
 EQUB VIOLET
 EQUB VIOLET
 EQUB VIOLET
 EQUB VIOLET
 EQUB VIOLET
 EQUB GREEN
 EQUB GREEN
 EQUB $FF
 EQUB $FF
 \.......

.ESCAPE

 JSR RES2
 LDX #CYL
 STX TYPE
 JSR FRS1
 BCS ES1
 LDX #CYL2
 JSR FRS1

.ES1

 LDA #8
 STA INWK+27
 LDA #$C2
 STA INWK+30
 LSR A
 STA INWK+32

.ESL1

 JSR MVEIT
 JSR LL9
 DEC INWK+32
 BNE ESL1
 JSR SCAN
 LDA #0
 LDX #16

.ESL2

 STA QQ20,X
 DEX
 BPL ESL2
 STA FIST
 STA ESCP
;LDA TRIBBLE
;ORA TRIBBLE+1
;BEQ nosurviv
;JSR DORND
;AND #7
;ORA #1
;STA TRIBBLE
;LDA #0
;STA TRIBBLE+1
 \.nosurviv
 LDA #70
 STA QQ14
 JMP GOIN

.HME2

;LDA #CYAN
;JSR DOCOL
 LDA #14
 JSR DETOK
 JSR TT103
 JSR TT81
 LDA #0
 STA XX20

.HME3

 JSR MT14
 JSR cpl
 LDX DTW5
 LDA INWK+5,X
 CMP #13
 BNE HME6

.HME4

 DEX
 LDA INWK+5,X
 ORA #32
 CMP BUF,X
 BEQ HME4
 TXA
 BMI HME5

.HME6

 JSR TT20
 INC XX20
 BNE HME3
 JSR TT111
 JSR TT103
 JSR BOOP ; @@
 LDA #215
 JMP DETOK
 \Not found

.HME5

 LDA QQ15+3
 STA QQ9
 LDA QQ15+1
 STA QQ10
 JSR TT111
 JSR TT103
 JSR MT15
 JMP T95

; ******************************************************************************
;
; Save ELTB.bin
;
; ******************************************************************************

 PRINT "ELITE B"
 PRINT "Assembled at ", ~CODE_B%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_B%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_B%

 PRINT "S.ELTB ", ~CODE_B%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_B%
 SAVE "3-assembled-output/ELTB.bin", CODE_B%, P%, LOAD%

; ******************************************************************************
;
; ELITE C FILE
;
; Produces the binary file ELTC.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_C% = P%

 LOAD_C% = LOAD% +P% - CODE%

; ******************************************************************************
;
;       Name: TACTICS (Part 1 of 7)
;       Type: Subroutine
;   Category: Tactics
;    Summary: Apply tactics: Process missiles, both enemy missiles and our own
;  Deep dive: Program flow of the tactics routine
;
; ------------------------------------------------------------------------------
;
; This section implements missile tactics and is entered at TA18 from the main
; entry point below, if the current ship is a missile. Specifically:
;
;   * If E.C.M. is active, destroy the missile
;
;   * If the missile is hostile towards us, then check how close it is. If it
;     hasn't reached us, jump to part 3 so it can streak towards us, otherwise
;     we've been hit, so process a large amount of damage to our ship
;
;   * Otherwise see how close the missile is to its target. If it has not yet
;     reached its target, give the target a chance to activate its E.C.M. if it
;     has one, otherwise jump to TA19 with K3 set to the vector from the target
;     to the missile
;
;   * If it has reached its target and the target is the space station, destroy
;     the missile, potentially damaging us if we are nearby
;
;   * If it has reached its target and the target is a ship, destroy the missile
;     and the ship, potentially damaging us if we are nearby
;
; ******************************************************************************

.TA352

                        ; If we get here, the missile has been destroyed by
                        ; E.C.M. or by the space station

 LDA INWK               ; Set A = x_lo OR y_lo OR z_lo of the missile
 ORA INWK+3
 ORA INWK+6

 BNE TA872              ; If A is non-zero then the missile is not near our
                        ; ship, so skip the next two instructions to avoid
                        ; damaging our ship

 LDA #80                ; Otherwise the missile just got destroyed near us, so
 JSR OOPS               ; call OOPS to damage the ship by 80, which is nowhere
                        ; near as bad as the 250 damage from a missile slamming
                        ; straight into us, but it's still pretty nasty

.TA872

 LDX #PLT               ; Set X to the ship type for plate alloys, so we get
                        ; awarded the kill points for the missile scraps in TA87

 BNE TA353              ; Jump to TA353 to process the missile kill tally and
                        ; make an explosion sound

.TA34

                        ; If we get here, the missile is hostile

 LDA #0                 ; Set A to x_hi OR y_hi OR z_hi
 JSR MAS4

 BEQ P%+5               ; If A = 0 then the missile is very close to our ship,
                        ; so skip the following instruction

 JMP TN4                ; Jump down to part 3 to set up the vectors and skip
                        ; straight to aggressive manoeuvring

 JSR TA873              ; The missile has hit our ship, so call TA873 to set
                        ; bit 7 of the missile's byte #31, which marks the
                        ; missile as being killed

 JSR EXNO3              ; Make the sound of the missile exploding

 LDA #250               ; Call OOPS to damage the ship by 250, which is a pretty
 JMP OOPS               ; big hit, and return from the subroutine using a tail
                        ; call

.TA18

                        ; This is the entry point for missile tactics and is
                        ; called from the main TACTICS routine below

 LDA ECMA               ; If an E.C.M. is currently active (either ours or an
 BNE TA352              ; opponent's), jump to TA352 to destroy this missile

 LDA INWK+32            ; Fetch the AI flag from byte #32 and if bit 6 is set
 ASL A                  ; (i.e. missile is hostile), jump up to TA34 to check
 BMI TA34               ; whether the missile has hit us

 LSR A                  ; Otherwise shift A right again. We know bits 6 and 7
                        ; are now clear, so this leaves bits 0-5. Bits 1-5
                        ; contain the target's slot number, and bit 0 is cleared
                        ; in FRMIS when a missile is launched, so A contains
                        ; the slot number shifted left by 1 (i.e. doubled) so we
                        ; can use it as an index for the two-byte address table
                        ; at UNIV

 TAX                    ; Copy the address of the target ship's data block from
 LDA UNIV,X             ; UNIV(X+1 X) to (A V)
 STA V
 LDA UNIV+1,X

 JSR VCSUB              ; Calculate vector K3 as follows:
                        ;
                        ; K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate of
                        ; target ship
                        ;
                        ; K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate of
                        ; target ship
                        ;
                        ; K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate of
                        ; target ship

                        ; So K3 now contains the vector from the target ship to
                        ; the missile

 LDA K3+2               ; Set A = OR of all the sign and high bytes of the
 ORA K3+5               ; above, clearing bit 7 (i.e. ignore the signs)
 ORA K3+8
 AND #%01111111
 ORA K3+1
 ORA K3+4
 ORA K3+7

 BNE TA64               ; If the result is non-zero, then the missile is some
                        ; distance from the target, so jump down to TA64 see if
                        ; the target activates its E.C.M.

 LDA INWK+32            ; Fetch the AI flag from byte #32 and if only bits 7 and
 CMP #%10000010         ; 1 are set (AI is enabled and the target is slot 1, the
 BEQ TA352              ; space station), jump to TA352 to destroy this missile,
                        ; as the space station ain't kidding around

 LDY #31                ; Fetch byte #31 (the exploding flag) of the target ship
 LDA (V),Y              ; into A

 BIT M32+1              ; M32 contains an LDY #32 instruction, so M32+1 contains
                        ; 32, so this instruction tests A with %00100000, which
                        ; checks bit 5 of A (the "already exploding?" bit)

 BNE TA35               ; If the target ship is already exploding, jump to TA35
                        ; to destroy this missile

 ORA #%10000000         ; Otherwise set bit 7 of the target's byte #31 to mark
 STA (V),Y              ; the ship as having been killed, so it explodes

.TA35

 LDA INWK               ; Set A = x_lo OR y_lo OR z_lo of the missile
 ORA INWK+3
 ORA INWK+6

 BNE TA87               ; If A is non-zero then the missile is not near our
                        ; ship, so jump to TA87 to skip damaging our ship

 LDA #80                ; Otherwise the missile just got destroyed near us, so
 JSR OOPS               ; call OOPS to damage the ship by 80, which is nowhere
                        ; near as bad as the 250 damage from a missile slamming
                        ; straight into us, but it's still pretty nasty

.TA87

 LDA INWK+32            ; Set X to bits 1-6 of the missile's AI flag in ship
 AND #%01111111         ; byte #32, so bits 0-4 of X are the target's slot
 LSR A                  ; number, and bit 5 is set (as the missile is hostile)
 TAX                    ; so X is fairly random and in the range 32-43 (as the
                        ; maximum slot number is 11)
                        ;
                        ; The value of X is used to determine the number of kill
                        ; points awarded for the destruction of the missile

.TA353

 JSR EXNO2              ; Call EXNO2 to process the fact that we have killed a
                        ; missile (so increase the kill tally, make an explosion
                        ; sound and so on)

.TA873

 ASL INWK+31            ; Set bit 7 of the missile's byte #31 flag to mark it as
 SEC                    ; having been killed, so it explodes
 ROR INWK+31

.TA1

 RTS                    ; Return from the subroutine

.TA64

                        ; If we get here then the missile has not reached the
                        ; target

 JSR DORND              ; Set A and X to random numbers

 CMP #16                ; If A >= 16 (94% chance), jump down to TA19S with the
 BCS TA19S              ; vector from the target to the missile in K3

.M32

 LDY #32                ; Fetch byte #32 for the target and shift bit 0 (E.C.M.)
 LDA (V),Y              ; into the C flag
 LSR A

 BCS P%+5               ; If the C flag is set then the target has E.C.M.
                        ; fitted, so skip the next instruction

.TA19S

 JMP TA19               ; The target does not have E.C.M. fitted, so jump down
                        ; to TA19 with the vector from the target to the missile
                        ; in K3

 JMP ECBLB2             ; The target has E.C.M., so jump to ECBLB2 to set it
                        ; off, returning from the subroutine using a tail call

; ******************************************************************************
;
;       Name: TACTICS (Part 2 of 7)
;       Type: Subroutine
;   Category: Tactics
;    Summary: Apply tactics: Escape pod, station, lone Thargon, safe-zone pirate
;  Deep dive: Program flow of the tactics routine
;
; ------------------------------------------------------------------------------
;
; This section contains the main entry point at TACTICS, which is called from
; part 2 of MVEIT for ships that have the AI flag set (i.e. bit 7 of byte #32).
; This part does the following:
;
;   * If this is a missile, jump up to the missile code in part 1
;
;   * If this is the space station and it is hostile, consider spawning a cop
;     (6.2% chance, up to a maximum of seven) and we're done
;
;   * If this is the space station and it is not hostile, consider spawning
;     (0.8% chance if there are no Transporters around) a Transporter or Shuttle
;     (equal odds of each type) and we're done
;
;   * If this is a rock hermit, consider spawning (22% chance) a highly
;     aggressive and hostile Sidewinder, Mamba, Krait, Adder or Gecko (equal
;     odds of each type) and we're done
;
;   * Recharge the ship's energy banks by 1
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The ship type
;
; ******************************************************************************

.TACTICS

 LDA #3                 ; Set RAT = 3, which is the magnitude we set the pitch
 STA RAT                ; or roll counter to in part 7 when turning a ship
                        ; towards a vector (a higher value giving a longer
                        ; turn). This value is not changed in the TACTICS
                        ; routine, but it is set to different values by the
                        ; DOCKIT routine

 LDA #4                 ; Set RAT2 = 4, which is the threshold below which we
 STA RAT2               ; don't apply pitch and roll to the ship (so a lower
                        ; value means we apply pitch and roll more often, and a
                        ; value of 0 means we always apply them). The value is
                        ; compared with double the high byte of sidev . XX15,
                        ; where XX15 is the vector from the ship to the enemy
                        ; or planet. This value is set to different values by
                        ; both the TACTICS and DOCKIT routines

 LDA #22                ; Set CNT2 = 22, which is the maximum angle beyond which
 STA CNT2               ; a ship will slow down to start turning towards its
                        ; prey (a lower value means a ship will start to slow
                        ; down even if its angle with the enemy ship is large,
                        ; which gives a tighter turn). This value is not changed
                        ; in the TACTICS routine, but it is set to different
                        ; values by the DOCKIT routine

 CPX #MSL               ; If this is a missile, jump up to TA18 to implement
 BEQ TA18               ; missile tactics

 CPX #SST               ; If this is not the space station, jump down to TA13
 BNE TA13

 LDA NEWB               ; This is the space station, so check whether bit 2 of
 AND #%00000100         ; the ship's NEWB flags is set, and if it is (i.e. the
 BNE TN5                ; station is hostile), jump to TN5 to spawn some cops

 LDA MANY+SHU+1         ; The station is not hostile, so check how many
 BNE TA1                ; Transporters there are in the vicinity, and if we
                        ; already have one, return from the subroutine (as TA1
                        ; contains an RTS)

                        ; If we get here then the station is not hostile, so we
                        ; can consider spawning a Transporter or Shuttle

 JSR DORND              ; Set A and X to random numbers

 CMP #253               ; If A < 253 (99.2% chance), return from the subroutine
 BCC TA1                ; (as TA1 contains an RTS)

 AND #1                 ; Set A = a random number that's either 0 or 1

 ADC #SHU-1             ; The C flag is set (as we didn't take the BCC above),
 TAX                    ; so this sets X to a value of either #SHU or #SHU + 1,
                        ; which is the ship type for a Shuttle or a Transporter

 BNE TN6                ; Jump to TN6 to spawn this ship type and return from
                        ; the subroutine using a tail call (this BNE is
                        ; effectively a JMP as A is never zero)

.TN5

                        ; We only call the tactics routine for the space station
                        ; when it is hostile, so if we get here then this is the
                        ; station, and we already know it's hostile, so we need
                        ; to spawn some cops

 JSR DORND              ; Set A and X to random numbers

 CMP #240               ; If A < 240 (93.8% chance), return from the subroutine
 BCC TA1                ; (as TA1 contains an RTS)

 LDA MANY+COPS          ; Check how many cops there are in the vicinity already,
 CMP #4                 ; and if there are 4 or more, return from the subroutine
 BCS TA22               ; (as TA22 contains an RTS)

 LDX #COPS              ; Set X to the ship type for a cop

.TN6

 LDA #%11110001         ; Set the AI flag to give the ship E.C.M., enable AI and
                        ; make it very aggressive (60 out of 63)

 JMP SFS1               ; Jump to SFS1 to spawn the ship, returning from the
                        ; subroutine using a tail call

.TA13

 CPX #HER               ; If this is not a rock hermit, jump down to TA17
 BNE TA17

 JSR DORND              ; Set A and X to random numbers

 CMP #200               ; If A < 200 (78% chance), return from the subroutine
 BCC TA22               ; (as TA22 contains an RTS)

 LDX #0                 ; Set byte #32 to %00000000 to disable AI, aggression
 STX INWK+32            ; and E.C.M.

 LDX #%00100100         ; Set the ship's NEWB flags to %00100100 so the ship we
 STX NEWB               ; spawn below will inherit the default values from E% as
                        ; well as having bit 2 (hostile) and bit 5 (innocent
                        ; bystander) set

 AND #3                 ; Set A = a random number that's in the range 0-3

 ADC #SH3               ; The C flag is set (as we didn't take the BCC above),
 TAX                    ; so this sets X to a random value between #SH3 + 1 and
                        ; #SH3 + 4, so that's a Sidewinder, Mamba, Krait, Adder
                        ; or Gecko

 JSR TN6                ; Call TN6 to spawn this ship with E.C.M., AI and a high
                        ; aggression (56 out of 63)

 LDA #0                 ; Set byte #32 to %00000000 to disable AI, aggression
 STA INWK+32            ; and E.C.M. (for the rock hermit)

 RTS                    ; Return from the subroutine

.TA17

 LDY #14                ; If the ship's energy is greater or equal to the
 LDA INWK+35            ; maximum value from the ship's blueprint pointed to by
 CMP (XX0),Y            ; XX0, then skip the next instruction
 BCS TA21

 INC INWK+35            ; The ship's energy is not at maximum, so recharge the
                        ; energy banks by 1

; ******************************************************************************
;
;       Name: TACTICS (Part 3 of 7)
;       Type: Subroutine
;   Category: Tactics
;    Summary: Apply tactics: Calculate dot product to determine ship's aim
;  Deep dive: Program flow of the tactics routine
;
; ------------------------------------------------------------------------------
;
; This section sets up some vectors and calculates dot products. Specifically:
;
;   * If this is a lone Thargon without a mothership, set it adrift aimlessly
;     and we're done
;
;   * If this is a trader, 80% of the time we're done, 20% of the time the
;     trader performs the same checks as the bounty hunter
;
;   * If this is a bounty hunter (or one of the 20% of traders) and we have been
;     really bad (i.e. a fugitive or serious offender), the ship becomes hostile
;     (if it isn't already)
;
;   * If the ship is not hostile, then either perform docking manoeuvres (if
;     it's docking) or fly towards the planet (if it isn't docking) and we're
;     done
;
;   * If the ship is hostile, and a pirate, and we are within the space station
;     safe zone, stop the pirate from attacking by removing all its aggression
;
;   * Calculate the dot product of the ship's nose vector (i.e. the direction it
;     is pointing) with the vector between us and the ship. This value will help
;     us work out later on whether the enemy ship is pointing towards us, and
;     therefore whether it can hit us with its lasers.
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   GOPL                Make the ship head towards the planet
;
; ******************************************************************************

.TA21

 CPX #TGL               ; If this is not a Thargon, jump down to TA14
 BNE TA14

 LDA MANY+THG           ; If there is at least one Thargoid in the vicinity,
 BNE TA14               ; jump down to TA14

 LSR INWK+32            ; This is a Thargon but there is no Thargoid mothership,
 ASL INWK+32            ; so clear bit 0 of the AI flag to disable its E.C.M.

 LSR INWK+27            ; And halve the Thargon's speed

.TA22

 RTS                    ; Return from the subroutine

.TA14

 JSR DORND              ; Set A and X to random numbers

 LDA NEWB               ; Extract bit 0 of the ship's NEWB flags into the C flag
 LSR A                  ; and jump to TN1 if it is clear (i.e. if this is not a
 BCC TN1                ; trader)

 CPX #50                ; This is a trader, so if X >= 50 (80% chance), return
 BCS TA22               ; from the subroutine (as TA22 contains an RTS)

.TN1

 LSR A                  ; Extract bit 1 of the ship's NEWB flags into the C flag
 BCC TN2                ; and jump to TN2 if it is clear (i.e. if this is not a
                        ; bounty hunter)

 LDX FIST               ; This is a bounty hunter, so check whether our FIST
 CPX #40                ; rating is < 40 (where 50 is a fugitive), and jump to
 BCC TN2                ; TN2 if we are not 100% evil

 LDA NEWB               ; We are a fugitive or a bad offender, and this ship is
 ORA #%00000100         ; a bounty hunter, so set bit 2 of the ship's NEWB flags
 STA NEWB               ; to make it hostile

 LSR A                  ; Shift A right twice so the next test in TN2 will check
 LSR A                  ; bit 2

.TN2

 LSR A                  ; Extract bit 2 of the ship's NEWB flags into the C flag
 BCS TN3                ; and jump to TN3 if it is set (i.e. if this ship is
                        ; hostile)

 LSR A                  ; The ship is not hostile, so extract bit 4 of the
 LSR A                  ; ship's NEWB flags into the C flag, and jump to GOPL if
 BCC GOPL               ; it is clear (i.e. if this ship is not docking)

 JMP DOCKIT             ; The ship is not hostile and is docking, so jump to
                        ; DOCKIT to apply the docking algorithm to this ship

.GOPL

 JSR SPS1               ; The ship is not hostile and it is not docking, so call
                        ; SPS1 to calculate the vector to the planet and store
                        ; it in XX15

 JMP TA151              ; Jump to TA151 to make the ship head towards the planet

.TN3

 LSR A                  ; Extract bit 2 of the ship's NEWB flags into the C flag
 BCC TN4                ; and jump to TN4 if it is clear (i.e. if this ship is
                        ; not a pirate)

 LDA SSPR               ; If we are not inside the space station safe zone, jump
 BEQ TN4                ; to TN4

                        ; If we get here then this is a pirate and we are inside
                        ; the space station safe zone

 LDA INWK+32            ; Set bits 0 and 7 of the AI flag in byte #32 (has AI
 AND #%10000001         ; enabled and has an E.C.M.)
 STA INWK+32

.TN4

 LDX #8                 ; We now want to copy the ship's x, y and z coordinates
                        ; from INWK to K3, so set up a counter for 9 bytes

.TAL1

 LDA INWK,X             ; Copy the X-th byte from INWK to the X-th byte of K3
 STA K3,X

 DEX                    ; Decrement the counter

 BPL TAL1               ; Loop back until we have copied all 9 bytes

.TA19

                        ; If this is a missile that's heading for its target
                        ; (not us, one of the other ships), then the missile
                        ; routine at TA18 above jumps here after setting K3 to
                        ; the vector from the target to the missile

 JSR TAS2               ; Normalise the vector in K3 and store the normalised
                        ; version in XX15, so XX15 contains the normalised
                        ; vector from our ship to the ship we are applying AI
                        ; tactics to (or the normalised vector from the target
                        ; to the missile - in both cases it's the vector from
                        ; the potential victim to the attacker)

 LDY #10                ; Set (A X) = nosev . XX15
 JSR TAS3

 STA CNT                ; Store the high byte of the dot product in CNT. The
                        ; bigger the value, the more aligned the two ships are,
                        ; with a maximum magnitude of 36 (96 * 96 >> 8). If CNT
                        ; is positive, the ships are facing in a similar
                        ; direction, if it's negative they are facing in
                        ; opposite directions

; ******************************************************************************
;
;       Name: TACTICS (Part 4 of 7)
;       Type: Subroutine
;   Category: Tactics
;    Summary: Apply tactics: Check energy levels, maybe launch escape pod if low
;  Deep dive: Program flow of the tactics routine
;
; ------------------------------------------------------------------------------
;
; This section works out what kind of condition the ship is in. Specifically:
;
;   * If this is an Anaconda, consider spawning (22% chance) a Worm (61% of the
;     time) or a Sidewinder (39% of the time)
;
;   * Rarely (2.5% chance) roll the ship by a noticeable amount
;
;   * If the ship has at least half its energy banks full, jump to part 6 to
;     consider firing the lasers
;
;   * If the ship is not into the last 1/8th of its energy, jump to part 5 to
;     consider firing a missile
;
;   * If the ship is into the last 1/8th of its energy, and this ship type has
;     an escape pod fitted, then rarely (10% chance) the ship launches an escape
;     pod and is left drifting in space
;
; ******************************************************************************

 LDA TYPE               ; If this is not a missile, skip the following
 CMP #MSL               ; instruction
 BNE P%+5

 JMP TA20               ; This is a missile, so jump down to TA20 to get
                        ; straight into some aggressive manoeuvring

 CMP #ANA               ; If this is not an Anaconda, jump down to TN7 to skip
 BNE TN7                ; the following

 JSR DORND              ; Set A and X to random numbers

 CMP #200               ; If A < 200 (78% chance), jump down to TN7 to skip the
 BCC TN7                ; following

 JSR DORND              ; Set A and X to random numbers

 LDX #WRM               ; Set X to the ship type for a Worm

 CMP #100               ; If A >= 100 (61% chance), skip the following
 BCS P%+4               ; instruction

 LDX #SH3               ; Set X to the ship type for a Sidewinder

 JMP TN6                ; Jump to TN6 to spawn the Worm or Sidewinder and return
                        ; from the subroutine using a tail call

.TN7

 JSR DORND              ; Set A and X to random numbers

 CMP #250               ; If A < 250 (97.5% chance), jump down to TA7 to skip
 BCC TA7                ; the following

 JSR DORND              ; Set A and X to random numbers

 ORA #104               ; Bump A up to at least 104 and store in the roll
 STA INWK+29            ; counter, to gives the ship a noticeable roll

.TA7

 LDY #14                ; Set A = the ship's maximum energy / 2
 LDA (XX0),Y
 LSR A

 CMP INWK+35            ; If the ship's current energy in byte #35 > A, i.e. the
 BCC TA3                ; ship has at least half of its energy banks charged,
                        ; jump down to TA3

 LSR A                  ; If the ship's current energy in byte #35 > A / 4, i.e.
 LSR A                  ; the ship is not into the last 1/8th of its energy,
 CMP INWK+35            ; jump down to ta3 to consider firing a missile
 BCC ta3

 JSR DORND              ; Set A and X to random numbers

 CMP #230               ; If A < 230 (90% chance), jump down to ta3 to consider
 BCC ta3                ; firing a missile

 LDX TYPE               ; Fetch the ship blueprint's default NEWB flags from the
 LDA E%-1,X             ; table at E%, and if bit 7 is clear (i.e. this ship
 BPL ta3                ; does not have an escape pod), jump to ta3 to skip the
                        ; spawning of an escape pod

                        ; By this point, the ship has run out of both energy and
                        ; luck, so it's time to bail

 LDA NEWB               ; Clear bits 0-3 of the NEWB flags, so the ship is no
 AND #%11110000         ; longer a trader, a bounty hunter, hostile or a pirate
 STA NEWB               ; and the escape pod we are about to spawn won't inherit
                        ; any of these traits

 LDY #36                ; Update the NEWB flags in the ship's data block
 STA (INF),Y

 LDA #0                 ; Set the AI flag to 0 to disable AI, hostility and
 STA INWK+32            ; E.C.M., so the ship's a sitting duck

 JMP SESCP              ; Jump to SESCP to spawn an escape pod from the ship,
                        ; returning from the subroutine using a tail call

; ******************************************************************************
;
;       Name: TACTICS (Part 5 of 7)
;       Type: Subroutine
;   Category: Tactics
;    Summary: Apply tactics: Consider whether to launch a missile at us
;  Deep dive: Program flow of the tactics routine
;
; ------------------------------------------------------------------------------
;
; This section considers whether to launch a missile. Specifically:
;
;   * If the ship doesn't have any missiles, skip to the next part
;
;   * If an E.C.M. is firing, skip to the next part
;
;   * Randomly decide whether to fire a missile (or, in the case of Thargoids,
;     release a Thargon), and if we do, we're done
;
; ******************************************************************************

.ta3

                        ; If we get here then the ship has less than half energy
                        ; so there may not be enough juice for lasers, but let's
                        ; see if we can fire a missile

 LDA INWK+31            ; Set A = bits 0-2 of byte #31, the number of missiles
 AND #%00000111         ; the ship has left

 BEQ TA3                ; If it doesn't have any missiles, jump to TA3

 STA T                  ; Store the number of missiles in T

 JSR DORND              ; Set A and X to random numbers

 AND #31                ; Restrict A to a random number in the range 0-31

 CMP T                  ; If A >= T, which is quite likely, though less likely
 BCS TA3                ; with higher numbers of missiles, jump to TA3 to skip
                        ; firing a missile

 LDA ECMA               ; If an E.C.M. is currently active (either ours or an
 BNE TA3                ; opponent's), jump to TA3 to skip firing a missile

 DEC INWK+31            ; We're done with the checks, so it's time to fire off a
                        ; missile, so reduce the missile count in byte #31 by 1

 LDA TYPE               ; Fetch the ship type into A

 CMP #THG               ; If this is not a Thargoid, jump down to TA16 to launch
 BNE TA16               ; a missile

 LDX #TGL               ; This is a Thargoid, so instead of launching a missile,
 LDA INWK+32            ; the mothership launches a Thargon, so call SFS1 to
 JMP SFS1               ; spawn a Thargon from the parent ship, and return from
                        ; the subroutine using a tail call

.TA16

 JMP SFRMIS             ; Jump to SFRMIS to spawn a missile as a child of the
                        ; current ship, make a noise and print a message warning
                        ; of incoming missiles, and return from the subroutine
                        ; using a tail call

; ******************************************************************************
;
;       Name: TACTICS (Part 6 of 7)
;       Type: Subroutine
;   Category: Tactics
;    Summary: Apply tactics: Consider firing a laser at us, if aim is true
;  Deep dive: Program flow of the tactics routine
;
; ------------------------------------------------------------------------------
;
; This section looks at potentially firing the ship's laser at us. Specifically:
;
;   * If the ship is not pointing at us, skip to the next part
;
;   * If the ship is pointing at us but not accurately, fire its laser at us and
;     skip to the next part
;
;   * If we are in the ship's crosshairs, register some damage to our ship, slow
;     down the attacking ship, make the noise of us being hit by laser fire, and
;     move on to the next part to manoeuvre the attacking ship
;
; ******************************************************************************

.TA3

                        ; If we get here then the ship either has plenty of
                        ; energy, or levels are low but it couldn't manage to
                        ; launch a missile, so maybe we can fire the laser?

 LDA #0                 ; Set A to x_hi OR y_hi OR z_hi
 JSR MAS4

 AND #%11100000         ; If any of the hi bytes have any of bits 5-7 set, then
 BNE TA4                ; jump to TA4 to skip the laser checks, as the ship is
                        ; too far away from us to hit us with a laser

 LDX CNT                ; Set X = the dot product set above in CNT. If this is
                        ; positive, this ship and our ship are facing in similar
                        ; directions, but if it's negative then we are facing
                        ; each other, so for us to be in the enemy ship's line
                        ; of fire, X needs to be negative. The value in X can
                        ; have a maximum magnitude of 36, which would mean we
                        ; were facing each other square on, so in the following
                        ; code we check X like this:
                        ;
                        ;   X = 0 to -31, we are not in the enemy ship's line
                        ;       of fire, so they can't shoot at us
                        ;
                        ;   X = -32 to -34, we are in the enemy ship's line
                        ;       of fire, so they can shoot at us, but they can't
                        ;       hit us as we're not dead in their crosshairs
                        ;
                        ;   X = -35 to -36, we are bang in the middle of the
                        ;       enemy ship's crosshairs, so they can not only
                        ;       shoot us, they can hit us

;BPL TA4                ; This instruction is commented out in the original
                        ; source

 CPX #160               ; If X < 160, i.e. X > -32, then we are not in the enemy
 BCC TA4                ; ship's line of fire, so jump to TA4 to skip the laser
                        ; checks

 LDY #19                ; Fetch the enemy ship's byte #19 from their ship's
 LDA (XX0),Y            ; blueprint into A

 AND #%11111000         ; Extract bits 3-7, which contain the enemy's laser
                        ; power

 BEQ TA4                ; If the enemy has no laser power, jump to TA4 to skip
                        ; the laser checks

 LDA INWK+31            ; Set bit 6 in byte #31 to denote that the ship is
 ORA #%01000000         ; firing its laser at us
 STA INWK+31

 CPX #163               ; If X < 163, i.e. X > -35, then we are not in the enemy
 BCC TA4                ; ship's crosshairs, so jump to TA4 to skip the laser
                        ; checks

;LDY #19                ; This instruction is commented out in the original
                        ; source

 LDA (XX0),Y            ; Fetch the enemy ship's byte #19 from their ship's
                        ; blueprint into A

 LSR A                  ; Halve the enemy ship's byte #19 (which contains both
                        ; the laser power and number of missiles) to get the
                        ; amount of damage we should take

 JSR OOPS               ; Call OOPS to take some damage, which could do anything
                        ; from reducing the shields and energy, all the way to
                        ; losing cargo or dying (if the latter, we don't come
                        ; back from this subroutine)

 DEC INWK+28            ; Halve the attacking ship's acceleration in byte #28

 LDA ECMA               ; If an E.C.M. is currently active (either ours or an
 BNE TA9-1              ; opponent's), return from the subroutine without making
                        ; the laser-strike sound (as TA9-1 contains an RTS)

 JSR LASNOISE           ; Call the LASNOISE routine to make the sound of us
                        ; being hit by lasers

; ******************************************************************************
;
;       Name: TACTICS (Part 7 of 7)
;       Type: Subroutine
;   Category: Tactics
;    Summary: Apply tactics: Set pitch, roll, and acceleration
;  Deep dive: Program flow of the tactics routine
;
; ------------------------------------------------------------------------------
;
; This section looks at manoeuvring the ship. Specifically:
;
;   * Work out which direction the ship should be moving, depending on the type
;     of ship, where it is, which direction it is pointing, and how aggressive
;     it is
;
;   * Set the pitch and roll counters to head in that direction
;
;   * Speed up or slow down, depending on where the ship is in relation to us
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   TA151               Make the ship head towards the planet
;
;   TA9-1               Contains an RTS
;
; ******************************************************************************

.TA4

 LDA INWK+7             ; If z_hi >= 3 then the ship is quite far away, so jump
 CMP #3                 ; down to TA5
 BCS TA5

 LDA INWK+1             ; Otherwise set A = x_hi OR y_hi and extract bits 1-7
 ORA INWK+4
 AND #%11111110

 BEQ TA15               ; If A = 0 then the ship is pretty close to us, so jump
                        ; to TA15 so it heads away from us

.TA5

                        ; If we get here then the ship is quite far away

 JSR DORND              ; Set A and X to random numbers

 ORA #%10000000         ; Set bit 7 of A, so A is at least 128

 CMP INWK+32            ; If A >= byte #32 (the ship's AI flag) then jump down
 BCS TA15               ; to TA15 so it heads away from us

                        ; We get here if A < byte #32, and the chances of this
                        ; being true are greater with high values of byte #32,
                        ; as long as they are at least 128
                        ;
                        ; In other words, higher byte #32 values increase the
                        ; chances of a ship changing direction to head towards
                        ; us - or, to put it another way, ships with higher
                        ; byte #32 values of 128 or more are spoiling for a
                        ; fight
                        ;
                        ; Thargoids have byte #32 set to 255, which explains
                        ; an awful lot

.TA20

                        ; If this is a missile we will have jumped straight
                        ; here, but we also get here if the ship is either far
                        ; away and aggressive, or not too close

 JSR TAS6               ; Call TAS6 to negate the vector in XX15 so it points in
                        ; the opposite direction

 LDA CNT                ; Change the sign of the dot product in CNT, so now it's
 EOR #%10000000         ; positive if the ships are facing each other, and
                        ; negative if they are facing the same way

.TA152

 STA CNT                ; Update CNT with the new value in A

.TA15

                        ; If we get here, then one of the following is true:
                        ;
                        ;   * This is a trader and XX15 is pointing towards the
                        ;     planet
                        ;
                        ;   * The ship is pretty close to us, or it's just not
                        ;     very aggressive (though there is a random factor
                        ;     at play here too). XX15 is still pointing from our
                        ;     ship towards the enemy ship
                        ;
                        ;   * The ship is aggressive (though again, there's an
                        ;     element of randomness here). XX15 is pointing from
                        ;     the enemy ship towards our ship
                        ;
                        ;   * This is a missile heading for a target. XX15 is
                        ;     pointing from the missile towards the target
                        ;
                        ; We now want to move the ship in the direction of XX15,
                        ; which will make aggressive ships head towards us, and
                        ; ships that are too close turn away. Peaceful traders,
                        ; meanwhile, head off towards the planet in search of a
                        ; space station, and missiles home in on their targets

 LDY #16                ; Set (A X) = roofv . XX15
 JSR TAS3               ;
                        ; This will be positive if XX15 is pointing in the same
                        ; direction as an arrow out of the top of the ship, in
                        ; other words if the ship should pull up to head in the
                        ; direction of XX15

 TAX                    ; Copy A into X so we can retrieve it below

 EOR #%10000000         ; Give the ship's pitch counter the opposite sign to the
 AND #%10000000         ; dot product result, with a value of 0
 STA INWK+30

 TXA                    ; Retrieve the original value of A from X

 ASL A                  ; Shift A left to double it and drop the sign bit

 CMP RAT2               ; If A < RAT2, skip to TA11 (so if RAT2 = 0, we always
 BCC TA11               ; set the pitch counter to RAT)

 LDA RAT                ; Set the magnitude of the ship's pitch counter to RAT
 ORA INWK+30            ; (we already set the sign above)
 STA INWK+30

.TA11

 LDA INWK+29            ; Fetch the roll counter from byte #29 into A

 ASL A                  ; Shift A left to double it and drop the sign bit

 CMP #32                ; If A >= 32 then jump to TA6, as the ship is already
 BCS TA6                ; in the process of rolling

 LDY #22                ; Set (A X) = sidev . XX15
 JSR TAS3               ;
                        ; This will be positive if XX15 is pointing in the same
                        ; direction as an arrow out of the right side of the
                        ; ship, in other words if the ship should roll right to
                        ; head in the direction of XX15

 TAX                    ; Copy A into X so we can retrieve it below

 EOR INWK+30            ; Give the ship's roll counter a positive sign
 AND #%10000000         ; (clockwise roll) if the pitch counter and dot product
 EOR #%10000000         ; have different signs, negative (anti-clockwise roll)
 STA INWK+29            ; if they have the same sign, with a value of 0

 TXA                    ; Retrieve the original value of A from X

 ASL A                  ; Shift A left to double it and drop the sign bit

 CMP RAT2               ; If A < RAT2, skip to TA12 (so if RAT2 = 0, we always
 BCC TA12               ; set the roll counter to RAT)

 LDA RAT                ; Set the magnitude of the ship's roll counter to RAT
 ORA INWK+29            ; (we already set the sign above)
 STA INWK+29

.TA12

.TA6

 LDA CNT                ; Fetch the dot product, and if it's negative jump to
 BMI TA9                ; TA9, as the ships are facing away from each other and
                        ; the ship might want to slow down to take another shot

 CMP CNT2               ; The dot product is positive, so the ships are facing
 BCC TA9                ; each other. If A < CNT2 then the ships are not heading
                        ; directly towards each other, so jump to TA9 to slow
                        ; down

.PH10E

 LDA #3                 ; Otherwise set the acceleration in byte #28 to 3
 STA INWK+28

 RTS                    ; Return from the subroutine

.TA9

 AND #%01111111         ; Clear the sign bit of the dot product in A

 CMP #18                ; If A < 18 then the ship is way off the XX15 vector, so
 BCC TA10               ; return from the subroutine (TA10 contains an RTS)
                        ; without slowing down, as it still has quite a bit of
                        ; turning to do to get on course

 LDA #$FF               ; Otherwise set A = -1

 LDX TYPE               ; If this is not a missile then skip the ASL instruction
 CPX #MSL
 BNE P%+3

 ASL A                  ; This is a missile, so set A = -2, as missiles are more
                        ; nimble and can brake more quickly

 STA INWK+28            ; Set the ship's acceleration to A

.TA10

 RTS                    ; Return from the subroutine

.TA151

                        ; This is called from part 3 with the vector to the
                        ; planet in XX15, when we want the ship to turn towards
                        ; the planet. It does the same dot product calculation
                        ; as part 3, but it can also change the value of RAT2
                        ; so that roll and pitch is always applied

 LDY #10                ; Set (A X) = nosev . XX15
 JSR TAS3               ;
                        ; The bigger the value of the dot product, the more
                        ; aligned the two vectors are, with a maximum magnitude
                        ; in A of 36 (96 * 96 >> 8). If A is positive, the
                        ; vectors are facing in a similar direction, if it's
                        ; negative they are facing in opposite directions

 CMP #$98               ; If A is positive or A <= -24, jump to ttt
 BCC ttt

 LDX #0                 ; A > -24, which means the vectors are facing in
 STX RAT2               ; opposite directions but are quite aligned, so set
                        ; RAT2 = 0 instead of the default value of 4, so we
                        ; always apply roll and pitch when we turn the ship
                        ; towards the planet

.ttt

 JMP TA152              ; Jump to TA152 to store A in CNT and move the ship in
                        ; the direction of XX15

; ******************************************************************************
;
;       Name: DOCKIT
;       Type: Subroutine
;   Category: Flight
;    Summary: Apply docking manoeuvres to the ship in INWK
;  Deep dive: The docking computer
;
; ******************************************************************************

.DOCKIT

 LDA #6                 ; Set RAT2 = 6, which is the threshold below which we
 STA RAT2               ; don't apply pitch and roll to the ship (so a lower
                        ; value means we apply pitch and roll more often, and a
                        ; value of 0 means we always apply them). The value is
                        ; compared with double the high byte of sidev . XX15,
                        ; where XX15 is the vector from the ship to the station

 LSR A                  ; Set RAT = 2, which is the magnitude we set the pitch
 STA RAT                ; or roll counter to in part 7 when turning a ship
                        ; towards a vector (a higher value giving a longer
                        ; turn)

 LDA #29                ; Set CNT2 = 29, which is the maximum angle beyond which
 STA CNT2               ; a ship will slow down to start turning towards its
                        ; prey (a lower value means a ship will start to slow
                        ; down even if its angle with the enemy ship is large,
                        ; which gives a tighter turn)

 LDA SSPR               ; If we are inside the space station safe zone, skip the
 BNE P%+5               ; next instruction

.GOPLS

 JMP GOPL               ; Jump to GOPL to make the ship head towards the planet

 JSR VCSU1              ; If we get here then we are in the space station safe
                        ; zone, so call VCSU1 to calculate the following, where
                        ; the station is at coordinates (station_x, station_y,
                        ; station_z):
                        ;
                        ;   K3(2 1 0) = (x_sign x_hi x_lo) - station_x
                        ;
                        ;   K3(5 4 3) = (y_sign y_hi z_lo) - station_y
                        ;
                        ;   K3(8 7 6) = (z_sign z_hi z_lo) - station_z
                        ;
                        ; so K3 contains the vector from the station to the ship

 LDA K3+2               ; If any of the top bytes of the K3 results above are
 ORA K3+5               ; non-zero (after removing the sign bits), jump to GOPL
 ORA K3+8               ; via GOPLS to make the ship head towards the planet, as
 AND #%01111111         ; this will aim the ship in the general direction of the
 BNE GOPLS              ; station (it's too far away for anything more accurate)

 JSR TA2                ; Call TA2 to calculate the length of the vector in K3
                        ; (ignoring the low coordinates), returning it in Q

 LDA Q                  ; Store the value of Q in K, so K now contains the
 STA K                  ; distance between station and the ship

 JSR TAS2               ; Call TAS2 to normalise the vector in K3, returning the
                        ; normalised version in XX15, so XX15 contains the unit
                        ; vector pointing from the station to the ship

 LDY #10                ; Call TAS4 to calculate:
 JSR TAS4               ;
                        ;   (A X) = nosev . XX15
                        ;
                        ; where nosev is the nose vector of the space station,
                        ; so this is the dot product of the station to ship
                        ; vector with the station's nosev (which points straight
                        ; out into space, out of the docking slot), and because
                        ; both vectors are unit vectors, the following is also
                        ; true:
                        ;
                        ;   (A X) = cos(t)
                        ;
                        ; where t is the angle between the two vectors
                        ;
                        ; If the dot product is positive, that means the vector
                        ; from the station to the ship and the nosev sticking
                        ; out of the docking slot are facing in a broadly
                        ; similar direction (so the ship is essentially heading
                        ; for the slot, which is facing towards the ship), and
                        ; if it's negative they are facing in broadly opposite
                        ; directions (so the station slot is on the opposite
                        ; side of the station as the ship approaches)

 BMI PH1                ; If the dot product is negative, i.e. the station slot
                        ; is on the opposite side, jump to PH1 to fly towards
                        ; the ideal docking position, some way in front of the
                        ; slot

 CMP #35                ; If the dot product < 35, jump to PH1 to fly towards
 BCC PH1                ; the ideal docking position, some way in front of the
                        ; slot, as there is a large angle between the vector
                        ; from the station to the ship and the station's nosev,
                        ; so the angle of approach is not very optimal
                        ;
                        ; Specifically, as the unit vector length is 96 in our
                        ; vector system,
                        ;
                        ;   (A X) = cos(t) < 35 / 96
                        ;
                        ; so:
                        ;
                        ;   t > arccos(35 / 96) = 68.6 degrees
                        ;
                        ; so the ship is coming in from the side of the station
                        ; at an angle between 68.6 and 90 degrees off the
                        ; optimal entry angle

                        ; If we get here, the slot is on the same side as the
                        ; ship and the angle of approach is less than 68.6
                        ; degrees, so we're heading in pretty much the correct
                        ; direction for a good approach to the docking slot

 LDY #10                ; Call TAS3 to calculate:
 JSR TAS3               ;
                        ;   (A X) = nosev . XX15
                        ;
                        ; where nosev is the nose vector of the ship, so this is
                        ; the dot product of the station to ship vector with the
                        ; ship's nosev, and is a measure of how close to the
                        ; station the ship is pointing, with negative meaning it
                        ; is pointing at the station, and positive meaning it is
                        ; pointing away from the station

 CMP #$A2               ; If the dot product is in the range 0 to -34, jump to
 BCS PH3                ; PH3 to refine our approach, as we are pointing towards
                        ; the station

                        ; If we get here, then we are not pointing straight at
                        ; the station, so check how close we are

 LDA K                  ; Fetch the distance to the station into A

;BEQ PH10               ; This instruction is commented out in the original
                        ; source

 CMP #157               ; If A < 157, jump to PH2 to turn away from the station,
 BCC PH2                ; as we are too close

 LDA TYPE               ; Fetch the ship type into A

 BMI PH3                ; If bit 7 is set, then that means the ship type was set
                        ; to -96 in the DOKEY routine when we switched on our
                        ; docking computer, so this is us auto-docking our
                        ; Cobra, so jump to PH3 to refine our approach
                        ;
                        ; Otherwise this is an NPC trying to dock, so keep going
                        ; to turn away from the station

.PH2

                        ; If we get here then we turn away from the station and
                        ; slow right down, effectively aborting this approach
                        ; attempt

 JSR TAS6               ; Call TAS6 to negate the vector in XX15 so it points in
                        ; the opposite direction, away from the station and
                        ; towards the ship

 JSR TA151              ; Call TA151 to make the ship head in the direction of
                        ; XX15, which makes the ship turn away from the station

.PH22

                        ; If we get here then we slam on the brakes and slow
                        ; right down

 LDX #0                 ; Set the acceleration in byte #28 to 0
 STX INWK+28

 INX                    ; Set the speed in byte #28 to 1
 STX INWK+27

 RTS                    ; Return from the subroutine

.PH1

                        ; If we get here then the slot is on the opposite side
                        ; of the station to the ship, or it's on the same side
                        ; and the approach angle is not optimal, so we just fly
                        ; towards the station, aiming for the ideal docking
                        ; position some distance in front of the slot

 JSR VCSU1              ; Call VCSU1 to set K3 to the vector from the station to
                        ; the ship

 JSR DCS1               ; Call DCS1 twice to calculate the vector from the ideal
 JSR DCS1               ; docking position to the ship, where the ideal docking
                        ; position is straight out of the docking slot at a
                        ; distance of 8 unit vectors from the centre of the
                        ; station

 JSR TAS2               ; Call TAS2 to normalise the vector in K3, returning the
                        ; normalised version in XX15

 JSR TAS6               ; Call TAS6 to negate the vector in XX15 so it points in
                        ; the opposite direction

 JMP TA151              ; Call TA151 to make the ship head in the direction of
                        ; XX15, which makes the ship turn towards the ideal
                        ; docking position, and return from the subroutine using
                        ; a tail call

.TN11

                        ; If we get here, we accelerate and apply a full
                        ; clockwise roll (which matches the space station's
                        ; roll)

 INC INWK+28            ; Increment the acceleration in byte #28

 LDA #%01111111         ; Set the roll counter to a positive (clockwise) roll
 STA INWK+29            ; with no damping, to match the space station's roll

 BNE TN13               ; Jump down to TN13 (this BNE is effectively a JMP as
                        ; A will never be zero)

.PH3

                        ; If we get here, we refine our approach using pitch and
                        ; roll to aim for the station

 LDX #0                 ; Set RAT2 = 0
 STX RAT2

 STX INWK+30            ; Set the pitch counter to 0 to stop any pitching

 LDA TYPE               ; If this is not our ship's docking computer, but is an
 BPL PH32               ; NPC ship trying to dock, jump to PH32

                        ; In the following, ship_x and ship_y are the x and
                        ; y-coordinates of XX15, the vector from the station to
                        ; the ship

 EOR XX15               ; A is negative, so this sets the sign of A to the same
 EOR XX15+1             ; as -XX15 * XX15+1, or -ship_x * ship_y

 ASL A                  ; Shift the sign bit into the C flag, so the C flag has
                        ; the following sign:
                        ;
                        ;   * Positive if ship_x and ship_y have different signs
                        ;   * Negative if ship_x and ship_y have the same sign

 LDA #2                 ; Set A = +2 or -2, giving it the sign in the C flag,
 ROR A                  ; and store it in byte #29, the roll counter, so that
 STA INWK+29            ; the ship rolls towards the station

 LDA XX15               ; If |ship_x * 2| >= 12, i.e. |ship_x| >= 6, then jump
 ASL A                  ; to PH22 to slow right down and return from the
 CMP #12                ; subroutine, as the station is not in our sights
 BCS PH22

 LDA XX15+1             ; Set A = +2 or -2, giving it the same sign as ship_y,
 ASL A                  ; and store it in byte #30, the pitch counter, so that
 LDA #2                 ; the ship pitches towards the station
 ROR A
 STA INWK+30

 LDA XX15+1             ; If |ship_y * 2| >= 12, i.e. |ship_y| >= 6, then jump
 ASL A                  ; to PH22 to slow right down and return from the
 CMP #12                ; subroutine, as the station is not in our sights
 BCS PH22

.PH32

                        ; If we get here, we try to match the station roll

 STX INWK+29            ; Set the roll counter to 0 to stop any pitching

 LDA INWK+22            ; Set XX15 = sidev_x_hi
 STA XX15

 LDA INWK+24            ; Set XX15+1 = sidev_y_hi
 STA XX15+1

 LDA INWK+26            ; Set XX15+2 = sidev_z_hi
 STA XX15+2             ;
                        ; so XX15 contains the sidev vector of the ship

 LDY #16                ; Call TAS4 to calculate:
 JSR TAS4               ;
                        ;   (A X) = roofv . XX15
                        ;
                        ; where roofv is the roof vector of the space station.
                        ; To dock with the slot horizontal, we want roofv to be
                        ; pointing off to the side, i.e. parallel to the ship's
                        ; sidev vector, which means we want the dot product to
                        ; be large (it can be positive or negative, as roofv can
                        ; point left or right - it just needs to be parallel to
                        ; the ship's sidev)

 ASL A                  ; If |A * 2| >= 66, i.e. |A| >= 33, then the ship is
 CMP #66                ; lined up with the slot, so jump to TN11 to accelerate
 BCS TN11               ; and roll clockwise (a positive roll) before jumping
                        ; down to TN13 to check if we're docked yet

 JSR PH22               ; Call PH22 to slow right down, as we haven't yet
                        ; matched the station's roll

.TN13

                        ; If we get here, we check to see if we have docked

 LDA K3+10              ; If K3+10 is non-zero, skip to TNRTS, to return from
 BNE TNRTS              ; the subroutine
                        ;
                        ; I have to say I have no idea what K3+10 contains, as
                        ; it isn't mentioned anywhere in the whole codebase
                        ; apart from here, but it does share a location with
                        ; XX2+10, so it will sometimes be non-zero (specifically
                        ; when face #10 in the ship we're drawing is visible,
                        ; which probably happens quite a lot). This would seem
                        ; to affect whether an NPC ship can dock, as that's the
                        ; code that gets skipped if K3+10 is non-zero, but as
                        ; to what this means... that's not yet clear

 ASL NEWB               ; Set bit 7 of the ship's NEWB flags to indicate that
 SEC                    ; the ship has now docked, which only has meaning if
 ROR NEWB               ; this is an NPC trying to dock

.TNRTS

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: VCSU1
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate vector K3(8 0) = [x y z] - coordinates of the sun or
;             space station
;
; ------------------------------------------------------------------------------
;
; Calculate the following:
;
;   K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate of the sun or space station
;
;   K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate of the sun or space station
;
;   K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate of the sun or space station
;
; where the first coordinate is from the ship data block in INWK, and the second
; coordinate is from the sun or space station's ship data block which they
; share.
;
; ******************************************************************************

.VCSU1

 LDA #LO(K%+NI%)        ; Set the low byte of V(1 0) to point to the coordinates
 STA V                  ; of the sun or space station

 LDA #HI(K%+NI%)        ; Set A to the high byte of the address of the
                        ; coordinates of the sun or space station

                        ; Fall through into VCSUB to calculate:
                        ;
                        ;   K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate of sun
                        ;               or space station
                        ;
                        ;   K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate of sun
                        ;               or space station
                        ;
                        ;   K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate of sun
                        ;               or space station

; ******************************************************************************
;
;       Name: VCSUB
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate vector K3(8 0) = [x y z] - coordinates in (A V)
;
; ------------------------------------------------------------------------------
;
; Calculate the following:
;
;   K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate in (A V)
;
;   K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate in (A V)
;
;   K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate in (A V)
;
; where the first coordinate is from the ship data block in INWK, and the second
; coordinate is from the ship data block pointed to by (A V).
;
; ******************************************************************************

.VCSUB

 STA V+1                ; Set the low byte of V(1 0) to A, so now V(1 0) = (A V)

 LDY #2                 ; K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate in data
 JSR TAS1               ; block at V(1 0)

 LDY #5                 ; K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate of data
 JSR TAS1               ; block at V(1 0)

 LDY #8                 ; Fall through into TAS1 to calculate the final result:
                        ;
                        ; K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate of data
                        ; block at V(1 0)

; ******************************************************************************
;
;       Name: TAS1
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate K3 = (x_sign x_hi x_lo) - V(1 0)
;
; ------------------------------------------------------------------------------
;
; Calculate one of the following, depending on the value in Y:
;
;   K3(2 1 0) = (x_sign x_hi x_lo) - x-coordinate in V(1 0)
;
;   K3(5 4 3) = (y_sign y_hi z_lo) - y-coordinate in V(1 0)
;
;   K3(8 7 6) = (z_sign z_hi z_lo) - z-coordinate in V(1 0)
;
; where the first coordinate is from the ship data block in INWK, and the second
; coordinate is from the ship data block pointed to by V(1 0).
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   V(1 0)              The address of the ship data block to subtract
;
;   Y                   The coordinate in the V(1 0) block to subtract:
;
;                         * If Y = 2, subtract the x-coordinate and store the
;                           result in K3(2 1 0)
;
;                         * If Y = 5, subtract the y-coordinate and store the
;                           result in K3(5 4 3)
;
;                         * If Y = 8, subtract the z-coordinate and store the
;                           result in K3(8 7 6)
;
; ******************************************************************************

.TAS1

 LDA (V),Y              ; Copy the sign byte of the V(1 0) coordinate into K+3,
 EOR #%10000000         ; flipping it in the process
 STA K+3

 DEY                    ; Copy the high byte of the V(1 0) coordinate into K+2
 LDA (V),Y
 STA K+2

 DEY                    ; Copy the high byte of the V(1 0) coordinate into K+1,
 LDA (V),Y              ; so now:
 STA K+1                ;
                        ;   K(3 2 1) = - coordinate in V(1 0)

 STY U                  ; Copy the index (now 0, 3 or 6) into U and X
 LDX U

 JSR MVT3               ; Call MVT3 to add the same coordinates, but this time
                        ; from INWK, so this would look like this for the
                        ; x-axis:
                        ;
                        ;   K(3 2 1) = (x_sign x_hi x_lo) + K(3 2 1)
                        ;            = (x_sign x_hi x_lo) - coordinate in V(1 0)

 LDY U                  ; Restore the index into Y, though this instruction has
                        ; no effect, as Y is not used again, either here or
                        ; following calls to this routine

 STA K3+2,X             ; Store K(3 2 1) in K3+X(2 1 0), starting with the sign
                        ; byte

 LDA K+2                ; And then doing the high byte
 STA K3+1,X

 LDA K+1                ; And finally the low byte
 STA K3,X

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TAS4
;       Type: Subroutine
;   Category: Maths (Geometry)
;    Summary: Calculate the dot product of XX15 and one of the space station's
;             orientation vectors
;
; ------------------------------------------------------------------------------
;
; Calculate the dot product of the vector in XX15 and one of the space station's
; orientation vectors, as determined by the value of Y. If vect is the space
; station orientation vector, we calculate this:
;
;   (A X) = vect . XX15
;         = vect_x * XX15 + vect_y * XX15+1 + vect_z * XX15+2
;
; Technically speaking, this routine can also calculate the dot product between
; XX15 and the sun's orientation vectors, as the sun and space station share the
; same ship data slot (the second ship data block at K%). However, the sun
; doesn't have orientation vectors, so this only gets called when that slot is
; being used for the space station.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   Y                   The space station's orientation vector:
;
;                         * If Y = 10, calculate nosev . XX15
;
;                         * If Y = 16, calculate roofv . XX15
;
;                         * If Y = 22, calculate sidev . XX15
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   (A X)               The result of the dot product
;
; ******************************************************************************

.TAS4

 LDX K%+NI%,Y           ; Set Q = the Y-th byte of K%+NI%, i.e. vect_x from the
 STX Q                  ; second ship data block at K%

 LDA XX15               ; Set A = XX15

 JSR MULT12             ; Set (S R) = Q * A
                        ;           = vect_x * XX15

 LDX K%+NI%+2,Y         ; Set Q = the Y+2-th byte of K%+NI%, i.e. vect_y
 STX Q

 LDA XX15+1             ; Set A = XX15+1

 JSR MAD                ; Set (A X) = Q * A + (S R)
                        ;           = vect_y * XX15+1 + vect_x * XX15

 STA S                  ; Set (S R) = (A X)
 STX R

 LDX K%+NI%+4,Y         ; Set Q = the Y+2-th byte of K%+NI%, i.e. vect_z
 STX Q

 LDA XX15+2             ; Set A = XX15+2

 JMP MAD                ; Set:
                        ;
                        ;   (A X) = Q * A + (S R)
                        ;           = vect_z * XX15+2 + vect_y * XX15+1 +
                        ;             vect_x * XX15
                        ;
                        ; and return from the subroutine using a tail call

; ******************************************************************************
;
;       Name: TAS6
;       Type: Subroutine
;   Category: Maths (Geometry)
;    Summary: Negate the vector in XX15 so it points in the opposite direction
;
; ******************************************************************************

.TAS6

 LDA XX15               ; Reverse the sign of the x-coordinate of the vector in
 EOR #%10000000         ; XX15
 STA XX15

 LDA XX15+1             ; Then reverse the sign of the y-coordinate
 EOR #%10000000
 STA XX15+1

 LDA XX15+2             ; And then the z-coordinate, so now the XX15 vector is
 EOR #%10000000         ; pointing in the opposite direction
 STA XX15+2

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: DCS1
;       Type: Subroutine
;   Category: Flight
;    Summary: Calculate the vector from the ideal docking position to the ship
;
; ------------------------------------------------------------------------------
;
; This routine is called by the docking computer routine in DOCKIT. It works out
; the vector between the ship and the ideal docking position, which is straight
; in front of the docking slot, but some distance away.
;
; Specifically, it calculates the following:
;
;   * K3(2 1 0) = K3(2 1 0) - nosev_x_hi * 4
;
;   * K3(5 4 3) = K3(5 4 3) - nosev_y_hi * 4
;
;   * K3(8 7 6) = K3(8 7 6) - nosev_x_hi * 4
;
; where K3 is the vector from the station to the ship, and nosev is the nose
; vector for the space station.
;
; The nose vector points from the centre of the station through the slot, so
; -nosev * 4 is the vector from a point in front of the docking slot, but some
; way from the station, back to the centre of the station. Adding this to the
; vector from the station to the ship gives the vector from the point in front
; of the station to the ship.
;
; In practice, this routine is called twice, so the ideal docking position is
; actually at a distance of 8 unit vectors from the centre of the station.
;
; Back in DOCKIT, we flip this vector round to get the vector from the ship to
; the point in front of the station slot.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   K3                  The vector from the station to the ship
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   K3                  The vector from the ship to the ideal docking position
;                       (4 unit vectors from the centre of the station for each
;                       call to DCS1, so two calls will return the vector to a
;                       point that's 8 unit vectors from the centre of the
;                       station)
;
; ******************************************************************************

.DCS1

 JSR P%+3               ; Run the following routine twice, so the subtractions
                        ; are all * 4

 LDA K%+NI%+10          ; Set A to the space station's byte #10, nosev_x_hi

 LDX #0                 ; Set K3(2 1 0) = K3(2 1 0) - A * 2
 JSR TAS7               ;               = K3(2 1 0) - nosev_x_hi * 2

 LDA K%+NI%+12          ; Set A to the space station's byte #12, nosev_y_hi

 LDX #3                 ; Set K3(5 4 3) = K3(5 4 3) - A * 2
 JSR TAS7               ;               = K3(5 4 3) - nosev_y_hi * 2

 LDA K%+NI%+14          ; Set A to the space station's byte #14, nosev_z_hi

 LDX #6                 ; Set K3(8 7 6) = K3(8 7 6) - A * 2
                        ;               = K3(8 7 6) - nosev_x_hi * 2

.TAS7

                        ; This routine subtracts A * 2 from one of the K3
                        ; coordinates, as determined by the value of X:
                        ;
                        ;   * X = 0, set K3(2 1 0) = K3(2 1 0) - A * 2
                        ;
                        ;   * X = 3, set K3(5 4 3) = K3(5 4 3) - A * 2
                        ;
                        ;   * X = 6, set K3(8 7 6) = K3(8 7 6) - A * 2
                        ;
                        ; Let's document it for X = 0, i.e. K3(2 1 0)

 ASL A                  ; Shift A left one place and move the sign bit into the
                        ; C flag, so A = |A * 2|

 STA R                  ; Set R = |A * 2|

 LDA #0                 ; Rotate the sign bit of A from the C flag into the sign
 ROR A                  ; bit of A, so A is now just the sign bit from the
                        ; original value of A. This also clears the C flag

 EOR #%10000000         ; Flip the sign bit of A, so it has the sign of -A

 EOR K3+2,X             ; Give A the correct sign of K3(2 1 0) * -A

 BMI TS71               ; If the sign of K3(2 1 0) * -A is negative, jump to
                        ; TS71, as K3(2 1 0) and A have the same sign

                        ; If we get here then K3(2 1 0) and A have different
                        ; signs, so we can add them to do the subtraction

 LDA R                  ; Set K3(2 1 0) = K3(2 1 0) + R
 ADC K3,X               ;               = K3(2 1 0) + |A * 2|
 STA K3,X               ;
                        ; starting with the low bytes

 BCC TS72               ; If the above addition didn't overflow, we have the
                        ; result we want, so jump to TS72 to return from the
                        ; subroutine

 INC K3+1,X             ; The above addition overflowed, so increment the high
                        ; byte of K3(2 1 0)

.TS72

 RTS                    ; Return from the subroutine

.TS71

                        ; If we get here, then K3(2 1 0) and A have the same
                        ; sign

 LDA K3,X               ; Set K3(2 1 0) = K3(2 1 0) - R
 SEC                    ;               = K3(2 1 0) - |A * 2|
 SBC R                  ;
 STA K3,X               ; starting with the low bytes

 LDA K3+1,X             ; And then the high bytes
 SBC #0
 STA K3+1,X

 BCS TS72               ; If the subtraction didn't underflow, we have the
                        ; result we want, so jump to TS72 to return from the
                        ; subroutine

 LDA K3,X               ; Negate the result in K3(2 1 0) by flipping all the
 EOR #%11111111         ; bits and adding 1, i.e. using two's complement to
 ADC #1                 ; give it the opposite sign, starting with the low
 STA K3,X               ; bytes

 LDA K3+1,X             ; Then doing the high bytes
 EOR #%11111111
 ADC #0
 STA K3+1,X

 LDA K3+2,X             ; And finally, flipping the sign bit
 EOR #%10000000
 STA K3+2,X

 JMP TS72               ; Jump to TS72 to return from the subroutine

; ******************************************************************************
;
;       Name: HITCH
;       Type: Subroutine
;   Category: Tactics
;    Summary: Work out if the ship in INWK is in our crosshairs
;  Deep dive: In the crosshairs
;
; ------------------------------------------------------------------------------
;
; This is called by the main flight loop to see if we have laser or missile lock
; on an enemy ship.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              Set if the ship is in our crosshairs, clear if it isn't
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   HI1                 Contains an RTS
;
; ******************************************************************************

.HITCH

 CLC                    ; Clear the C flag so we can return with it cleared if
                        ; our checks fail

 LDA INWK+8             ; Set A = z_sign

 BNE HI1                ; If A is non-zero then the ship is behind us and can't
                        ; be in our crosshairs, so return from the subroutine
                        ; with the C flag clear (as HI1 contains an RTS)

 LDA TYPE               ; If the ship type has bit 7 set then it is the planet
 BMI HI1                ; or sun, which we can't target or hit with lasers, so
                        ; return from the subroutine with the C flag clear (as
                        ; HI1 contains an RTS)

 LDA INWK+31            ; Fetch bit 5 of byte #31 (the exploding flag) and OR
 AND #%00100000         ; with x_hi and y_hi
 ORA INWK+1
 ORA INWK+4

 BNE HI1                ; If this value is non-zero then either the ship is
                        ; exploding (so we can't target it), or the ship is too
                        ; far away from our line of fire to be targeted, so
                        ; return from the subroutine with the C flag clear (as
                        ; HI1 contains an RTS)

 LDA INWK               ; Set A = x_lo

 JSR SQUA2              ; Set (A P) = A * A = x_lo^2

 STA S                  ; Set (S R) = (A P) = x_lo^2
 LDA P
 STA R

 LDA INWK+3             ; Set A = y_lo

 JSR SQUA2              ; Set (A P) = A * A = y_lo^2

 TAX                    ; Store the high byte in X

 LDA P                  ; Add the two low bytes, so:
 ADC R                  ;
 STA R                  ;   R = P + R

 TXA                    ; Restore the high byte into A and add S to give the
 ADC S                  ; following:
                        ;
                        ;   (A R) = (S R) + (A P) = x_lo^2 + y_lo^2

 BCS TN10               ; If the addition just overflowed then there is no way
                        ; our crosshairs are within the ship's targetable area,
                        ; so return from the subroutine with the C flag clear
                        ; (as TN10 contains a CLC then an RTS)

 STA S                  ; Set (S R) = (A P) = x_lo^2 + y_lo^2

 LDY #2                 ; Fetch the ship's blueprint and set A to the high byte
 LDA (XX0),Y            ; of the targetable area of the ship

 CMP S                  ; We now compare the high bytes of the targetable area
                        ; and the calculation in (S R):
                        ;
                        ;   * If A >= S then then the C flag will be set
                        ;
                        ;   * If A < S then the C flag will be C clear

 BNE HI1                ; If A <> S we have just set the C flag correctly, so
                        ; return from the subroutine (as HI1 contains an RTS)

 DEY                    ; The high bytes were identical, so now we fetch the
 LDA (XX0),Y            ; low byte of the targetable area into A

 CMP R                  ; We now compare the low bytes of the targetable area
                        ; and the calculation in (S R):
                        ;
                        ;   * If A >= R then the C flag will be set
                        ;
                        ;   * If A < R then the C flag will be C clear

.HI1

 RTS                    ; Return from the subroutine

.TN10

 CLC                    ; Clear the C flag to indicate the ship is not in our
                        ; crosshairs

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: FRS1
;       Type: Subroutine
;   Category: Tactics
;    Summary: Launch a ship straight ahead of us, below the laser sights
;
; ------------------------------------------------------------------------------
;
; This is used in two places:
;
;   * When we launch a missile, in which case the missile is the ship that is
;     launched ahead of us
;
;   * When we launch our escape pod, in which case it's our abandoned Cobra Mk
;     III that is launched ahead of us
;
;   * The fq1 entry point is used to launch a bunch of cargo canisters ahead of
;     us as part of the death screen
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The type of ship to launch ahead of us
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              Set if the ship was successfully launched, clear if it
;                       wasn't (as there wasn't enough free memory)
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   fq1                 Used to add a cargo canister to the universe
;
; ******************************************************************************

.FRS1

 JSR ZINF               ; Call ZINF to reset the INWK ship workspace

 LDA #28                ; Set y_lo = 28
 STA INWK+3

 LSR A                  ; Set z_lo = 14, so the launched ship starts out
 STA INWK+6             ; ahead of us

 LDA #%10000000         ; Set y_sign to be negative, so the launched ship is
 STA INWK+5             ; launched just below our line of sight

 LDA MSTG               ; Set A to the missile lock target, shifted left so the
 ASL A                  ; slot number is in bits 1-5

 ORA #%10000000         ; Set bit 7 and store the result in byte #32, the AI
 STA INWK+32            ; flag launched ship for the launched ship. For missiles
                        ; this enables AI (bit 7), makes it friendly towards us
                        ; (bit 6), sets the target to the value of MSTG (bits
                        ; 1-5), and sets its lock status as launched (bit 0).
                        ; It doesn't matter what it does for our abandoned
                        ; Cobra, as the AI flag gets overwritten once we return
                        ; from the subroutine back to the ESCAPE routine that
                        ; called FRS1 in the first place

.fq1

 LDA #$60               ; Set byte #14 (nosev_z_hi) to 1 ($60), so the launched
 STA INWK+14            ; ship is pointing away from us

 ORA #128               ; Set byte #22 (sidev_x_hi) to -1 ($D0), so the launched
 STA INWK+22            ; ship has the same orientation as spawned ships, just
                        ; pointing away from us (if we set sidev to +1 instead,
                        ; this ship would be a mirror image of all the other
                        ; ships, which are spawned with -1 in nosev and +1 in
                        ; sidev)

 LDA DELTA              ; Set byte #27 (speed) to 2 * DELTA, so the launched
 ROL A                  ; ship flies off at twice our speed
 STA INWK+27

 TXA                    ; Add a new ship of type X to our local bubble of
 JMP NWSHP              ; universe and return from the subroutine using a tail
                        ; call

; ******************************************************************************
;
;       Name: FRMIS
;       Type: Subroutine
;   Category: Tactics
;    Summary: Fire a missile from our ship
;
; ------------------------------------------------------------------------------
;
; We fired a missile, so send it streaking away from us to unleash mayhem and
; destruction on our sworn enemies.
;
; ******************************************************************************

.FRMIS

 LDX #MSL               ; Call FRS1 to launch a missile straight ahead of us
 JSR FRS1

 BCC FR1                ; If FRS1 returns with the C flag clear, then there
                        ; isn't room in the universe for our missile, so jump
                        ; down to FR1 to display a "missile jammed" message

 LDX MSTG               ; Fetch the slot number of the missile's target

 JSR GINF               ; Get the address of the data block for the target ship
                        ; and store it in INF

 LDA FRIN,X             ; Fetch the ship type of the missile's target into A

 JSR ANGRY              ; Call ANGRY to make the target ship hostile

 LDY #BLACK             ; We have just launched a missile, so we need to remove
 JSR ABORT              ; missile lock and hide the leftmost indicator on the
                        ; dashboard by setting it to black

 DEC NOMSL              ; Reduce the number of missiles we have by 1

 LDY #120               ; Call the SOHISS routine with Y = 120 to make the sound
 JSR SOHISS             ; of a missile launch ???

                        ; Fall through into ANGRY to make the missile target
                        ; angry, though as we already did this above, I'm not
                        ; entirely sure why we do this again

; ******************************************************************************
;
;       Name: ANGRY
;       Type: Subroutine
;   Category: Tactics
;    Summary: Make a ship hostile
;
; ------------------------------------------------------------------------------
;
; All this routine does is set the ship's hostile flag, start it turning and
; give it a kick of acceleration - later calls to TACTICS will make the ship
; start to attack us.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The type of ship we're going to irritate
;
;   INF                 The address of the data block for the ship we're going
;                       to infuriate
;
; ******************************************************************************

.ANGRY

 CMP #SST               ; If this is the space station, jump to AN2 to make the
 BEQ AN2                ; space station hostile

 LDY #36                ; Fetch the ship's NEWB flags from byte #36
 LDA (INF),Y

 AND #%00100000         ; If bit 5 of the ship's NEWB flags is clear, skip the
 BEQ P%+5               ; following instruction, otherwise bit 5 is set, meaning
                        ; this ship is an innocent bystander, and attacking it
                        ; will annoy the space station

 JSR AN2                ; Call AN2 to make the space station hostile

 LDY #32                ; Fetch the ship's byte #32 (AI flag)
 LDA (INF),Y

 BEQ HI1                ; If the AI flag is zero then this ship has no AI and
                        ; it can't get hostile, so return from the subroutine
                        ; (as HI1 contains an RTS)

 ORA #%10000000         ; Otherwise set bit 7 (AI enabled) to ensure AI is
 STA (INF),Y            ; definitely enabled

 LDY #28                ; Set the ship's byte #28 (acceleration) to 2, so it
 LDA #2                 ; speeds up
 STA (INF),Y

 ASL A                  ; Set the ship's byte #30 (pitch counter) to 4, so it
 LDY #30                ; starts diving
 STA (INF),Y

 LDA TYPE               ; If the ship's type is < #CYL (i.e. a missile, Coriolis
 CMP #CYL               ; space station, escape pod, plate, cargo canister,
 BCC AN3                ; boulder, asteroid, splinter, Shuttle or Transporter),
                        ; then jump to AN3 to skip the following

 LDY #36                ; Set bit 2 of the ship's NEWB flags in byte #36 to
 LDA (INF),Y            ; make this ship hostile
 ORA #%00000100
 STA (INF),Y

.AN3

 RTS                    ; Return from the subroutine

.AN2

 LDA K%+NI%+36          ; Set bit 2 of the NEWB flags in byte #36 of the second
 ORA #%00000100         ; ship in the ship data workspace at K%, which is
 STA K%+NI%+36          ; reserved for the sun or the space station (in this
                        ; case it's the latter), to make it hostile

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: FR1
;       Type: Subroutine
;   Category: Tactics
;    Summary: Display the "missile jammed" message
;
; ------------------------------------------------------------------------------
;
; This is shown if there isn't room in the local bubble of universe for a new
; missile.
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   FR1-2               Clear the C flag and return from the subroutine
;
; ******************************************************************************

.FR1

 LDA #201               ; Print recursive token 41 ("MISSILE JAMMED") as an
 JMP MESS               ; in-flight message and return from the subroutine using
                        ; a tail call

; ******************************************************************************
;
;       Name: SESCP
;       Type: Subroutine
;   Category: Flight
;    Summary: Spawn an escape pod from the current (parent) ship
;
; ------------------------------------------------------------------------------
;
; This is called when an enemy ship has run out of both energy and luck, so it's
; time to bail.
;
; ******************************************************************************

.SESCP

 LDX #ESC               ; Set X to the ship type for an escape pod

 LDA #%11111110         ; Set A to an AI flag that has AI enabled, is hostile,
                        ; but has no E.C.M.

                        ; Fall through into SFS1 to spawn the escape pod

; ******************************************************************************
;
;       Name: SFS1
;       Type: Subroutine
;   Category: Universe
;    Summary: Spawn a child ship from the current (parent) ship
;
; ------------------------------------------------------------------------------
;
; If the parent is a space station then the child ship is spawned coming out of
; the slot, and if the child is a cargo canister, it is sent tumbling through
; space. Otherwise the child ship is spawned with the same ship data as the
; parent, just with damping disabled and the ship type and AI flag that are
; passed in A and X.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   AI flag for the new ship (see the documentation on ship
;                       data byte #32 for details)
;
;   X                   The ship type of the child to spawn
;
;   INF                 Address of the parent's ship data block
;
;   TYPE                The type of the parent ship
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              Set if ship successfully added, clear if it failed
;
;   INF                 INF is preserved
;
;   XX0                 XX0 is preserved
;
;   INWK                The whole INWK workspace is preserved
;
;   X                   X is preserved
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   SFS1-2              Add a missile to the local bubble that has AI enabled,
;                       is hostile, but has no E.C.M.
;
; ******************************************************************************

.SFS1

 STA T1                 ; Store the child ship's AI flag in T1

                        ; Before spawning our child ship, we need to save the
                        ; INF and XX00 variables and the whole INWK workspace,
                        ; so we can restore them later when returning from the
                        ; subroutine

 TXA                    ; Store X, the ship type to spawn, on the stack so we
 PHA                    ; can preserve it through the routine

 LDA XX0                ; Store XX0(1 0) on the stack, so we can restore it
 PHA                    ; later when returning from the subroutine
 LDA XX0+1
 PHA

 LDA INF                ; Store INF(1 0) on the stack, so we can restore it
 PHA                    ; later when returning from the subroutine
 LDA INF+1
 PHA

 LDY #NI%-1             ; Now we want to store the current INWK data block in
                        ; temporary memory so we can restore it when we are
                        ; done, and we also want to copy the parent's ship data
                        ; into INWK, which we can do at the same time, so set up
                        ; a counter in Y for NI% bytes

.FRL2

 LDA INWK,Y             ; Copy the Y-th byte of INWK to the Y-th byte of
 STA XX3,Y              ; temporary memory in XX3, so we can restore it later
                        ; when returning from the subroutine

 LDA (INF),Y            ; Copy the Y-th byte of the parent ship's data block to
 STA INWK,Y             ; the Y-th byte of INWK

 DEY                    ; Decrement the loop counter

 BPL FRL2               ; Loop back to copy the next byte until we have done
                        ; them all

                        ; INWK now contains the ship data for the parent ship,
                        ; so now we need to tweak the data before creating the
                        ; new child ship (in this way, the child inherits things
                        ; like location from the parent)

 LDA TYPE               ; Fetch the ship type of the parent into A

 CMP #SST               ; If the parent is not a space station, jump to rx to
 BNE rx                 ; skip the following

                        ; The parent is a space station, so the child needs to
                        ; launch out of the space station's slot. The space
                        ; station's nosev vector points out of the station's
                        ; slot, so we want to move the ship along this vector.
                        ; We do this by taking the unit vector in nosev and
                        ; doubling it, so we spawn our ship 2 units along the
                        ; vector from the space station's centre

 TXA                    ; Store the child's ship type in X on the stack
 PHA

 LDA #32                ; Set the child's byte #27 (speed) to 32
 STA INWK+27

 LDX #0                 ; Add 2 * nosev_x_hi to (x_lo, x_hi, x_sign) to get the
 LDA INWK+10            ; child's x-coordinate
 JSR SFS2

 LDX #3                 ; Add 2 * nosev_y_hi to (y_lo, y_hi, y_sign) to get the
 LDA INWK+12            ; child's y-coordinate
 JSR SFS2

 LDX #6                 ; Add 2 * nosev_z_hi to (z_lo, z_hi, z_sign) to get the
 LDA INWK+14            ; child's z-coordinate
 JSR SFS2

 PLA                    ; Restore the child's ship type from the stack into X
 TAX

.rx

 LDA T1                 ; Restore the child ship's AI flag from T1 and store it
 STA INWK+32            ; in the child's byte #32 (AI)

 LSR INWK+29            ; Clear bit 0 of the child's byte #29 (roll counter) so
 ASL INWK+29            ; that its roll dampens (so if we are spawning from a
                        ; space station, for example, the spawned ship won't
                        ; keep rolling forever)

 TXA                    ; Copy the child's ship type from X into A

 CMP #SPL+1             ; If the type of the child we are spawning is less than
 BCS NOIL               ; #PLT or greater than #SPL - i.e. not an alloy plate,
 CMP #PLT               ; cargo canister, boulder, asteroid or splinter - then
 BCC NOIL               ; jump to NOIL to skip us setting up some pitch and roll
                        ; for it

 PHA                    ; Store the child's ship type on the stack so we can
                        ; retrieve it below

 JSR DORND              ; Set A and X to random numbers

 ASL A                  ; Set the child's byte #30 (pitch counter) to a random
 STA INWK+30            ; value, and at the same time set the C flag randomly

 TXA                    ; Set the child's byte #27 (speed) to a random value
 AND #%00001111         ; between 0 and 15
 STA INWK+27

 LDA #$FF               ; Set the child's byte #29 (roll counter) to a full
 ROR A                  ; roll with no damping (as bits 0 to 6 are set), so the
 STA INWK+29            ; canister tumbles through space, with the direction in
                        ; bit 7 set randomly, depending on the C flag from above

 PLA                    ; Retrieve the child's ship type from the stack

.NOIL

 JSR NWSHP              ; Add a new ship of type A to the local bubble

                        ; We have now created our child ship, so we need to
                        ; restore all the variables we saved at the start of
                        ; the routine, so they are preserved when we return
                        ; from the subroutine

 PLA                    ; Restore INF(1 0) from the stack
 STA INF+1
 PLA
 STA INF

 LDX #NI%-1             ; Now to restore the INWK workspace that we saved into
                        ; XX3 above, so set a counter in X for NI% bytes

.FRL3

 LDA XX3,X              ; Copy the Y-th byte of XX3 to the Y-th byte of INWK
 STA INWK,X

 DEX                    ; Decrement the loop counter

 BPL FRL3               ; Loop back to copy the next byte until we have done
                        ; them all

 PLA                    ; Restore XX0(1 0) from the stack
 STA XX0+1
 PLA
 STA XX0

 PLA                    ; Retrieve the ship type to spawn from the stack into X
 TAX                    ; so it is preserved through calls to this routine

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: SFS2
;       Type: Subroutine
;   Category: Moving
;    Summary: Move a ship in space along one of the coordinate axes
;
; ------------------------------------------------------------------------------
;
; Move a ship's coordinates by a certain amount in the direction of one of the
; axes, where X determines the axis. Mathematically speaking, this routine
; translates the ship along a single axis by a signed delta.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The amount of movement, i.e. the signed delta
;
;   X                   Determines which coordinate axis of INWK to move:
;
;                         * X = 0 moves the ship along the x-axis
;
;                         * X = 3 moves the ship along the y-axis
;
;                         * X = 6 moves the ship along the z-axis
;
; ******************************************************************************

.SFS2

 ASL A                  ; Set R = |A * 2|, with the C flag set to bit 7 of A
 STA R

 LDA #0                 ; Set bit 7 of A to the C flag, i.e. the sign bit from
 ROR A                  ; the original argument in A

 JMP MVT1               ; Add the delta R with sign A to (x_lo, x_hi, x_sign)
                        ; (or y or z, depending on the value in X) and return
                        ; from the subroutine using a tail call

; ******************************************************************************
;
;       Name: LL164
;       Type: Subroutine
;   Category: Drawing circles
;    Summary: Make the hyperspace sound and draw the hyperspace tunnel
;
; ------------------------------------------------------------------------------
;
; See the IRQ1 routine for details on the multi-coloured effect that's used.
;
; ******************************************************************************

.LL164

 LDA #255               ; ???

.BEEPL7

 STA T2                 ; ???
 TAX
 LDY #90
 JSR SOBLIP
 LDA T2
 SBC #10
 CMP #170
 BCS BEEPL7

 LDA #4                 ; Set the step size for the hyperspace rings to 4, so
                        ; there are more sections in the rings and they are
                        ; quite round (compared to the step size of 8 used in
                        ; the much more polygonal launch rings)

 JSR HFS2               ; Call HFS2 to draw the hyperspace tunnel rings

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: LAUN
;       Type: Subroutine
;   Category: Drawing circles
;    Summary: Make the launch sound and draw the launch tunnel
;
; ------------------------------------------------------------------------------
;
; This is shown when launching from or docking with the space station.
;
; ******************************************************************************

.LAUN

 LDY #0                 ; ???
 JSR SOHISS
 JSR SOHISS

 LDA #8                 ; Set the step size for the launch tunnel rings to 8, so
                        ; there are fewer sections in the rings and they are
                        ; quite polygonal (compared to the step size of 4 used
                        ; in the much rounder hyperspace rings)

                        ; Fall through into HFS2 to draw the launch tunnel rings

; ******************************************************************************
;
;       Name: HFS2
;       Type: Subroutine
;   Category: Drawing circles
;    Summary: Draw the launch or hyperspace tunnel
;
; ------------------------------------------------------------------------------
;
; The animation gets drawn like this. First, we draw a circle of radius 8 at the
; centre, and then double the radius, draw another circle, double the radius
; again and draw a circle, and we keep doing this until the radius is bigger
; than 160 (which goes beyond the edge of the screen, which is 256 pixels wide,
; equivalent to a radius of 128). We then repeat this whole process for an
; initial circle of radius 9, then radius 10, all the way up to radius 15.
;
; This has the effect of making the tunnel appear to be racing towards us as we
; hurtle out into hyperspace or through the space station's docking tunnel.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The step size of the straight lines making up the rings
;                       (4 for launch, 8 for hyperspace)
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   HFS1                Don't clear the screen, and draw 8 concentric rings
;                       with the step size in STP
;
; ******************************************************************************

.HFS2

 STA STP                ; Store the step size in A

 LDA QQ11               ; Store the current view type in QQ11 on the stack
 PHA

 LDA #0                 ; Clear the top part of the screen, draw a white border,
 JSR TT66               ; and set the current view type in QQ11 to 0 (the space
                        ; view)

 PLA                    ; Restore the view type from the stack
 STA QQ11

.HFS1

 LDX #X                 ; Set K3 = #X (the x-coordinate of the centre of the
 STX K3                 ; screen)

 LDX #Y                 ; Set K4 = #Y (the y-coordinate of the centre of the
 STX K4                 ; screen)

 LDX #0                 ; Set X = 0

 STX XX4                ; Set XX4 = 0, which we will use as a counter for
                        ; drawing eight concentric rings

 STX K3+1               ; Set the high bytes of K3(1 0) and K4(1 0) to 0
 STX K4+1

.HFL5

 JSR HFL1               ; Call HFL1 below to draw a set of rings, with each one
                        ; twice the radius of the previous one, until they won't
                        ; fit on-screen

 INC XX4                ; Increment the counter and fetch it into X
 LDX XX4

 CPX #8                 ; If we haven't drawn 8 sets of rings yet, loop back to
 BNE HFL5               ; HFL5 to draw the next ring

 RTS                    ; Return from the subroutine

.HFL1

 LDA XX4                ; Set K to the ring number in XX4 (0-7) + 8, so K has
 AND #7                 ; a value of 8 to 15, which we will use as the starting
 CLC                    ; radius for our next set of rings
 ADC #8
 STA K

.HFL2

 LDY #10                ; ???
 JSR SOHISS

 LDA #1                 ; Set LSP = 1 to reset the ball line heap
 STA LSP

 JSR CIRCLE2            ; Call CIRCLE2 to draw a circle with the centre at
                        ; (K3(1 0), K4(1 0)) and radius K

 ASL K                  ; Double the radius in K

 BCS HF8                ; If the radius had a 1 in bit 7 before the above shift,
                        ; then doubling K will means the circle will no longer
                        ; fit on the screen (which is width 256), so jump to
                        ; HF8 to stop drawing circles

 LDA K                  ; If the radius in K <= 160, loop back to HFL2 to draw
 CMP #160               ; another one
 BCC HFL2

.HF8

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: STARS2
;       Type: Subroutine
;   Category: Stardust
;    Summary: Process the stardust for the left or right view
;  Deep dive: Stardust in the side views
;
; ------------------------------------------------------------------------------
;
; This moves the stardust sideways according to our speed and which side we are
; looking out of, and applies our current pitch and roll to each particle of
; dust, so the stardust moves correctly when we steer our ship.
;
; These are the calculations referred to in the commentary:
;
;   1. delta_x = 8 * 256 * speed / z_hi
;   2. x = x + delta_x
;
;   3. x = x + beta * y
;   4. y = y - beta * x
;
;   5. x = x - alpha * x * y
;   6. y = y + alpha * y * y + alpha
;
; For more information see the deep dive on "Stardust in the side views".
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The view to process:
;
;                         * X = 1 for left view
;
;                         * X = 2 for right view
;
; ******************************************************************************

.STARS2

 LDA #0                 ; Set A to 0 so we can use it to capture a sign bit

 CPX #2                 ; If X >= 2 then the C flag is set

 ROR A                  ; Roll the C flag into the sign bit of A and store in
 STA RAT                ; RAT, so:
                        ;
                        ;   * Left view, C is clear so RAT = 0 (positive)
                        ;
                        ;   * Right view, C is set so RAT = 128 (negative)
                        ;
                        ; RAT represents the end of the x-axis where we want new
                        ; stardust particles to come from: positive for the left
                        ; view where new particles come in from the right,
                        ; negative for the right view where new particles come
                        ; in from the left

 EOR #%10000000         ; Set RAT2 to the opposite sign, so:
 STA RAT2               ;
                        ;   * Left view, RAT2 = 128 (negative)
                        ;
                        ;   * Right view, RAT2 = 0 (positive)
                        ;
                        ; RAT2 represents the direction in which stardust
                        ; particles should move along the x-axis: negative for
                        ; the left view where particles go from right to left,
                        ; positive for the right view where particles go from
                        ; left to right

 JSR ST2                ; Call ST2 to flip the signs of the following if this is
                        ; the right view: ALPHA, ALP2, ALP2+1, BET2 and BET2+1

 LDY NOSTM              ; Set Y to the current number of stardust particles, so
                        ; we can use it as a counter through all the stardust

.STL2

 LDA SZ,Y               ; Set A = ZZ = z_hi

 STA ZZ                 ; We also set ZZ to the original value of z_hi, which we
                        ; use below to remove the existing particle

 LSR A                  ; Set A = z_hi / 8
 LSR A
 LSR A

 JSR DV41               ; Call DV41 to set the following:
                        ;
                        ;   (P R) = 256 * DELTA / A
                        ;         = 256 * speed / (z_hi / 8)
                        ;         = 8 * 256 * speed / z_hi
                        ;
                        ; This represents the distance we should move this
                        ; particle along the x-axis, let's call it delta_x

 LDA P                  ; Store the high byte of delta_x in newzp
 STA newzp

 EOR RAT2               ; Set S = P but with the sign from RAT2, so we now have
 STA S                  ; the distance delta_x with the correct sign in (S R):
                        ;
                        ;   (S R) = delta_x
                        ;         = 8 * 256 * speed / z_hi
                        ;
                        ; So (S R) is the delta, signed to match the direction
                        ; the stardust should move in, which is result 1 above

 LDA SXL,Y              ; Set (A P) = (x_hi x_lo)
 STA P                  ;           = x
 LDA SX,Y

 STA X1                 ; Set X1 = A, so X1 contains the original value of x_hi,
                        ; which we use below to remove the existing particle

 JSR ADD                ; Call ADD to calculate:
                        ;
                        ;   (A X) = (A P) + (S R)
                        ;         = x + delta_x

 STA S                  ; Set (S R) = (A X)
 STX R                  ;           = x + delta_x

 LDA SY,Y               ; Set A = y_hi

 STA Y1                 ; Set Y1 = A, so Y1 contains the original value of y_hi,
                        ; which we use below to remove the existing particle

 EOR BET2               ; Give A the correct sign of A * beta, i.e. y_hi * beta

 LDX BET1               ; Fetch |beta| from BET1, the pitch angle

 JSR MULTS-2            ; Call MULTS-2 to calculate:
                        ;
                        ;   (A P) = X * A
                        ;         = beta * y_hi

 JSR ADD                ; Call ADD to calculate:
                        ;
                        ;   (A X) = (A P) + (S R)
                        ;         = beta * y + x + delta_x

 STX XX                 ; Set XX(1 0) = (A X), which gives us results 2 and 3
 STA XX+1               ; above, done at the same time:
                        ;
                        ;   x = x + delta_x + beta * y

 LDX SYL,Y              ; Set (S R) = (y_hi y_lo)
 STX R                  ;           = y
 LDX Y1
 STX S

 LDX BET1               ; Fetch |beta| from BET1, the pitch angle

 EOR BET2+1             ; Give A the opposite sign to x * beta

 JSR MULTS-2            ; Call MULTS-2 to calculate:
                        ;
                        ;   (A P) = X * A
                        ;         = -beta * x

 JSR ADD                ; Call ADD to calculate:
                        ;
                        ;   (A X) = (A P) + (S R)
                        ;         = -beta * x + y

 STX YY                 ; Set YY(1 0) = (A X), which gives us result 4 above:
 STA YY+1               ;
                        ;   y = y - beta * x

 LDX ALP1               ; Set X = |alpha| from ALP2, the roll angle

 EOR ALP2               ; Give A the correct sign of A * alpha, i.e. y_hi *
                        ; alpha

 JSR MULTS-2            ; Call MULTS-2 to calculate:
                        ;
                        ;   (A P) = X * A
                        ;         = alpha * y

 STA Q                  ; Set Q = high byte of alpha * y

 LDA XX                 ; Set (S R) = XX(1 0)
 STA R                  ;           = x
 LDA XX+1               ;
 STA S                  ; and set A = y_hi at the same time

 EOR #%10000000         ; Flip the sign of A = -x_hi

 JSR MAD                ; Call MAD to calculate:
                        ;
                        ;   (A X) = Q * A + (S R)
                        ;         = alpha * y * -x + x

 STA XX+1               ; Store the high byte A in XX+1

 TXA                    ; Store the low byte X in x_lo
 STA SXL,Y

                        ; So (XX+1 x_lo) now contains result 5 above:
                        ;
                        ;   x = x - alpha * x * y

 LDA YY                 ; Set (S R) = YY(1 0)
 STA R                  ;           = y
 LDA YY+1               ;
 STA S                  ; and set A = y_hi at the same time

 JSR MAD                ; Call MAD to calculate:
                        ;
                        ;   (A X) = Q * A + (S R)
                        ;         = alpha * y * y_hi + y

 STA S                  ; Set (S R) = (A X)
 STX R                  ;           = y + alpha * y * y

 LDA #0                 ; Set P = 0
 STA P

 LDA ALPHA              ; Set A = alpha, so:
                        ;
                        ;   (A P) = (alpha 0)
                        ;         = alpha / 256

 JSR PIX1               ; Call PIX1 to calculate the following:
                        ;
                        ;   (YY+1 y_lo) = (A P) + (S R)
                        ;               = alpha * 256 + y + alpha * y * y
                        ;
                        ; i.e. y = y + alpha / 256 + alpha * y^2, which is
                        ; result 6 above
                        ;
                        ; PIX1 also draws a particle at (X1, Y1) with distance
                        ; ZZ, which will remove the old stardust particle, as we
                        ; set X1, Y1 and ZZ to the original values for this
                        ; particle during the calculations above

                        ; We now have our newly moved stardust particle at
                        ; x-coordinate (XX+1 x_lo) and y-coordinate (YY+1 y_lo)
                        ; and distance z_hi, so we draw it if it's still on
                        ; screen, otherwise we recycle it as a new bit of
                        ; stardust and draw that

 LDA XX+1               ; Set X1 and x_hi to the high byte of XX in XX+1, so
 STA SX,Y               ; the new x-coordinate is in (x_hi x_lo) and the high
 STA X1                 ; byte is in X1

 AND #%01111111         ; Set A = ~|x_hi|, which is the same as -(x_hi + 1)
 EOR #%01111111         ; using two's complement

 CMP newzp              ; If newzp <= -(x_hi + 1), then the particle has been
 BCC KILL2              ; moved off the side of the screen and has wrapped
 BEQ KILL2              ; round to the other side, jump to KILL2 to recycle this
                        ; particle and rejoin at STC2 with the new particle
                        ;
                        ; In the original BBC Micro versions, this test simply
                        ; checks whether |x_hi| >= 116, but this version using
                        ; newzp doesn't hard-code the screen width, so this is
                        ; presumably a change that was introduced to support
                        ; the different screen sizes of the other platforms

 LDA YY+1               ; Set Y1 and y_hi to the high byte of YY in YY+1, so
 STA SY,Y               ; the new x-coordinate is in (y_hi y_lo) and the high
 STA Y1                 ; byte is in Y1

 AND #%01111111         ; If |y_hi| >= 116 then jump to ST5 to recycle this
 CMP #116               ; particle, as it's gone off the top or bottom of the
 BCS ST5                ; screen, and rejoin at STC2 with the new particle

.STC2

 JSR PIXEL2             ; Draw a stardust particle at (X1,Y1) with distance ZZ,
                        ; i.e. draw the newly moved particle at (x_hi, y_hi)
                        ; with distance z_hi

 DEY                    ; Decrement the loop counter to point to the next
                        ; stardust particle

 BEQ ST2                ; If we have just done the last particle, skip the next
                        ; instruction to return from the subroutine

 JMP STL2               ; We have more stardust to process, so jump back up to
                        ; STL2 for the next particle

                        ; Fall through into ST2 to restore the signs of the
                        ; following if this is the right view: ALPHA, ALP2,
                        ; ALP2+1, BET2 and BET2+1

.ST2

 LDA ALPHA              ; If this is the right view, flip the sign of ALPHA
 EOR RAT
 STA ALPHA

 LDA ALP2               ; If this is the right view, flip the sign of ALP2
 EOR RAT
 STA ALP2

 EOR #%10000000         ; If this is the right view, flip the sign of ALP2+1
 STA ALP2+1

 LDA BET2               ; If this is the right view, flip the sign of BET2
 EOR RAT
 STA BET2

 EOR #%10000000         ; If this is the right view, flip the sign of BET2+1
 STA BET2+1

 RTS                    ; Return from the subroutine

.KILL2

 JSR DORND              ; Set A and X to random numbers

 STA Y1                 ; Set y_hi and Y1 to random numbers, so the particle
 STA SY,Y               ; starts anywhere along the y-axis

 LDA #115               ; Make sure A is at least 115 and has the sign in RAT
 ORA RAT

 STA X1                 ; Set x_hi and X1 to A, so this particle starts on the
 STA SX,Y               ; correct edge of the screen for new particles

 BNE STF1               ; Jump down to STF1 to set the z-coordinate (this BNE is
                        ; effectively a JMP as A will never be zero)

.ST5

 JSR DORND              ; Set A and X to random numbers

 STA X1                 ; Set x_hi and X1 to random numbers, so the particle
 STA SX,Y               ; starts anywhere along the x-axis

 LDA #110               ; Make sure A is at least 110 and has the sign in AL2+1,
 ORA ALP2+1             ; the flipped sign of the roll angle alpha

 STA Y1                 ; Set y_hi and Y1 to A, so the particle starts at the
 STA SY,Y               ; top or bottom edge, depending on the current roll
                        ; angle alpha

.STF1

 JSR DORND              ; Set A and X to random numbers

 ORA #8                 ; Make sure A is at least 8 and store it in z_hi and
 STA ZZ                 ; ZZ, so the new particle starts at any distance from
 STA SZ,Y               ; us, but not too close

 BNE STC2               ; Jump up to STC2 to draw this new particle (this BNE is
                        ; effectively a JMP as A will never be zero)

; ******************************************************************************
;
;       Name: MU5
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Set K(3 2 1 0) = (A A A A) and clear the C flag
;
; ------------------------------------------------------------------------------
;
; In practice this is only called via a BEQ following an AND instruction, in
; which case A = 0, so this routine effectively does this:
;
;   K(3 2 1 0) = 0
;
; ******************************************************************************

.MU5

 STA K                  ; Set K(3 2 1 0) to (A A A A)
 STA K+1
 STA K+2
 STA K+3

 CLC                    ; Clear the C flag

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: MULT3
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate K(3 2 1 0) = (A P+1 P) * Q
;  Deep dive: Shift-and-add multiplication
;
; ------------------------------------------------------------------------------
;
; Calculate the following multiplication between a signed 24-bit number and a
; signed 8-bit number, returning the result as a signed 32-bit number:
;
;   K(3 2 1 0) = (A P+1 P) * Q
;
; The algorithm is the same shift-and-add algorithm as in routine MULT1, but
; extended to cope with more bits.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              The C flag is cleared
;
; ******************************************************************************

.MULT3

 STA R                  ; Store the high byte of (A P+1 P) in R

 AND #%01111111         ; Set K+2 to |A|, the high byte of K(2 1 0)
 STA K+2

 LDA Q                  ; Set A to bits 0-6 of Q, so A = |Q|
 AND #%01111111

 BEQ MU5                ; If |Q| = 0, jump to MU5 to set K(3 2 1 0) to 0,
                        ; returning from the subroutine using a tail call

 SEC                    ; Set T = |Q| - 1
 SBC #1
 STA T

                        ; We now use the same shift-and-add algorithm as MULT1
                        ; to calculate the following:
                        ;
                        ; K(2 1 0) = K(2 1 0) * |Q|
                        ;
                        ; so we start with the first shift right, in which we
                        ; take (K+2 P+1 P) and shift it right, storing the
                        ; result in K(2 1 0), ready for the multiplication loop
                        ; (so the multiplication loop actually calculates
                        ; (|A| P+1 P) * |Q|, as the following sets K(2 1 0) to
                        ; (|A| P+1 P) shifted right)

 LDA P+1                ; Set A = P+1

 LSR K+2                ; Shift the high byte in K+2 to the right

 ROR A                  ; Shift the middle byte in A to the right and store in
 STA K+1                ; K+1 (so K+1 contains P+1 shifted right)

 LDA P                  ; Shift the middle byte in P to the right and store in
 ROR A                  ; K, so K(2 1 0) now contains (|A| P+1 P) shifted right
 STA K

                        ; We now use the same shift-and-add algorithm as MULT1
                        ; to calculate the following:
                        ;
                        ; K(2 1 0) = K(2 1 0) * |Q|

 LDA #0                 ; Set A = 0 so we can start building the answer in A

 LDX #24                ; Set up a counter in X to count the 24 bits in K(2 1 0)

.MUL2

 BCC P%+4               ; If C (i.e. the next bit from K) is set, do the
 ADC T                  ; addition for this bit of K:
                        ;
                        ;   A = A + T + C
                        ;     = A + |Q| - 1 + 1
                        ;     = A + |Q|

 ROR A                  ; Shift A right by one place to catch the next digit
 ROR K+2                ; next digit of our result in the left end of K(2 1 0),
 ROR K+1                ; while also shifting K(2 1 0) right to fetch the next
 ROR K                  ; bit for the calculation into the C flag
                        ;
                        ; On the last iteration of this loop, the bit falling
                        ; off the end of K will be bit 0 of the original A, as
                        ; we did one shift before the loop and we are doing 24
                        ; iterations. We set A to 0 before looping, so this
                        ; means the loop exits with the C flag clear

 DEX                    ; Decrement the loop counter

 BNE MUL2               ; Loop back for the next bit until K(2 1 0) has been
                        ; rotated all the way

                        ; The result (|A| P+1 P) * |Q| is now in (A K+2 K+1 K),
                        ; but it is positive and doesn't have the correct sign
                        ; of the final result yet

 STA T                  ; Save the high byte of the result into T

 LDA R                  ; Fetch the sign byte from the original (A P+1 P)
                        ; argument that we stored in R

 EOR Q                  ; EOR with Q so the sign bit is the same as that of
                        ; (A P+1 P) * Q

 AND #%10000000         ; Extract the sign bit

 ORA T                  ; Apply this to the high byte of the result in T, so
                        ; that A now has the correct sign for the result, and
                        ; (A K+2 K+1 K) therefore contains the correctly signed
                        ; result

 STA K+3                ; Store A in K+3, so K(3 2 1 0) now contains the result

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: MLS2
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (S R) = XX(1 0) and (A P) = A * ALP1
;
; ------------------------------------------------------------------------------
;
; Calculate the following:
;
;   (S R) = XX(1 0)
;
;   (A P) = A * ALP1
;
; where ALP1 is the magnitude of the current roll angle alpha, in the range
; 0-31.
;
; ******************************************************************************

.MLS2

 LDX XX                 ; Set (S R) = XX(1 0), starting with the low bytes
 STX R

 LDX XX+1               ; And then doing the high bytes
 STX S

                        ; Fall through into MLS1 to calculate (A P) = A * ALP1

; ******************************************************************************
;
;       Name: MLS1
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A P) = ALP1 * A
;
; ------------------------------------------------------------------------------
;
; Calculate the following:
;
;   (A P) = ALP1 * A
;
; where ALP1 is the magnitude of the current roll angle alpha, in the range
; 0-31.
;
; This routine uses an unrolled version of MU11. MU11 calculates P * X, so we
; use the same algorithm but with P set to ALP1 and X set to A. The unrolled
; version here can skip the bit tests for bits 5-7 of P as we know P < 32, so
; only 5 shifts with bit tests are needed (for bits 0-4), while the other 3
; shifts can be done without a test (for bits 5-7).
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   MULTS-2             Calculate (A P) = X * A
;
; ******************************************************************************

.MLS1

 LDX ALP1               ; Set P to the roll angle alpha magnitude in ALP1
 STX P                  ; (0-31), so now we calculate P * A

.MULTS

 TAX                    ; Set X = A, so now we can calculate P * X instead of
                        ; P * A to get our result, and we can use the algorithm
                        ; from MU11 to do that, just unrolled (as MU11 returns
                        ; P * X)

 AND #%10000000         ; Set T to the sign bit of A
 STA T

 TXA                    ; Set A = |A|
 AND #127

 BEQ MU6                ; If A = 0, jump to MU6 to set P(1 0) = 0 and return
                        ; from the subroutine using a tail call

 TAX                    ; Set T1 = X - 1
 DEX                    ;
 STX T1                 ; We subtract 1 as the C flag will be set when we want
                        ; to do an addition in the loop below

 LDA #0                 ; Set A = 0 so we can start building the answer in A

 LSR P                  ; Set P = P >> 1
                        ; and C flag = bit 0 of P

                        ; We are now going to work our way through the bits of
                        ; P, and do a shift-add for any bits that are set,
                        ; keeping the running total in A, but instead of using a
                        ; loop like MU11, we just unroll it, starting with bit 0

 BCC P%+4               ; If C (i.e. the next bit from P) is set, do the
 ADC T1                 ; addition for this bit of P:
                        ;
                        ;   A = A + T1 + C
                        ;     = A + X - 1 + 1
                        ;     = A + X

 ROR A                  ; Shift A right to catch the next digit of our result,
                        ; which the next ROR sticks into the left end of P while
                        ; also extracting the next bit of P

 ROR P                  ; Add the overspill from shifting A to the right onto
                        ; the start of P, and shift P right to fetch the next
                        ; bit for the calculation into the C flag

 BCC P%+4               ; Repeat the shift-and-add loop for bit 1
 ADC T1
 ROR A
 ROR P

 BCC P%+4               ; Repeat the shift-and-add loop for bit 2
 ADC T1
 ROR A
 ROR P

 BCC P%+4               ; Repeat the shift-and-add loop for bit 3
 ADC T1
 ROR A
 ROR P

 BCC P%+4               ; Repeat the shift-and-add loop for bit 4
 ADC T1
 ROR A
 ROR P

 LSR A                  ; Just do the "shift" part for bit 5
 ROR P

 LSR A                  ; Just do the "shift" part for bit 6
 ROR P

 LSR A                  ; Just do the "shift" part for bit 7
 ROR P

 ORA T                  ; Give A the sign bit of the original argument A that
                        ; we put into T above

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: MU6
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Set P(1 0) = (A A)
;
; ------------------------------------------------------------------------------
;
; In practice this is only called via a BEQ following an AND instruction, in
; which case A = 0, so this routine effectively does this:
;
;   P(1 0) = 0
;
; ******************************************************************************

.MU6

 STA P+1                ; Set P(1 0) = (A A)
 STA P

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: SQUA
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Clear bit 7 of A and calculate (A P) = A * A
;
; ------------------------------------------------------------------------------
;
; Do the following multiplication of unsigned 8-bit numbers, after first
; clearing bit 7 of A:
;
;   (A P) = A * A
;
; ******************************************************************************

.SQUA

 AND #%01111111         ; Clear bit 7 of A and fall through into SQUA2 to set
                        ; (A P) = A * A

; ******************************************************************************
;
;       Name: SQUA2
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A P) = A * A
;
; ------------------------------------------------------------------------------
;
; Do the following multiplication of unsigned 8-bit numbers:
;
;   (A P) = A * A
;
; ******************************************************************************

.SQUA2

 STA P                  ; Copy A into P and X
 TAX

 BNE MU11               ; If X = 0 fall through into MU1 to return a 0,
                        ; otherwise jump to MU11 to return P * X

; ******************************************************************************
;
;       Name: MU1
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Copy X into P and A, and clear the C flag
;
; ------------------------------------------------------------------------------
;
; Used to return a 0 result quickly from MULTU below.
;
; ******************************************************************************

.MU1

 CLC                    ; Clear the C flag

 STX P                  ; Copy X into P and A
 TXA

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: MLU1
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate Y1 = y_hi and (A P) = |y_hi| * Q for Y-th stardust
;
; ------------------------------------------------------------------------------
;
; Do the following assignment, and multiply the Y-th stardust particle's
; y-coordinate with an unsigned number Q:
;
;   Y1 = y_hi
;
;   (A P) = |y_hi| * Q
;
; ******************************************************************************

.MLU1

 LDA SY,Y               ; Set Y1 the Y-th byte of SY
 STA Y1

                        ; Fall through into MLU2 to calculate:
                        ;
                        ;   (A P) = |A| * Q

; ******************************************************************************
;
;       Name: MLU2
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A P) = |A| * Q
;
; ------------------------------------------------------------------------------
;
; Do the following multiplication of a sign-magnitude 8-bit number P with an
; unsigned number Q:
;
;   (A P) = |A| * Q
;
; ******************************************************************************

.MLU2

 AND #%01111111         ; Clear the sign bit in P, so P = |A|
 STA P

                        ; Fall through into MULTU to calculate:
                        ;
                        ;   (A P) = P * Q
                        ;         = |A| * Q

; ******************************************************************************
;
;       Name: MULTU
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A P) = P * Q
;
; ------------------------------------------------------------------------------
;
; Do the following multiplication of unsigned 8-bit numbers:
;
;   (A P) = P * Q
;
; ******************************************************************************

.MULTU

 LDX Q                  ; Set X = Q

 BEQ MU1                ; If X = Q = 0, jump to MU1 to copy X into P and A,
                        ; clear the C flag and return from the subroutine using
                        ; a tail call

                        ; Otherwise fall through into MU11 to set (A P) = P * X

; ******************************************************************************
;
;       Name: MU11
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A P) = P * X
;  Deep dive: Shift-and-add multiplication
;
; ------------------------------------------------------------------------------
;
; Do the following multiplication of two unsigned 8-bit numbers:
;
;   (A P) = P * X
;
; This uses the same shift-and-add approach as MULT1, but it's simpler as we
; are dealing with unsigned numbers in P and X. See the deep dive on
; "Shift-and-add multiplication" for a discussion of how this algorithm works.
;
; ******************************************************************************

.MU11

 DEX                    ; Set T = X - 1
 STX T                  ;
                        ; We subtract 1 as the C flag will be set when we want
                        ; to do an addition in the loop below

 LDA #0                 ; Set A = 0 so we can start building the answer in A

;LDX #8                 ; This instruction is commented out in the original
                        ; source

 TAX                    ; Copy A into X. There is a comment in the original
                        ; source here that says "just in case", which refers to
                        ; the MU11 routine in the cassette and disc versions,
                        ; which set X to 0 (as they use X as a loop counter).
                        ; The version here doesn't use a loop, but this
                        ; instruction makes sure the unrolled version returns
                        ; the same results as the loop versions, just in case
                        ; something out there relies on MU11 returning X = 0

 LSR P                  ; Set P = P >> 1
                        ; and C flag = bit 0 of P

                        ; We now repeat the following four instruction block
                        ; eight times, one for each bit in P. In the cassette
                        ; and disc versions of Elite the following is done with
                        ; a loop, but it is marginally faster to unroll the loop
                        ; and have eight copies of the code, though it does take
                        ; up a bit more memory (though that isn't a concern when
                        ; you have a 6502 Second Processor)

 BCC P%+4               ; If C (i.e. bit 0 of P) is set, do the
 ADC T                  ; addition for this bit of P:
                        ;
                        ;   A = A + T + C
                        ;     = A + X - 1 + 1
                        ;     = A + X

 ROR A                  ; Shift A right to catch the next digit of our result,
                        ; which the next ROR sticks into the left end of P while
                        ; also extracting the next bit of P

 ROR P                  ; Add the overspill from shifting A to the right onto
                        ; the start of P, and shift P right to fetch the next
                        ; bit for the calculation into the C flag

 BCC P%+4               ; Repeat for the second time
 ADC T
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the third time
 ADC T
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the fourth time
 ADC T
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the fifth time
 ADC T
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the sixth time
 ADC T
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the seventh time
 ADC T
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the eighth time
 ADC T
 ROR A
 ROR P

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: FMLTU2
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate A = K * sin(A)
;  Deep dive: The sine, cosine and arctan tables
;
; ------------------------------------------------------------------------------
;
; Calculate the following:
;
;   A = K * sin(A)
;
; Because this routine uses the sine lookup table SNE, we can also call this
; routine to calculate cosine multiplication. To calculate the following:
;
;   A = K * cos(B)
;
; call this routine with B + 16 in the accumulator, as sin(B + 16) = cos(B).
;
; ******************************************************************************

.FMLTU2

 AND #%00011111         ; Restrict A to bits 0-5 (so it's in the range 0-31)

 TAX                    ; Set Q = sin(A) * 256
 LDA SNE,X
 STA Q

 LDA K                  ; Set A to the radius in K

                        ; Fall through into FMLTU to do the following:
                        ;
                        ;   (A ?) = A * Q
                        ;         = K * sin(A) * 256
                        ;
                        ; which is equivalent to:
                        ;
                        ;   A = K * sin(A)

; ******************************************************************************
;
;       Name: FMLTU
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate A = A * Q / 256
;  Deep dive: Multiplication and division using logarithms
;
; ------------------------------------------------------------------------------
;
; Do the following multiplication of two unsigned 8-bit numbers, returning only
; the high byte of the result:
;
;   (A ?) = A * Q
;
; or, to put it another way:
;
;   A = A * Q / 256
;
; The advanced versions of Elite use logarithms to speed up the multiplication
; process. See the deep dive on "Multiplication using logarithms" for more
; details.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              The C flag is clear if A = 0, or set if we return a
;                       result from one of the log tables
;
; ******************************************************************************

.FMLTU

 STX P                  ; Store X in P so we can preserve it through the call to
                        ; FMULTU

 STA widget             ; Store A in widget, so now widget = argument A

 TAX                    ; Transfer A into X, so now X = argument A

 BEQ MU3                ; If A = 0, jump to MU3 to return a result of 0, as
                        ; 0 * Q / 256 is always 0

                        ; We now want to calculate La + Lq, first adding the low
                        ; bytes (from the logL table), and then the high bytes
                        ; (from the log table)

 LDA logL,X             ; Set A = low byte of La
                        ;       = low byte of La (as we set X to A above)

 LDX Q                  ; Set X = Q

 BEQ MU3again           ; If X = 0, jump to MU3again to return a result of 0, as
                        ; A * 0 / 256 is always 0

 CLC                    ; Set A = A + low byte of Lq
 ADC logL,X             ;       = low byte of La + low byte of Lq

 LDA log,X              ; Set A = high byte of Lq

 LDX widget             ; Set A = A + C + high byte of La
 ADC log,X              ;       = high byte of Lq + high byte of La + C
                        ;
                        ; so we now have:
                        ;
                        ;   A = high byte of (La + Lq)

 BCC MU3again           ; If the addition fitted into one byte and didn't carry,
                        ; then La + Lq < 256, so we jump to MU3again to return a
                        ; result of 0 and the C flag clear

                        ; If we get here then the C flag is set, ready for when
                        ; we return from the subroutine below

 TAX                    ; Otherwise La + Lq >= 256, so we return the A-th entry
 LDA alogh,X            ; from the antilog table

 LDX P                  ; Restore X from P so it is preserved

 RTS                    ; Return from the subroutine

.MU3again

 LDA #0                 ; Set A = 0

.MU3

                        ; If we get here then A (our result) is already 0

 LDX P                  ; Restore X from P so it is preserved

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: MLTU2
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A P+1 P) = (A ~P) * Q
;  Deep dive: Shift-and-add multiplication
;
; ------------------------------------------------------------------------------
;
; Do the following multiplication of an unsigned 16-bit number and an unsigned
; 8-bit number:
;
;   (A P+1 P) = (A ~P) * Q
;
; where ~P means P EOR %11111111 (i.e. P with all its bits flipped). In other
; words, if you wanted to calculate $1234 * $56, you would:
;
;   * Set A to $12
;   * Set P to $34 EOR %11111111 = $CB
;   * Set Q to $56
;
; before calling MLTU2.
;
; This routine is like a mash-up of MU11 and FMLTU. It uses part of FMLTU's
; inverted argument trick to work out whether or not to do an addition, and like
; MU11 it sets up a counter in X to extract bits from (P+1 P). But this time we
; extract 16 bits from (P+1 P), so the result is a 24-bit number. The core of
; the algorithm is still the shift-and-add approach explained in MULT1, just
; with more bits.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   Q                   Q is preserved
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   MLTU2-2             Set Q to X, so this calculates (A P+1 P) = (A ~P) * X
;
; ******************************************************************************

 STX Q                  ; Store X in Q

.MLTU2

 EOR #%11111111         ; Flip the bits in A and rotate right, storing the
 LSR A                  ; result in P+1, so we now calculate (P+1 P) * Q
 STA P+1

 LDA #0                 ; Set A = 0 so we can start building the answer in A

 LDX #16                ; Set up a counter in X to count the 16 bits in (P+1 P)

 ROR P                  ; Set P = P >> 1 with bit 7 = bit 0 of A
                        ; and C flag = bit 0 of P

.MUL7

 BCS MU21               ; If C (i.e. the next bit from P) is set, do not do the
                        ; addition for this bit of P, and instead skip to MU21
                        ; to just do the shifts

 ADC Q                  ; Do the addition for this bit of P:
                        ;
                        ;   A = A + Q + C
                        ;     = A + Q

 ROR A                  ; Rotate (A P+1 P) to the right, so we capture the next
 ROR P+1                ; digit of the result in P+1, and extract the next digit
 ROR P                  ; of (P+1 P) in the C flag

 DEX                    ; Decrement the loop counter

 BNE MUL7               ; Loop back for the next bit until P has been rotated
                        ; all the way

 RTS                    ; Return from the subroutine

.MU21

 LSR A                  ; Shift (A P+1 P) to the right, so we capture the next
 ROR P+1                ; digit of the result in P+1, and extract the next digit
 ROR P                  ; of (P+1 P) in the C flag

 DEX                    ; Decrement the loop counter

 BNE MUL7               ; Loop back for the next bit until P has been rotated
                        ; all the way

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: MUT3
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: An unused routine that does the same as MUT2
;
; ------------------------------------------------------------------------------
;
; This routine is never actually called, but it is identical to MUT2, as the
; extra instructions have no effect.
;
; ******************************************************************************

.MUT3

 LDX ALP1               ; Set P = ALP1, though this gets overwritten by the
 STX P                  ; following, so this has no effect

                        ; Fall through into MUT2 to do the following:
                        ;
                        ;   (S R) = XX(1 0)
                        ;   (A P) = Q * A

; ******************************************************************************
;
;       Name: MUT2
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (S R) = XX(1 0) and (A P) = Q * A
;
; ------------------------------------------------------------------------------
;
; Do the following assignment, and multiplication of two signed 8-bit numbers:
;
;   (S R) = XX(1 0)
;   (A P) = Q * A
;
; ******************************************************************************

.MUT2

 LDX XX+1               ; Set S = XX+1
 STX S

                        ; Fall through into MUT1 to do the following:
                        ;
                        ;   R = XX
                        ;   (A P) = Q * A

; ******************************************************************************
;
;       Name: MUT1
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate R = XX and (A P) = Q * A
;
; ------------------------------------------------------------------------------
;
; Do the following assignment, and multiplication of two signed 8-bit numbers:
;
;   R = XX
;   (A P) = Q * A
;
; ******************************************************************************

.MUT1

 LDX XX                 ; Set R = XX
 STX R

                        ; Fall through into MULT1 to do the following:
                        ;
                        ;   (A P) = Q * A

; ******************************************************************************
;
;       Name: MULT1
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A P) = Q * A
;  Deep dive: Shift-and-add multiplication
;
; ------------------------------------------------------------------------------
;
; Do the following multiplication of two 8-bit sign-magnitude numbers:
;
;   (A P) = Q * A
;
; ******************************************************************************

.MULT1

 TAX                    ; Store A in X

 AND #%01111111         ; Set P = |A| >> 1
 LSR A                  ; and C flag = bit 0 of A
 STA P

 TXA                    ; Restore argument A

 EOR Q                  ; Set bit 7 of A and T if Q and A have different signs,
 AND #%10000000         ; clear bit 7 if they have the same signs, 0 all other
 STA T                  ; bits, i.e. T contains the sign bit of Q * A

 LDA Q                  ; Set A = |Q|
 AND #%01111111

 BEQ mu10               ; If |Q| = 0 jump to mu10 (with A set to 0)

 TAX                    ; Set T1 = |Q| - 1
 DEX                    ;
 STX T1                 ; We subtract 1 as the C flag will be set when we want
                        ; to do an addition in the loop below

                        ; We are now going to work our way through the bits of
                        ; P, and do a shift-add for any bits that are set,
                        ; keeping the running total in A. We already set up
                        ; the first shift at the start of this routine, as
                        ; P = |A| >> 1 and C = bit 0 of A, so we now need to set
                        ; up a loop to sift through the other 7 bits in P

 LDA #0                 ; Set A = 0 so we can start building the answer in A

 TAX                    ; Copy A into X. There is a comment in the original
                        ; source here that says "just in case", which refers to
                        ; the MULT1 routine in the cassette and disc versions,
                        ; which set X to 0 (as they use X as a loop counter).
                        ; The version here doesn't use a loop, but this
                        ; instruction makes sure the unrolled version returns
                        ; the same results as the loop versions, just in case
                        ; something out there relies on MULT1 returning X = 0

;.MUL4                  ; These instructions are commented out in the original
;                       ; source. They contain the original loop version of the
;BCC P%+4               ; code that's used in the disc and cassette versions
;ADC T1
;ROR A
;ROR P
;DEX
;BNE MUL4
;LSR A
;ROR P
;ORA T
;RTS
;
;.mu10
;STA P
;RTS

                        ; We now repeat the following four instruction block
                        ; seven times, one for each remaining bit in P. In the
                        ; cassette and disc versions of Elite the following is
                        ; done with a loop, but it is marginally faster to
                        ; unroll the loop and have seven copies of the code,
                        ; though it does take up a bit more memory

 BCC P%+4               ; If C (i.e. the next bit from P) is set, do the
 ADC T1                 ; addition for this bit of P:
                        ;
                        ;   A = A + T1 + C
                        ;     = A + |Q| - 1 + 1
                        ;     = A + |Q|

 ROR A                  ; As mentioned above, this ROR shifts A right and
                        ; catches bit 0 in C - giving another digit for our
                        ; result - and the next ROR sticks that bit into the
                        ; left end of P while also extracting the next bit of P
                        ; for the next addition

 ROR P                  ; Add the overspill from shifting A to the right onto
                        ; the start of P, and shift P right to fetch the next
                        ; bit for the calculation

 BCC P%+4               ; Repeat for the second time
 ADC T1
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the third time
 ADC T1
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the fourth time
 ADC T1
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the fifth time
 ADC T1
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the sixth time
 ADC T1
 ROR A
 ROR P

 BCC P%+4               ; Repeat for the seventh time
 ADC T1
 ROR A
 ROR P

 LSR A                  ; Rotate (A P) once more to get the final result, as
 ROR P                  ; we only pushed 7 bits through the above process

 ORA T                  ; Set the sign bit of the result that we stored in T

 RTS                    ; Return from the subroutine

.mu10

 STA P                  ; If we get here, the result is 0 and A = 0, so set
                        ; P = 0 so (A P) = 0

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: MULT12
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (S R) = Q * A
;
; ------------------------------------------------------------------------------
;
; Calculate:
;
;   (S R) = Q * A
;
; ******************************************************************************

.MULT12

 JSR MULT1              ; Set (A P) = Q * A

 STA S                  ; Set (S R) = (A P)
 LDA P                  ;           = Q * A
 STA R

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TAS3
;       Type: Subroutine
;   Category: Maths (Geometry)
;    Summary: Calculate the dot product of XX15 and an orientation vector
;
; ------------------------------------------------------------------------------
;
; Calculate the dot product of the vector in XX15 and one of the orientation
; vectors, as determined by the value of Y. If vect is the orientation vector,
; we calculate this:
;
;   (A X) = vect . XX15
;         = vect_x * XX15 + vect_y * XX15+1 + vect_z * XX15+2
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   Y                   The orientation vector:
;
;                         * If Y = 10, calculate nosev . XX15
;
;                         * If Y = 16, calculate roofv . XX15
;
;                         * If Y = 22, calculate sidev . XX15
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   (A X)               The result of the dot product
;
; ******************************************************************************

.TAS3

 LDX INWK,Y             ; Set Q = the Y-th byte of INWK, i.e. vect_x
 STX Q

 LDA XX15               ; Set A = XX15

 JSR MULT12             ; Set (S R) = Q * A
                        ;           = vect_x * XX15

 LDX INWK+2,Y           ; Set Q = the Y+2-th byte of INWK, i.e. vect_y
 STX Q

 LDA XX15+1             ; Set A = XX15+1

 JSR MAD                ; Set (A X) = Q * A + (S R)
                        ;           = vect_y * XX15+1 + vect_x * XX15

 STA S                  ; Set (S R) = (A X)
 STX R

 LDX INWK+4,Y           ; Set Q = the Y+2-th byte of INWK, i.e. vect_z
 STX Q

 LDA XX15+2             ; Set A = XX15+2

                        ; Fall through into MAD to set:
                        ;
                        ;   (A X) = Q * A + (S R)
                        ;           = vect_z * XX15+2 + vect_y * XX15+1 +
                        ;             vect_x * XX15

; ******************************************************************************
;
;       Name: MAD
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A X) = Q * A + (S R)
;
; ------------------------------------------------------------------------------
;
; Calculate
;
;   (A X) = Q * A + (S R)
;
; ******************************************************************************

.MAD

 JSR MULT1              ; Call MULT1 to set (A P) = Q * A

                        ; Fall through into ADD to do:
                        ;
                        ;   (A X) = (A P) + (S R)
                        ;         = Q * A + (S R)

; ******************************************************************************
;
;       Name: ADD
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A X) = (A P) + (S R)
;  Deep dive: Adding sign-magnitude numbers
;
; ------------------------------------------------------------------------------
;
; Add two 16-bit sign-magnitude numbers together, calculating:
;
;   (A X) = (A P) + (S R)
;
; ******************************************************************************

.ADD

 STA T1                 ; Store argument A in T1

 AND #%10000000         ; Extract the sign (bit 7) of A and store it in T
 STA T

 EOR S                  ; EOR bit 7 of A with S. If they have different bit 7s
 BMI MU8                ; (i.e. they have different signs) then bit 7 in the
                        ; EOR result will be 1, which means the EOR result is
                        ; negative. So the AND, EOR and BMI together mean "jump
                        ; to MU8 if A and S have different signs"

                        ; If we reach here, then A and S have the same sign, so
                        ; we can add them and set the sign to get the result

 LDA R                  ; Add the least significant bytes together into X:
 CLC                    ;
 ADC P                  ;   X = P + R
 TAX

 LDA S                  ; Add the most significant bytes together into A. We
 ADC T1                 ; stored the original argument A in T1 earlier, so we
                        ; can do this with:
                        ;
                        ;   A = A  + S + C
                        ;     = T1 + S + C

 ORA T                  ; If argument A was negative (and therefore S was also
                        ; negative) then make sure result A is negative by
                        ; OR'ing the result with the sign bit from argument A
                        ; (which we stored in T)

 RTS                    ; Return from the subroutine

.MU8

                        ; If we reach here, then A and S have different signs,
                        ; so we can subtract their absolute values and set the
                        ; sign to get the result

 LDA S                  ; Clear the sign (bit 7) in S and store the result in
 AND #%01111111         ; U, so U now contains |S|
 STA U

 LDA P                  ; Subtract the least significant bytes into X:
 SEC                    ;
 SBC R                  ;   X = P - R
 TAX

 LDA T1                 ; Restore the A of the argument (A P) from T1 and
 AND #%01111111         ; clear the sign (bit 7), so A now contains |A|

 SBC U                  ; Set A = |A| - |S|

                        ; At this point we have |A P| - |S R| in (A X), so we
                        ; need to check whether the subtraction above was the
                        ; right way round (i.e. that we subtracted the smaller
                        ; absolute value from the larger absolute value)

 BCS MU9                ; If |A| >= |S|, our subtraction was the right way
                        ; round, so jump to MU9 to set the sign

                        ; If we get here, then |A| < |S|, so our subtraction
                        ; above was the wrong way round (we actually subtracted
                        ; the larger absolute value from the smaller absolute
                        ; value). So let's subtract the result we have in (A X)
                        ; from zero, so that the subtraction is the right way
                        ; round

 STA U                  ; Store A in U

 TXA                    ; Set X = 0 - X using two's complement (to negate a
 EOR #$FF               ; number in two's complement, you can invert the bits
 ADC #1                 ; and add one - and we know the C flag is clear as we
 TAX                    ; didn't take the BCS branch above, so the ADC will do
                        ; the correct addition)

 LDA #0                 ; Set A = 0 - A, which we can do this time using a
 SBC U                  ; subtraction with the C flag clear

 ORA #%10000000         ; We now set the sign bit of A, so that the EOR on the
                        ; next line will give the result the opposite sign to
                        ; argument A (as T contains the sign bit of argument
                        ; A). This is the same as giving the result the same
                        ; sign as argument S (as A and S have different signs),
                        ; which is what we want, as S has the larger absolute
                        ; value

.MU9

 EOR T                  ; If we get here from the BCS above, then |A| >= |S|,
                        ; so we want to give the result the same sign as
                        ; argument A, so if argument A was negative, we flip
                        ; the sign of the result with an EOR (to make it
                        ; negative)

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TIS1
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (A ?) = (-X * A + (S R)) / 96
;  Deep dive: Shift-and-subtract division
;
; ------------------------------------------------------------------------------
;
; Calculate the following expression between sign-magnitude numbers, ignoring
; the low byte of the result:
;
;   (A ?) = (-X * A + (S R)) / 96
;
; This uses the same shift-and-subtract algorithm as TIS2, just with the
; quotient A hard-coded to 96.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   Q                   Gets set to the value of argument X
;
; ******************************************************************************

.TIS1

 STX Q                  ; Set Q = X

 EOR #%10000000         ; Flip the sign bit in A

 JSR MAD                ; Set (A X) = Q * A + (S R)
                        ;           = X * -A + (S R)

.DVID96

 TAX                    ; Set T to the sign bit of the result
 AND #%10000000
 STA T

 TXA                    ; Set A to the high byte of the result with the sign bit
 AND #%01111111         ; cleared, so (A ?) = |X * A + (S R)|

                        ; The following is identical to TIS2, except Q is
                        ; hard-coded to 96, so this does A = A / 96

 LDX #254               ; Set T1 to have bits 1-7 set, so we can rotate through
 STX T1                 ; 7 loop iterations, getting a 1 each time, and then
                        ; getting a 0 on the 8th iteration... and we can also
                        ; use T1 to catch our result bits into bit 0 each time

.DVL3

 ASL A                  ; Shift A to the left

 CMP #96                ; If A < 96 skip the following subtraction
 BCC DV4

 SBC #96                ; Set A = A - 96
                        ;
                        ; Going into this subtraction we know the C flag is
                        ; set as we passed through the BCC above, and we also
                        ; know that A >= 96, so the C flag will still be set
                        ; once we are done

.DV4

 ROL T1                 ; Rotate the counter in T1 to the left, and catch the
                        ; result bit into bit 0 (which will be a 0 if we didn't
                        ; do the subtraction, or 1 if we did)

 BCS DVL3               ; If we still have set bits in T1, loop back to DVL3 to
                        ; do the next iteration of 7

 LDA T1                 ; Fetch the result from T1 into A

 ORA T                  ; Give A the sign of the result that we stored above

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: DV42
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (P R) = 256 * DELTA / z_hi
;
; ------------------------------------------------------------------------------
;
; Calculate the following division and remainder:
;
;   P = DELTA / (the Y-th stardust particle's z_hi coordinate)
;
;   R = remainder as a fraction of A, where 1.0 = 255
;
; Another way of saying the above is this:
;
;   (P R) = 256 * DELTA / z_hi
;
; DELTA is a value between 1 and 40, and the minimum z_hi is 16 (dust particles
; are removed at lower values than this), so this means P is between 0 and 2
; (as 40 / 16 = 2.5, so the maximum result is P = 2 and R = 128.
;
; This uses the same shift-and-subtract algorithm as TIS2, but this time we
; keep the remainder.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   Y                   The number of the stardust particle to process
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              The C flag is cleared
;
; ******************************************************************************

.DV42

 LDA SZ,Y               ; Fetch the Y-th dust particle's z_hi coordinate into A

                        ; Fall through into DV41 to do:
                        ;
                        ;   (P R) = 256 * DELTA / A
                        ;         = 256 * DELTA / Y-th stardust particle's z_hi

; ******************************************************************************
;
;       Name: DV41
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (P R) = 256 * DELTA / A
;
; ------------------------------------------------------------------------------
;
; Calculate the following division and remainder:
;
;   P = DELTA / A
;
;   R = remainder as a fraction of A, where 1.0 = 255
;
; Another way of saying the above is this:
;
;   (P R) = 256 * DELTA / A
;
; This uses the same shift-and-subtract algorithm as TIS2, but this time we
; keep the remainder.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              The C flag is cleared
;
; ******************************************************************************

.DV41

 STA Q                  ; Store A in Q

 LDA DELTA              ; Fetch the speed from DELTA into A

                        ; Fall through into DVID4 to do:
                        ;
                        ;   (P R) = 256 * A / Q
                        ;         = 256 * DELTA / A

; ******************************************************************************
;
;       Name: DVID4
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (P R) = 256 * A / Q
;  Deep dive: Shift-and-subtract division
;
; ------------------------------------------------------------------------------
;
; Calculate the following division and remainder:
;
;   P = A / Q
;
;   R = remainder as a fraction of Q, where 1.0 = 255
;
; Another way of saying the above is this:
;
;   (P R) = 256 * A / Q
;
; This uses the same shift-and-subtract algorithm as TIS2, but this time we
; keep the remainder and the loop is unrolled.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              The C flag is cleared
;
; ******************************************************************************

.DVID4

;LDX #8                 ; This instruction is commented out in the original
                        ; source

 ASL A                  ; Shift A left and store in P (we will build the result
 STA P                  ; in P)

 LDA #0                 ; Set A = 0 for us to build a remainder

;.DVL4                  ; This label is commented out in the original source

                        ; We now repeat the following five instruction block
                        ; eight times, one for each bit in P. In the cassette
                        ; and disc versions of Elite the following is done with
                        ; a loop, but it is marginally faster to unroll the loop
                        ; and have eight copies of the code, though it does take
                        ; up a bit more memory (though that isn't a concern when
                        ; you have a 6502 Second Processor)

 ROL A                  ; Shift A to the left

 CMP Q                  ; If A < Q skip the following subtraction
 BCC P%+4

 SBC Q                  ; A >= Q, so set A = A - Q

 ROL P                  ; Shift P to the left, pulling the C flag into bit 0

 ROL A                  ; Repeat for the second time
 CMP Q
 BCC P%+4
 SBC Q
 ROL P

 ROL A                  ; Repeat for the third time
 CMP Q
 BCC P%+4
 SBC Q
 ROL P

 ROL A                  ; Repeat for the fourth time
 CMP Q
 BCC P%+4
 SBC Q
 ROL P

 ROL A                  ; Repeat for the fifth time
 CMP Q
 BCC P%+4
 SBC Q
 ROL P

 ROL A                  ; Repeat for the sixth time
 CMP Q
 BCC P%+4
 SBC Q
 ROL P

 ROL A                  ; Repeat for the seventh time
 CMP Q
 BCC P%+4
 SBC Q
 ROL P

 ROL A                  ; Repeat for the eighth time
 CMP Q
 BCC P%+4
 SBC Q
 ROL P

 LDX #0                 ; Set X = 0 so this unrolled version of DVID4 also
                        ; returns X = 0

 STA widget             ; This contains the code from the LL28+4 routine, so
 TAX                    ; this section is exactly equivalent to a JMP LL28+4
 BEQ LLfix22            ; call, but is slightly faster as it's been inlined
 LDA logL,X             ; (so it converts the remainder in A into an integer
 LDX Q                  ; representation of the fractional value A / Q, in R,
 SEC                    ; where 1.0 = 255, and it also clears the C flag
 SBC logL,X
 LDX widget
 LDA log,X
 LDX Q
 SBC log,X
 BCS LL222
 TAX
 LDA alogh,X

.LLfix22

 STA R                  ; This is also part of the inline LL28+4 routine
 RTS

.LL222

 LDA #255               ; This is also part of the inline LL28+4 routine
 STA R
 RTS

; ******************************************************************************
;
;       Name: DVID3B2
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
;  Deep dive: Shift-and-subtract division
;
; ------------------------------------------------------------------------------
;
; Calculate the following:
;
;   K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
;
; The actual division here is done as an 8-bit calculation using LL31, but this
; routine shifts both the numerator (the top part of the division) and the
; denominator (the bottom part of the division) around to get the multi-byte
; result we want.
;
; Specifically, it shifts both of them to the left as far as possible, keeping a
; tally of how many shifts get done in each one - and specifically, the
; difference in the number of shifts between the top and bottom (as shifting
; both of them once in the same direction won't change the result). It then
; divides the two highest bytes with the simple 8-bit routine in LL31, and
; shifts the result by the difference in the number of shifts, which acts as a
; scale factor to get the correct result.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   K(3 2 1 0)          The result of the division
;
;   X                   X is preserved
;
; ******************************************************************************

.DVID3B2

 STA P+2                ; Set P+2 = A

 LDA INWK+6             ; Set Q = z_lo, making sure Q is at least 1
 ORA #1
 STA Q

 LDA INWK+7             ; Set R = z_hi
 STA R

 LDA INWK+8             ; Set S = z_sign
 STA S

.DVID3B

                        ; Given the above assignments, we now want to calculate
                        ; the following to get the result we want:
                        ;
                        ;   K(3 2 1 0) = P(2 1 0) / (S R Q)

 LDA P                  ; Make sure P(2 1 0) is at least 1
 ORA #1
 STA P

 LDA P+2                ; Set T to the sign of P+2 * S (i.e. the sign of the
 EOR S                  ; result) and store it in T
 AND #%10000000
 STA T

 LDY #0                 ; Set Y = 0 to store the scale factor

 LDA P+2                ; Clear the sign bit of P+2, so the division can be done
 AND #%01111111         ; with positive numbers and we'll set the correct sign
                        ; below, once all the maths is done
                        ;
                        ; This also leaves A = P+2, which we use below

.DVL9

                        ; We now shift (A P+1 P) left until A >= 64, counting
                        ; the number of shifts in Y. This makes the top part of
                        ; the division as large as possible, thus retaining as
                        ; much accuracy as we can.  When we come to return the
                        ; final result, we shift the result by the number of
                        ; places in Y, and in the correct direction

 CMP #64                ; If A >= 64, jump down to DV14
 BCS DV14

 ASL P                  ; Shift (A P+1 P) to the left
 ROL P+1
 ROL A

 INY                    ; Increment the scale factor in Y

 BNE DVL9               ; Loop up to DVL9 (this BNE is effectively a JMP, as Y
                        ; will never be zero)

.DV14

                        ; If we get here, A >= 64 and contains the highest byte
                        ; of the numerator, scaled up by the number of left
                        ; shifts in Y

 STA P+2                ; Store A in P+2, so we now have the scaled value of
                        ; the numerator in P(2 1 0)

 LDA S                  ; Set A = |S|
 AND #%01111111

;BMI DV9                ; This label is commented out in the original source

.DVL6

                        ; We now shift (S R Q) left until bit 7 of S is set,
                        ; reducing Y by the number of shifts. This makes the
                        ; bottom part of the division as large as possible, thus
                        ; retaining as much accuracy as we can. When we come to
                        ; return the final result, we shift the result by the
                        ; total number of places in Y, and in the correct
                        ; direction, to give us the correct result
                        ;
                        ; We set A to |S| above, so the following actually
                        ; shifts (A R Q)

 DEY                    ; Decrement the scale factor in Y

 ASL Q                  ; Shift (A R Q) to the left
 ROL R
 ROL A

 BPL DVL6               ; Loop up to DVL6 to do another shift, until bit 7 of A
                        ; is set and we can't shift left any further

.DV9

                        ; We have now shifted both the numerator and denominator
                        ; left as far as they will go, keeping a tally of the
                        ; overall scale factor of the various shifts in Y. We
                        ; can now divide just the two highest bytes to get our
                        ; result

 STA Q                  ; Set Q = A, the highest byte of the denominator

 LDA #254               ; Set R to have bits 1-7 set, so we can pass this to
 STA R                  ; LL31 to act as the bit counter in the division

 LDA P+2                ; Set A to the highest byte of the numerator

.LL31new

 ASL A                  ; This contains the code from the LL31 routine, so
 BCS LL29new            ; this section is exactly equivalent to a JSR LL31
 CMP Q                  ; call, but is slightly faster as it's been inlined,
 BCC P%+4               ; so it calculates:
 SBC Q                  ;
 ROL R                  ;   R = 256 * A / Q
 BCS LL31new            ;     = 256 * numerator / denominator
 JMP LL312new

.LL29new

 SBC Q                  ; This is also part of the inline LL31 routine
 SEC
 ROL R
 BCS LL31new
 LDA R

.LL312new

                        ; The result of our division is now in R, so we just
                        ; need to shift it back by the scale factor in Y

 LDA #0                 ; Set K(3 2 1) = 0 to hold the result (we populate K
 STA K+1                ; next)
 STA K+2
 STA K+3

 TYA                    ; If Y is positive, jump to DV12
 BPL DV12

                        ; If we get here then Y is negative, so we need to shift
                        ; the result R to the left by Y places, and then set the
                        ; correct sign for the result

 LDA R                  ; Set A = R

.DVL8

 ASL A                  ; Shift (K+3 K+2 K+1 A) left
 ROL K+1
 ROL K+2
 ROL K+3

 INY                    ; Increment the scale factor in Y

 BNE DVL8               ; Loop back to DVL8 until we have shifted left by Y
                        ; places

 STA K                  ; Store A in K so the result is now in K(3 2 1 0)

 LDA K+3                ; Set K+3 to the sign in T, which we set above to the
 ORA T                  ; correct sign for the result
 STA K+3

 RTS                    ; Return from the subroutine

.DV13

                        ; If we get here then Y is zero, so we don't need to
                        ; shift the result R, we just need to set the correct
                        ; sign for the result

 LDA R                  ; Store R in K so the result is now in K(3 2 1 0)
 STA K

 LDA T                  ; Set K+3 to the sign in T, which we set above to the
 STA K+3                ; correct sign for the result

 RTS                    ; Return from the subroutine

.DV12

 BEQ DV13               ; We jumped here having set A to the scale factor in Y,
                        ; so this jumps up to DV13 if Y = 0

                        ; If we get here then Y is positive and non-zero, so we
                        ; need to shift the result R to the right by Y places
                        ; and then set the correct sign for the result. We also
                        ; know that K(3 2 1) will stay 0, as we are shifting the
                        ; lowest byte to the right, so no set bits will make
                        ; their way into the top three bytes

 LDA R                  ; Set A = R

.DVL10

 LSR A                  ; Shift A right

 DEY                    ; Decrement the scale factor in Y

 BNE DVL10              ; Loop back to DVL10 until we have shifted right by Y
                        ; places

 STA K                  ; Store the shifted A in K so the result is now in
                        ; K(3 2 1 0)

 LDA T                  ; Set K+3 to the sign in T, which we set above to the
 STA K+3                ; correct sign for the result

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: cntr
;       Type: Subroutine
;   Category: Dashboard
;    Summary: Apply damping to the pitch or roll dashboard indicator
;
; ------------------------------------------------------------------------------
;
; Apply damping to the value in X, where X ranges from 1 to 255 with 128 as the
; centre point (so X represents a position on a centre-based dashboard slider,
; such as pitch or roll). If the value is in the left-hand side of the slider
; (1-127) then it bumps the value up by 1 so it moves towards the centre, and
; if it's in the right-hand side, it reduces it by 1, also moving it towards the
; centre.
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   RE1                 Contains an RTS
;
; ******************************************************************************

.cntr

 LDA auto               ; If the docking computer is currently activated, jump
 BNE cnt2               ; to cnt2 to skip the following as we always want to
                        ; enable damping for the docking computer

 LDA DAMP               ; If DAMP is non-zero, then keyboard damping is not
 BNE RE1                ; enabled, so jump to RE1 to return from the subroutine

.cnt2

 TXA                    ; If X < 128, then it's in the left-hand side of the
 BPL BUMP               ; dashboard slider, so jump to BUMP to bump it up by 1,
                        ; to move it closer to the centre

 DEX                    ; Otherwise X >= 128, so it's in the right-hand side
 BMI RE1                ; of the dashboard slider, so decrement X by 1, and if
                        ; it's still >= 128, jump to RE1 to return from the
                        ; subroutine, otherwise fall through to BUMP to undo
                        ; the bump and then return

.BUMP

 INX                    ; Bump X up by 1, and if it hasn't overshot the end of
 BNE RE1                ; the dashboard slider, jump to RE1 to return from the
                        ; subroutine, otherwise fall through to REDU to drop
                        ; it down by 1 again

.REDU

 DEX                    ; Reduce X by 1, and if we have reached 0 jump up to
 BEQ BUMP               ; BUMP to add 1, because we need the value to be in the
                        ; range 1 to 255

.RE1

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: BUMP2
;       Type: Subroutine
;   Category: Dashboard
;    Summary: Bump up the value of the pitch or roll dashboard indicator
;
; ------------------------------------------------------------------------------
;
; Increase ("bump up") X by A, where X is either the current rate of pitch or
; the current rate of roll.
;
; The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
; This is the amount by which the pitch or roll is currently changing, so 1
; means it is decreasing at the maximum rate, 128 means it is not changing,
; and 255 means it is increasing at the maximum rate. These values correspond
; to the line on the DC or RL indicators on the dashboard, with 1 meaning full
; left, 128 meaning the middle, and 255 meaning full right.
;
; If bumping up X would push it past 255, then X is set to 255.
;
; If keyboard auto-recentre is configured and the result is less than 128, we
; bump X up to the mid-point, 128. This is the equivalent of having a roll or
; pitch in the left half of the indicator, when increasing the roll or pitch
; should jump us straight to the mid-point.
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   RE2+2               Restore A from T and return from the subroutine
;
; ******************************************************************************

.BUMP2

 STA T                  ; Store argument A in T so we can restore it later

 TXA                    ; Copy argument X into A

 CLC                    ; Clear the C flag so we can do addition without the
                        ; C flag affecting the result

 ADC T                  ; Set X = A = argument X + argument A
 TAX

 BCC RE2                ; If the C flag is clear, then we didn't overflow, so
                        ; jump to RE2 to auto-recentre and return the result

 LDX #255               ; We have an overflow, so set X to the maximum possible
                        ; value of 255

.RE2

 BPL djd1               ; If X has bit 7 clear (i.e. the result < 128), then
                        ; jump to djd1 in routine REDU2 to do an auto-recentre,
                        ; if configured, because the result is on the left side
                        ; of the centre point of 128

                        ; Jumps to RE2+2 end up here

 LDA T                  ; Restore the original argument A from T into A

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: REDU2
;       Type: Subroutine
;   Category: Dashboard
;    Summary: Reduce the value of the pitch or roll dashboard indicator
;
; ------------------------------------------------------------------------------
;
; Reduce X by A, where X is either the current rate of pitch or the current
; rate of roll.
;
; The rate of pitch or roll ranges from 1 to 255 with 128 as the centre point.
; This is the amount by which the pitch or roll is currently changing, so 1
; means it is decreasing at the maximum rate, 128 means it is not changing,
; and 255 means it is increasing at the maximum rate. These values correspond
; to the line on the DC or RL indicators on the dashboard, with 1 meaning full
; left, 128 meaning the middle, and 255 meaning full right.
;
; If reducing X would bring it below 1, then X is set to 1.
;
; If keyboard auto-recentre is configured and the result is greater than 128, we
; reduce X down to the mid-point, 128. This is the equivalent of having a roll
; or pitch in the right half of the indicator, when decreasing the roll or pitch
; should jump us straight to the mid-point.
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   djd1                Auto-recentre the value in X, if keyboard auto-recentre
;                       is configured
;
; ******************************************************************************

.REDU2

 STA T                  ; Store argument A in T so we can restore it later

 TXA                    ; Copy argument X into A

 SEC                    ; Set the C flag so we can do subtraction without the
                        ; C flag affecting the result

 SBC T                  ; Set X = A = argument X - argument A
 TAX

 BCS RE3                ; If the C flag is set, then we didn't underflow, so
                        ; jump to RE3 to auto-recentre and return the result

 LDX #1                 ; We have an underflow, so set X to the minimum possible
                        ; value, 1

.RE3

 BPL RE2+2              ; If X has bit 7 clear (i.e. the result < 128), then
                        ; jump to RE2+2 above to return the result as is,
                        ; because the result is on the left side of the centre
                        ; point of 128, so we don't need to auto-centre

.djd1

                        ; If we get here, then we need to apply auto-recentre,
                        ; if it is configured

 LDA DJD                ; If keyboard auto-recentre is disabled, then
 BNE RE2+2              ; jump to RE2+2 to restore A and return

 LDX #128               ; If we get here then keyboard auto-recentre is enabled,
 BMI RE2+2              ; so set X to 128 (the middle of our range) and jump to
                        ; RE2+2 to restore A and return from the subroutine
                        ; (this BMI is effectively a JMP as bit 7 of X is always
                        ; set)

; ******************************************************************************
;
;       Name: LASLI
;       Type: Subroutine
;   Category: Drawing lines
;    Summary: Draw the laser lines for when we fire our lasers
;
; ------------------------------------------------------------------------------
;
; Draw the laser lines, aiming them to slightly different place each time so
; they appear to flicker and dance. Also heat up the laser temperature and drain
; some energy.
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   LASLI2              Just draw the current laser lines without moving the
;                       centre point, draining energy or heating up. This has
;                       the effect of removing the lines from the screen
;
;   LASLI-1             Contains an RTS
;
; ******************************************************************************

.LASLI

 JSR DORND              ; Set A and X to random numbers

 AND #7                 ; Restrict A to a random value in the range 0 to 7

 ADC #Y-4               ; Set LASY to four pixels above the centre of the
 STA LASY               ; screen (#Y), plus our random number, so the laser
                        ; dances above and below the centre point

 JSR DORND              ; Set A and X to random numbers

 AND #7                 ; Restrict A to a random value in the range 0 to 7

 ADC #X-4               ; Set LASX to four pixels left of the centre of the
 STA LASX               ; screen (#X), plus our random number, so the laser
                        ; dances to the left and right of the centre point

 LDA GNTMP              ; Add 8 to the laser temperature in GNTMP
 ADC #8
 STA GNTMP

 JSR DENGY              ; Call DENGY to deplete our energy banks by 1

.LASLI2

 LDA QQ11               ; If this is not a space view (i.e. QQ11 is non-zero)
 BNE RE1                ; then jump to MA9 to return from the main flight loop
                        ; (as RE1 is an RTS)

;LDA #RED               ; These instructions are commented out in the original
;STA COL                ; source; they would switch to colour 2, which is red in
                        ; the space view

 LDA #32                ; Set A = 32 and Y = 224 for the first set of laser
 LDY #224               ; lines (the wider pair of lines)

 JSR las                ; Call las below to draw the first set of laser lines

 LDA #48                ; Fall through into las with A = 48 and Y = 208 to draw
 LDY #208               ; a second set of lines (the narrower pair)

                        ; The following routine draws two laser lines, one from
                        ; the centre point down to point A on the bottom row,
                        ; and the other from the centre point down to point Y
                        ; on the bottom row. We therefore get lines from the
                        ; centre point to points 32, 48, 208 and 224 along the
                        ; bottom row, giving us the triangular laser effect
                        ; we're after

.las

 STA X2                 ; Set X2 = A

 LDA LASX               ; Set (X1, Y1) to the random centre point we set above
 STA X1
 LDA LASY
 STA Y1

 LDA #2*Y-1             ; Set Y2 = 2 * #Y - 1. The constant #Y is 96, the
 STA Y2                 ; y-coordinate of the mid-point of the space view, so
                        ; this sets Y2 to 191, the y-coordinate of the bottom
                        ; pixel row of the space view

 JSR LL30               ; Draw a line from (X1, Y1) to (X2, Y2), so that's from
                        ; the centre point to (A, 191)

 LDA LASX               ; Set (X1, Y1) to the random centre point we set above
 STA X1
 LDA LASY
 STA Y1

 STY X2                 ; Set X2 = Y

 LDA #2*Y-1             ; Set Y2 = 2 * #Y - 1, the y-coordinate of the bottom
 STA Y2                 ; pixel row of the space view (as before)

 JMP LL30               ; Draw a line from (X1, Y1) to (X2, Y2), so that's from
                        ; the centre point to (Y, 191), and return from
                        ; the subroutine using a tail call

; ******************************************************************************
;
;       Name: PDESC
;       Type: Subroutine
;   Category: Universe
;    Summary: Print the system's extended description or a mission 1 directive
;  Deep dive: Extended system descriptions
;             Extended text tokens
;
; ------------------------------------------------------------------------------
;
; This prints a specific system's extended description. This is called the "pink
; volcanoes string" in a comment in the original source, and the "goat soup"
; recipe by Ian Bell on his website (where he also refers to the species string
; as the "pink felines" string).
;
; For some special systems, when you are docked at them, the procedurally
; generated extended description is overridden and a text token from the RUTOK
; table is shown instead. If mission 1 is in progress, then a number of systems
; along the route of that mission's story will show custom mission-related
; directives in place of that system's normal "goat soup" phrase.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   ZZ                  The system number (0-255)
;
; ******************************************************************************

.PDESC

 LDA QQ8                ; If either byte in QQ18(1 0) is non-zero, meaning that
 ORA QQ8+1              ; the distance from the current system to the selected
 BNE PD1                ; is non-zero, jump to PD1 to show the standard "goat
                        ; soup" description

 LDA QQ12               ; If QQ12 does not have bit 7 set, which means we are
 BPL PD1                ; not docked, jump to PD1 to show the standard "goat
                        ; soup" description

                        ; If we get here, then the current system is the same as
                        ; the selected system and we are docked, so now to check
                        ; whether there is a special override token for this
                        ; system

 LDY #NRU%              ; Set Y as a loop counter as we work our way through the
                        ; system numbers in RUPLA, starting at NRU% (which is
                        ; the number of entries in RUPLA, 26) and working our
                        ; way down to 1

.PDL1

 LDA RUPLA-1,Y          ; Fetch the Y-th byte from RUPLA-1 into A (we use
                        ; RUPLA-1 because Y is looping from 26 to 1)

 CMP ZZ                 ; If A doesn't match the system whose description we
 BNE PD2                ; are printing (in ZZ), jump to PD2 to keep looping
                        ; through the system numbers in RUPLA

                        ; If we get here we have found a match for this system
                        ; number in RUPLA

 LDA RUGAL-1,Y          ; Fetch the Y-th byte from RUGAL-1 into A

 AND #%01111111         ; Extract bits 0-6 of A

 CMP GCNT               ; If the result does not equal the current galaxy
 BNE PD2                ; number, jump to PD2 to keep looping through the system
                        ; numbers in RUPLA

 LDA RUGAL-1,Y          ; Fetch the Y-th byte from RUGAL-1 into A, once again

 BMI PD3                ; If bit 7 is set, jump to PD3 to print the extended
                        ; token in A from the second table in RUTOK

 LDA TP                 ; Fetch bit 0 of TP into the C flag, and skip to PD1 if
 LSR A                  ; it is clear (i.e. if mission 1 is not in progress) to
 BCC PD1                ; print the "goat soup" extended description

                        ; If we get here then mission 1 is in progress, so we
                        ; print out the corresponding token from RUTOK

 JSR MT14               ; Call MT14 to switch to justified text

 LDA #1                 ; Set A = 1 so that extended token 1 (an empty string)
                        ; gets printed below instead of token 176, followed by
                        ; the Y-th token in RUTOK

 EQUB $2C               ; Skip the next instruction by turning it into
                        ; $2C $A9 $B0, or BIT $B0A9, which does nothing apart
                        ; from affect the flags

.PD3

 LDA #176               ; Print extended token 176 ("{lower case}{justify}
 JSR DETOK2             ; {single cap}")

 TYA                    ; Print the extended token in Y from the second table
 JSR DETOK3             ; in RUTOK

 LDA #177               ; Set A = 177 so when we jump to PD4 in the next
                        ; instruction, we print token 177 (".{cr}{left align}")

 BNE PD4                ; Jump to PD4 to print the extended token in A and
                        ; return from the subroutine using a tail call

.PD2

 DEY                    ; Decrement the byte counter in Y

 BNE PDL1               ; Loop back to check the next byte in RUPLA until we
                        ; either find a match for the system in ZZ, or we fall
                        ; through into the "goat soup" extended description
                        ; routine

.PD1

                        ; We now print the "goat soup" extended description

 LDX #3                 ; We now want to seed the random number generator with
                        ; the s1 and s2 16-bit seeds from the current system, so
                        ; we get the same extended description for each system
                        ; every time we call PDESC, so set a counter in X for
                        ; copying 4 bytes

{
.PDL1                   ; This label is a duplicate of the label above (which is
                        ; why we need to surround it with braces, as BeebAsm
                        ; doesn't allow us to redefine labels, unlike BBC BASIC)

 LDA QQ15+2,X           ; Copy QQ15+2 to QQ15+5 (s1 and s2) to RAND to RAND+3
 STA RAND,X

 DEX                    ; Decrement the loop counter

 BPL PDL1               ; Loop back to PDL1 until we have copied all

 LDA #5                 ; Set A = 5, so we print extended token 5 in the next
                        ; instruction ("{lower case}{justify}{single cap}[86-90]
                        ; IS [140-144].{cr}{left align}"
}

.PD4

 JMP DETOK              ; Print the extended token given in A, and return from
                        ; the subroutine using a tail call

; ******************************************************************************
;
;       Name: BRIEF2
;       Type: Subroutine
;   Category: Missions
;    Summary: Start mission 2
;  Deep dive: The Thargoid Plans mission
;
; ******************************************************************************

.BRIEF2

 LDA TP                 ; Set bit 2 of TP to indicate mission 2 is in progress
 ORA #%00000100         ; but plans have not yet been picked up
 STA TP

 LDA #11                ; Set A = 11 so the call to BRP prints extended token 11
                        ; (the initial contact at the start of mission 2, asking
                        ; us to head for Ceerdi for a mission briefing)

                        ; Fall through into BRP to print the extended token in A
                        ; and show the Status Mode screen

; ******************************************************************************
;
;       Name: BRP
;       Type: Subroutine
;   Category: Missions
;    Summary: Print an extended token and show the Status Mode screen
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   BAYSTEP             Go to the docking bay (i.e. show the Status Mode screen)
;
; ******************************************************************************

.BRP

 JSR DETOK              ; Print the extended token in A

.BAYSTEP

 JMP BAY                ; Jump to BAY to go to the docking bay (i.e. show the
                        ; Status Mode screen) and return from the subroutine
                        ; using a tail call

; ******************************************************************************
;
;       Name: BRIEF3
;       Type: Subroutine
;   Category: Missions
;    Summary: Receive the briefing and plans for mission 2
;  Deep dive: The Thargoid Plans mission
;
; ******************************************************************************

.BRIEF3

 LDA TP                 ; Set bits 1 and 3 of TP to indicate that mission 1 is
 AND #%11110000         ; complete, and mission 2 is in progress and the plans
 ORA #%00001010         ; have been picked up
 STA TP

 LDA #222               ; Set A = 222 so the call to BRP prints extended token
                        ; 222 (the briefing for mission 2 where we pick up the
                        ; plans we need to take to Birera)

 BNE BRP                ; Jump to BRP to print the extended token in A and show
                        ; the Status Mode screen), returning from the subroutine
                        ; using a tail call (this BNE is effectively a JMP as A
                        ; is never zero)

; ******************************************************************************
;
;       Name: DEBRIEF2
;       Type: Subroutine
;   Category: Missions
;    Summary: Finish mission 2
;  Deep dive: The Thargoid Plans mission
;
; ******************************************************************************

.DEBRIEF2

 LDA TP                 ; Set bit 2 of TP to indicate mission 2 is complete (so
 ORA #%00000100         ; both bits 2 and 3 are now set)
 STA TP

 LDA #2                 ; Set ENGY to 2 so our energy banks recharge at a faster
 STA ENGY               ; rate, as our mission reward is a special navy energy
                        ; unit that recharges at a rate of 3 units of energy on
                        ; each iteration of the main loop, compared to a rate of
                        ; 2 units of energy for the standard energy unit

 INC TALLY+1            ; Award 256 kill points for completing the mission

 LDA #223               ; Set A = 223 so the call to BRP prints extended token
                        ; 223 (the thank you message at the end of mission 2)

 BNE BRP                ; Jump to BRP to print the extended token in A and show
                        ; the Status Mode screen), returning from the subroutine
                        ; using a tail call (this BNE is effectively a JMP as A
                        ; is never zero)

; ******************************************************************************
;
;       Name: DEBRIEF
;       Type: Subroutine
;   Category: Missions
;    Summary: Finish mission 1
;  Deep dive: The Constrictor mission
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   BRPS                Print the extended token in A, show the Status Mode
;                       screen and return from the subroutine
;
; ******************************************************************************

.DEBRIEF

 LSR TP                 ; Clear bit 0 of TP to indicate that mission 1 is no
 ASL TP                 ; longer in progress, as we have completed it

;INC TALLY+1            ; This instruction is commented out in the original
                        ; source

 LDX #LO(50000)         ; Increase our cash reserves by the generous mission
 LDY #HI(50000)         ; reward of 5,000 CR
 JSR MCASH

 LDA #15                ; Set A = 15 so the call to BRP prints extended token 15
                        ; (the thank you message at the end of mission 1)

.BRPS

 BNE BRP                ; Jump to BRP to print the extended token in A and show
                        ; the Status Mode screen, returning from the subroutine
                        ; using a tail call (this BNE is effectively a JMP as A
                        ; is never zero)

; ******************************************************************************
;
;       Name: TBRIEF
;       Type: Subroutine
;   Category: Missions
;    Summary: Start mission 3
;  Deep dive: The Trumbles mission
;
; ******************************************************************************

;.TBRIEF                ; These instructions are commented out in the original
;LDA TP                 ; source
;ORA #$10
;STA TP
;LDA #199
;JSR DETOK
;JSR YESNO
;BCC BAYSTEP
;LDY #HI(50000)
;LDX #LO(50000)
;JSR LCASH
;INC TRIBBLE
;JMP BAY

; ******************************************************************************
;
;       Name: BRIEF
;       Type: Subroutine
;   Category: Missions
;    Summary: Start mission 1 and show the mission briefing
;  Deep dive: The Constrictor mission
;
; ------------------------------------------------------------------------------
;
; This routine does the following:
;
;   * Clear the screen
;   * Display "INCOMING MESSAGE" in the middle of the screen
;   * Wait for 2 seconds
;   * Clear the screen
;   * Show the Constrictor rolling and pitching in the middle of the screen
;   * Do this for 64 loop iterations
;   * Move the ship away from us and up until it's near the top of the screen
;   * Show the mission 1 briefing in extended token 10
;
; The mission briefing ends with a "{display ship, wait for key press}" token,
; which calls the PAUSE routine. This continues to display the rotating ship,
; waiting until a key is pressed, and then removes the ship from the screen.
;
; ******************************************************************************

.BRIEF

 LSR TP                 ; Set bit 0 of TP to indicate that mission 1 is now in
 SEC                    ; progress
 ROL TP

 JSR BRIS               ; Call BRIS to clear the screen, display "INCOMING
                        ; MESSAGE" and wait for 2 seconds

 JSR ZINF               ; Call ZINF to reset the INWK ship workspace

 LDA #CON               ; Set the ship type in TYPE to the Constrictor
 STA TYPE

 JSR NWSHP              ; Add a new Constrictor to the local bubble (in this
                        ; case, the briefing screen)

 LDA #1                 ; Set A = 1 to set as the text cursor column

IF _IB_DISK

 STA XC                 ; Move the text cursor to column 1

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 JSR DOXC               ; Move the text cursor to column 1

ENDIF

 STA INWK+7             ; Set z_hi = 1, the distance at which we show the
                        ; rotating ship

 LDA #13                ; Clear the top part of the screen, draw a white border,
 JSR TT66               ; and set the current view type in QQ11 to 13 (rotating
                        ; ship view)

 LDA #64                ; Set the main loop counter to 64, so the ship rotates
 STA MCNT               ; for 64 iterations through MVEIT

.BRL1

 LDX #%01111111         ; Set the ship's roll counter to a positive roll that
 STX INWK+29            ; doesn't dampen (a clockwise roll)

 STX INWK+30            ; Set the ship's pitch counter to a positive pitch that
                        ; doesn't dampen (a diving pitch)

 JSR LL9                ; Draw the ship on screen

 JSR MVEIT              ; Call MVEIT to rotate the ship in space

 DEC MCNT               ; Decrease the counter in MCNT

 BNE BRL1               ; Loop back to keep moving the ship until we have done
                        ; all 64 iterations

.BRL2

 LSR INWK               ; Halve x_lo so the Constrictor moves towards the centre

 INC INWK+6             ; Increment z_lo so the Constrictor moves away from us

 BEQ BR2                ; If z_lo = 0 (i.e. it just went past 255), jump to BR2
                        ; to show the briefing

 INC INWK+6             ; Increment z_lo so the Constrictor moves a bit further
                        ; away from us

 BEQ BR2                ; If z_lo = 0 (i.e. it just went past 255), jump out of
                        ; the loop to BR2 to stop moving the ship up the screen
                        ; and show the briefing

 LDX INWK+3             ; Set X = y_lo + 1
 INX

 CPX #conhieght         ; If X < conhieght then skip the next instruction
 BCC P%+4

 LDX #conhieght         ; X is bigger than conhieght, so set X = conhieght so
                        ; that X has a maximum value of conhieght

 STX INWK+3             ; Set y_lo = X
                        ;          = y_lo + 1
                        ;
                        ; so the ship moves up the screen (as space coordinates
                        ; have the y-axis going up)

 JSR LL9                ; Draw the ship on screen

 JSR MVEIT              ; Call MVEIT to move and rotate the ship in space

 DEC MCNT               ; Decrease the counter in MCNT

 JMP BRL2               ; Loop back to keep moving the ship up the screen and
                        ; away from us

.BR2

 INC INWK+7             ; Increment z_hi, to keep the ship at the same distance
                        ; as we just incremented z_lo past 255

 JSR PAS1               ; Call PAS1 to display the rotating ship at space
                        ; coordinates (0, 112, 256) and scan the keyboard,
                        ; returning the ASCII code of the key in X (or 0 for no
                        ; key press)

 LDA #10                ; Set A = 10 so the call to BRP prints extended token 10
                        ; (the briefing for mission 1 where we find out all
                        ; about the stolen Constrictor)

 BNE BRPS               ; Jump to BRP via BRPS to print the extended token in A
                        ; and show the Status Mode screen, returning from the
                        ; subroutine using a tail call (this BNE is effectively
                        ; a JMP as A is never zero)

; ******************************************************************************
;
;       Name: BRIS
;       Type: Subroutine
;   Category: Missions
;    Summary: Clear the screen, display "INCOMING MESSAGE" and wait for 2
;             seconds
;
; ******************************************************************************

.BRIS

 LDA #216               ; Print extended token 216 ("{clear screen}{tab 6}{move
 JSR DETOK              ; to row 10, white, lower case}{white}{all caps}INCOMING
                        ; MESSAGE"

 LDY #100               ; Delay for 100 vertical syncs (100/50 = 2 seconds) and
 JMP DELAY              ; return from the subroutine using a tail call

; ******************************************************************************
;
;       Name: PAUSE
;       Type: Subroutine
;   Category: Missions
;    Summary: Wait until a key is pressed for the Constrictor mission briefing
;
; ******************************************************************************

.PAUSE

 JSR PAUSE2             ; ???

; ******************************************************************************
;
;       Name: PAS1
;       Type: Subroutine
;   Category: Missions
;    Summary: Scan the keyboard for the Constrictor mission briefing
;
; ******************************************************************************

.PAS1

 LDA #1                 ; ???
 JMP TT66

; ******************************************************************************
;
;       Name: MT23
;       Type: Subroutine
;   Category: Text
;    Summary: Move to row 9 and switch to lower case
;             when printing extended tokens
;  Deep dive: Extended text tokens
;
; ******************************************************************************

.MT23

 LDA #9                 ; Set A = 9, so when we fall through into MT29, the
                        ; text cursor gets moved to row 9

 EQUB $2C               ; Skip the next instruction by turning it into
                        ; $2C $A9 $06, or BIT $06A9, which does nothing apart
                        ; from affect the flags

                        ; Fall through into MT29 to move to the row in A and
                        ; switch to lower case

; ******************************************************************************
;
;       Name: MT29
;       Type: Subroutine
;   Category: Text
;    Summary: Move to row 5 and switch to lower case when printing extended
;             tokens
;  Deep dive: Extended text tokens
;
; ******************************************************************************

.MT29

 LDA #5                 ; Move the text cursor to row 5
 STA YC

 JMP MT13               ; Jump to MT13 to set bit 7 of DTW6 and bit 5 of DTW1,
                        ; returning from the subroutine using a tail call

; ******************************************************************************
;
;       Name: PAUSE2
;       Type: Subroutine
;   Category: Keyboard
;    Summary: Wait until a key is pressed, ignoring any existing key press
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   X                   The ASCII code of the key that was pressed
;
; ******************************************************************************

.PAUSE2

 JSR RDKEY              ; Scan the keyboard for a key press and return the
                        ; ASCII code of the key pressed in X (or 0 for no key
                        ; press)

 BNE PAUSE2             ; If a key was already being held down when we entered
                        ; this routine, keep looping back up to PAUSE2, until
                        ; the key is released

 JSR RDKEY              ; Any pre-existing key press is now gone, so we can
                        ; start scanning the keyboard again, returning the
                        ; ASCII code of the key pressed in X (or 0 for no key
                        ; press)

 BEQ PAUSE2             ; Keep looping up to PAUSE2 until a key is pressed

.newyearseve

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: GINF
;       Type: Subroutine
;   Category: Universe
;    Summary: Fetch the address of a ship's data block into INF
;
; ------------------------------------------------------------------------------
;
; Get the address of the data block for ship slot X and store it in INF. This
; address is fetched from the UNIV table, which stores the addresses of the 13
; ship data blocks in workspace K%.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The ship slot number for which we want the data block
;                       address
;
; ******************************************************************************

.GINF

 TXA                    ; Set Y = X * 2
 ASL A
 TAY

 LDA UNIV,Y             ; Get the high byte of the address of the X-th ship
 STA INF                ; from UNIV and store it in INF

 LDA UNIV+1,Y           ; Get the low byte of the address of the X-th ship
 STA INF+1              ; from UNIV and store it in INF

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: ping
;       Type: Subroutine
;   Category: Universe
;    Summary: Set the selected system to the current system
;
; ******************************************************************************

.ping

 LDX #1                 ; We want to copy the X- and Y-coordinates of the
                        ; current system in (QQ0, QQ1) to the selected system's
                        ; coordinates in (QQ9, QQ10), so set up a counter to
                        ; copy two bytes

.pl1

 LDA QQ0,X              ; Load byte X from the current system in QQ0/QQ1

 STA QQ9,X              ; Store byte X in the selected system in QQ9/QQ10

 DEX                    ; Decrement the loop counter

 BPL pl1                ; Loop back for the next byte to copy

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: DELAY
;       Type: Subroutine
;   Category: Utility routines
;    Summary: Wait for a specified time, in 1/50s of a second
;
; ------------------------------------------------------------------------------
;
; Wait for the number of vertical syncs given in Y, so this effectively waits
; for Y/50 of a second (as the vertical sync occurs 50 times a second).
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   Y                   The number of vertical sync events to wait for
;
; ******************************************************************************

.DELAY

 JSR WSCAN              ; Call WSCAN to wait for the vertical sync, so the whole
                        ; screen gets drawn

 DEY                    ; Decrement the counter in Y

 BNE DELAY              ; If Y isn't yet at zero, jump back to DELAY to wait
                        ; for another vertical sync

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: MTIN
;       Type: Variable
;   Category: Text
;    Summary: Lookup table for random tokens in the extended token table (0-37)
;  Deep dive: Extended text tokens
;
; ------------------------------------------------------------------------------
;
; The ERND token type, which is part of the extended token system, takes an
; argument between 0 and 37, and returns a randomly chosen token in the range
; specified in this table. This is used to generate the extended description of
; each system.
;
; For example, the entry at position 13 in this table (counting from 0) is 66,
; so ERND 14 will expand into a random token in the range 66-70, i.e. one of
; "JUICE", "BRANDY", "WATER", "BREW" and "GARGLE BLASTERS".
;
; ******************************************************************************

.MTIN

 EQUB 16                ; Token  0: a random extended token between 16 and 20
 EQUB 21                ; Token  1: a random extended token between 21 and 25
 EQUB 26                ; Token  2: a random extended token between 26 and 30
 EQUB 31                ; Token  3: a random extended token between 31 and 35
 EQUB 155               ; Token  4: a random extended token between 155 and 159
 EQUB 160               ; Token  5: a random extended token between 160 and 164
 EQUB 46                ; Token  6: a random extended token between 46 and 50
 EQUB 165               ; Token  7: a random extended token between 165 and 169
 EQUB 36                ; Token  8: a random extended token between 36 and 40
 EQUB 41                ; Token  9: a random extended token between 41 and 45
 EQUB 61                ; Token 10: a random extended token between 61 and 65
 EQUB 51                ; Token 11: a random extended token between 51 and 55
 EQUB 56                ; Token 12: a random extended token between 56 and 60
 EQUB 170               ; Token 13: a random extended token between 170 and 174
 EQUB 66                ; Token 14: a random extended token between 66 and 70
 EQUB 71                ; Token 15: a random extended token between 71 and 75
 EQUB 76                ; Token 16: a random extended token between 76 and 80
 EQUB 81                ; Token 17: a random extended token between 81 and 85
 EQUB 86                ; Token 18: a random extended token between 86 and 90
 EQUB 140               ; Token 19: a random extended token between 140 and 144
 EQUB 96                ; Token 20: a random extended token between 96 and 100
 EQUB 101               ; Token 21: a random extended token between 101 and 105
 EQUB 135               ; Token 22: a random extended token between 135 and 139
 EQUB 130               ; Token 23: a random extended token between 130 and 134
 EQUB 91                ; Token 24: a random extended token between 91 and 95
 EQUB 106               ; Token 25: a random extended token between 106 and 110
 EQUB 180               ; Token 26: a random extended token between 180 and 184
 EQUB 185               ; Token 27: a random extended token between 185 and 189
 EQUB 190               ; Token 28: a random extended token between 190 and 194
 EQUB 225               ; Token 29: a random extended token between 225 and 229
 EQUB 230               ; Token 30: a random extended token between 230 and 234
 EQUB 235               ; Token 31: a random extended token between 235 and 239
 EQUB 240               ; Token 32: a random extended token between 240 and 244
 EQUB 245               ; Token 33: a random extended token between 245 and 249
 EQUB 250               ; Token 34: a random extended token between 250 and 254
 EQUB 115               ; Token 35: a random extended token between 115 and 119
 EQUB 120               ; Token 36: a random extended token between 120 and 124
 EQUB 125               ; Token 37: a random extended token between 125 and 129

; ******************************************************************************
;
; Save ELTC.bin
;
; ******************************************************************************

 PRINT "ELITE C"
 PRINT "Assembled at ", ~CODE_C%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_C%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_C%

 PRINT "S.ELTC ", ~CODE_C%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_C%
 SAVE "3-assembled-output/ELTC.bin", CODE_C%, P%, LOAD%

; ******************************************************************************
;
; ELITE D FILE
;
; Produces the binary file ELTD.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_D% = P%

 LOAD_D% = LOAD% + P% - CODE%

; ******************************************************************************
;
;       Name: SCALEY
;       Type: Subroutine
;   Category: Maths (Geometry)
;    Summary: Scale the y-coordinate in A
;
; ------------------------------------------------------------------------------
;
; This routine (and the related SCALEY2 and SCALEX routines) are called from
; various places in the code to scale the value in A. This code is different in
; the Apple II and BBC Master versions, and allows coordinates to be scaled
; correctly on different platforms.
;
; The original source contains the comment "SCALE Scans by 3/4 to fit in".
;
; ******************************************************************************

.SCALEY

 LSR A                  ; Halve the value in A

; ******************************************************************************
;
;       Name: SCALEY2
;       Type: Subroutine
;   Category: Maths (Geometry)
;    Summary: Scale the y-coordinate in A
;
; ------------------------------------------------------------------------------
;
; This routine (and the related SCALEY and SCALEX routines) are called from
; various places in the code to scale the value in A. This code is different in
; the Apple II and BBC Master versions, and allows coordinates to be scaled
; correctly on different platforms.
;
; ******************************************************************************

.SCALEY2

 STA T3                 ; ???
 LSR A
 LSR A
 SEC
 SBC T3
 EOR #$FF
 ADC #1

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: SCALEX
;       Type: Subroutine
;   Category: Maths (Geometry)
;    Summary: Scale the x-coordinate in A
;
; ------------------------------------------------------------------------------
;
; This routine (and the related SCALEY and SCALEY2 routines) are called from
; various places in the code to scale the value in A. This code is different in
; the Apple II and BBC Master versions, and allows coordinates to be scaled
; correctly on different platforms.
;
; ******************************************************************************

.SCALEX

 JSR SCALEY2            ; ???
 ADC #32

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: DVLOIN
;       Type: Subroutine
;   Category: Drawing lines
;    Summary: Draw a vertical line from (A, GCYT) to (A, GCYB)
;
; ******************************************************************************

.DVLOIN

 STA X1                 ; Draw a vertical line from (A, GCYT) to (A, GCYB)
 LDA #GCYT
 STA Y1
 LDA #GCYB
 STA Y2
 JMP VLOIN

; ******************************************************************************
;
;       Name: tnpr1
;       Type: Subroutine
;   Category: Market
;    Summary: Work out if we have space for one tonne of cargo
;
; ------------------------------------------------------------------------------
;
; Given a market item, work out whether there is room in the cargo hold for one
; tonne of this item.
;
; For standard tonne canisters, the limit is given by the type of cargo hold we
; have, with a standard cargo hold having a capacity of 20t and an extended
; cargo bay being 35t.
;
; For items measured in kg (gold, platinum), g (gem-stones) and alien items,
; the individual limit on each of these is 200 units.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The type of market item (see QQ23 for a list of market
;                       item numbers)
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   A                   A = 1
;
;   C flag              Returns the result:
;
;                         * Set if there is no room for this item
;
;                         * Clear if there is room for this item
;
; ******************************************************************************

.tnpr1

 STA QQ29               ; Store the type of market item in QQ29

 LDA #1                 ; Set the number of units of this market item to 1

                        ; Fall through into tnpr to work out whether there is
                        ; room in the cargo hold for A tonnes of the item of
                        ; type QQ29

; ******************************************************************************
;
;       Name: tnpr
;       Type: Subroutine
;   Category: Market
;    Summary: Work out if we have space for a specific amount of cargo
;
; ------------------------------------------------------------------------------
;
; Given a market item and an amount, work out whether there is room in the
; cargo hold for this item.
;
; For standard tonne canisters, the limit is given by the type of cargo hold we
; have, with a standard cargo hold having a capacity of 20t and an extended
; cargo bay being 35t.
;
; For items measured in kg (gold, platinum), g (gem-stones) and alien items,
; the individual limit on each of these is 200 units.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The number of units of this market item
;
;   QQ29                The type of market item (see QQ23 for a list of market
;                       item numbers)
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   A                   A is preserved
;
;   C flag              Returns the result:
;
;                         * Set if there is no room for this item
;
;                         * Clear if there is room for this item
;
; ******************************************************************************

.tnpr

 PHA                    ; Store A on the stack

 LDX #12                ; If QQ29 > 12 then jump to kg below, as this cargo
 CPX QQ29               ; type is gold, platinum, gem-stones or alien items,
 BCC kg                 ; and they have different cargo limits to the standard
                        ; tonne canisters

.Tml

                        ; Here we count the tonne canisters we have in the hold
                        ; and add to A to see if we have enough room for A more
                        ; tonnes of cargo, using X as the loop counter, starting
                        ; with X = 12

 ADC QQ20,X             ; Set A = A + the number of tonnes we have in the hold
                        ; of market item number X. Note that the first time we
                        ; go round this loop, the C flag is set (as we didn't
                        ; branch with the BCC above, so the effect of this loop
                        ; is to count the number of tonne canisters in the hold,
                        ; and add 1

 DEX                    ; Decrement the loop counter

 BPL Tml                ; Loop back to add in the next market item in the hold,
                        ; until we have added up all market items from 12
                        ; (minerals) down to 0 (food)

 ADC TRIBBLE+1          ; Add the high byte of the number of Trumbles in the
                        ; hold, as 256 Trumbles take up one tonne of cargo space

 CMP CRGO               ; If A < CRGO then the C flag will be clear (we have
                        ; room in the hold)
                        ;
                        ; If A >= CRGO then the C flag will be set (we do not
                        ; have room in the hold)
                        ;
                        ; This works because A contains the number of canisters
                        ; plus 1, while CRGO contains our cargo capacity plus 2,
                        ; so if we actually have "a" canisters and a capacity
                        ; of "c", then:
                        ;
                        ; A < CRGO means: a+1 <  c+2
                        ;                 a   <  c+1
                        ;                 a   <= c
                        ;
                        ; So this is why the value in CRGO is 2 higher than the
                        ; actual cargo bay size, i.e. it's 22 for the standard
                        ; 20-tonne bay, and 37 for the large 35-tonne bay

 PLA                    ; Restore A from the stack

 RTS                    ; Return from the subroutine

.kg

                        ; Here we count the number of items of this type that
                        ; we already have in the hold, and add to A to see if
                        ; we have enough room for A more units

 LDY QQ29               ; Set Y to the item number we want to add

 ADC QQ20,Y             ; Set A = A + the number of units of this item that we
                        ; already have in the hold

 CMP #200               ; Is the result greater than 200 (the limit on
                        ; individual stocks of gold, platinum, gem-stones and
                        ; alien items)?
                        ;
                        ; If so, this sets the C flag (no room)
                        ;
                        ; Otherwise it is clear (we have room)

 PLA                    ; Restore A from the stack

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: DOXC
;       Type: Subroutine
;   Category: Text
;    Summary: Move the text cursor to a specific column
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The text column
;
; ******************************************************************************

.DOXC

 STA XC                 ; Store the new text column in XC

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: DOYC
;       Type: Subroutine
;   Category: Text
;    Summary: Move the text cursor to a specific row
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The text row
;
; ******************************************************************************

.DOYC

 STA YC                 ; Store the new text row in YC

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: INCYC
;       Type: Subroutine
;   Category: Text
;    Summary: Move the text cursor to the next row
;
; ******************************************************************************

.INCYC

 INC YC                 ; Move the text cursor to the next row

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TRADEMODE
;       Type: Subroutine
;   Category: Drawing the screen
;    Summary: Clear the screen and set up a trading screen
;
; ------------------------------------------------------------------------------
;
; Clear the top part of the screen.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The type of the new current view (see QQ11 for a list of
;                       view types)
;
; ******************************************************************************

.TRADEMODE

 JSR TT66               ; Clear the top part of the screen, draw a white border,
                        ; and set the current view type in QQ11 to A

 JMP FLKB               ; Call FLKB to flush the keyboard buffer and return from
                        ; the subroutine using a tail call

 RTS                    ; Return from the subroutine (though this instruction
                        ; has no effect as we already returned using a tail
                        ; call)

; ******************************************************************************
;
;       Name: TT20
;       Type: Subroutine
;   Category: Universe
;    Summary: Twist the selected system's seeds four times
;  Deep dive: Twisting the system seeds
;             Galaxy and system seeds
;
; ------------------------------------------------------------------------------
;
; Twist the three 16-bit seeds in QQ15 (selected system) four times, to
; generate the next system.
;
; ******************************************************************************

.TT20

 JSR P%+3               ; This line calls the line below as a subroutine, which
                        ; does two twists before returning here, and then we
                        ; fall through to the line below for another two
                        ; twists, so the net effect of these two consecutive
                        ; JSR calls is four twists, not counting the ones
                        ; inside your head as you try to follow this process

 JSR P%+3               ; This line calls TT54 as a subroutine to do a twist,
                        ; and then falls through into TT54 to do another twist
                        ; before returning from the subroutine

; ******************************************************************************
;
;       Name: TT54
;       Type: Subroutine
;   Category: Universe
;    Summary: Twist the selected system's seeds
;  Deep dive: Twisting the system seeds
;             Galaxy and system seeds
;
; ------------------------------------------------------------------------------
;
; This routine twists the three 16-bit seeds in QQ15 once.
;
; If we start with seeds s0, s1 and s2 and we want to work out their new values
; after we perform a twist (let's call the new values s0´, s1´ and s2´), then:
;
;  s0´ = s1
;  s1´ = s2
;  s2´ = s0 + s1 + s2
;
; So given an existing set of seeds in s0, s1 and s2, we can get the new values
; s0´, s1´ and s2´ simply by doing the above sums. And if we want to do the
; above in-place without creating three new s´ variables, then we can do the
; following:
;
;  tmp = s0 + s1
;  s0 = s1
;  s1 = s2
;  s2 = tmp + s1
;
; So this is what we do in this routine, where each seed is a 16-bit number.
;
; ******************************************************************************

.TT54

 LDA QQ15               ; X = tmp_lo = s0_lo + s1_lo
 CLC
 ADC QQ15+2
 TAX

 LDA QQ15+1             ; Y = tmp_hi = s1_hi + s1_hi + C
 ADC QQ15+3
 TAY

 LDA QQ15+2             ; s0_lo = s1_lo
 STA QQ15

 LDA QQ15+3             ; s0_hi = s1_hi
 STA QQ15+1

 LDA QQ15+5             ; s1_hi = s2_hi
 STA QQ15+3

 LDA QQ15+4             ; s1_lo = s2_lo
 STA QQ15+2

 CLC                    ; s2_lo = X + s1_lo
 TXA
 ADC QQ15+2
 STA QQ15+4

 TYA                    ; s2_hi = Y + s1_hi + C
 ADC QQ15+3
 STA QQ15+5

 RTS                    ; The twist is complete so return from the subroutine

; ******************************************************************************
;
;       Name: TT146
;       Type: Subroutine
;   Category: Universe
;    Summary: Print the distance to the selected system in light years
;
; ------------------------------------------------------------------------------
;
; If it is non-zero, print the distance to the selected system in light years.
; If it is zero, just move the text cursor down a line.
;
; Specifically, if the distance in QQ8 is non-zero, print token 31 ("DISTANCE"),
; then a colon, then the distance to one decimal place, then token 35 ("LIGHT
; YEARS"). If the distance is zero, move the cursor down one line.
;
; ******************************************************************************

.TT146

 LDA QQ8                ; Take the two bytes of the 16-bit value in QQ8 and
 ORA QQ8+1              ; OR them together to check whether there are any
 BNE TT63               ; non-zero bits, and if so, jump to TT63 to print the
                        ; distance

 INC YC                 ; The distance is zero, so we just move the text cursor
 RTS                    ; in YC down by one line and return from the subroutine

.TT63

 LDA #191               ; Print recursive token 31 ("DISTANCE") followed by
 JSR TT68               ; a colon

 LDX QQ8                ; Load (Y X) from QQ8, which contains the 16-bit
 LDY QQ8+1              ; distance we want to show

 SEC                    ; Set the C flag so that the call to pr5 will include a
                        ; decimal point, and display the value as (Y X) / 10

 JSR pr5                ; Print (Y X) to 5 digits, including a decimal point

 LDA #195               ; Set A to the recursive token 35 (" LIGHT YEARS") and
                        ; fall through into TT60 to print the token followed
                        ; by a paragraph break

; ******************************************************************************
;
;       Name: TT60
;       Type: Subroutine
;   Category: Text
;    Summary: Print a text token and a paragraph break
;
; ------------------------------------------------------------------------------
;
; Print a text token (i.e. a character, control code, two-letter token or
; recursive token). Then print a paragraph break (a blank line between
; paragraphs) by moving the cursor down a line, setting Sentence Case, and then
; printing a newline.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The text token to be printed
;
; ******************************************************************************

.TT60

 JSR TT27               ; Print the text token in A and fall through into TTX69
                        ; to print the paragraph break

; ******************************************************************************
;
;       Name: TTX69
;       Type: Subroutine
;   Category: Text
;    Summary: Print a paragraph break
;
; ------------------------------------------------------------------------------
;
; Print a paragraph break (a blank line between paragraphs) by moving the cursor
; down a line, setting Sentence Case, and then printing a newline.
;
; ******************************************************************************

.TTX69

 INC YC                 ; Move the text cursor down a line

;JSR INCYC              ; This instruction is commented out in the original
;                       ; source

                        ; Fall through into TT69 to set Sentence Case and print
                        ; a newline

; ******************************************************************************
;
;       Name: TT69
;       Type: Subroutine
;   Category: Text
;    Summary: Set Sentence Case and print a newline
;
; ******************************************************************************

.TT69

 LDA #%10000000         ; Set bit 7 of QQ17 to switch to Sentence Case
 STA QQ17

                        ; Fall through into TT67 to print a newline

; ******************************************************************************
;
;       Name: TT67
;       Type: Subroutine
;   Category: Text
;    Summary: Print a newline
;
; ******************************************************************************

.TT67

;INC YC                 ; This instruction is commented out in the original
                        ; source

 LDA #12                ; Load a newline character into A

 JMP TT27               ; Print the text token in A and return from the
                        ; subroutine using a tail call

; ******************************************************************************
;
;       Name: TT70
;       Type: Subroutine
;   Category: Universe
;    Summary: Display "MAINLY " and jump to TT72
;
; ------------------------------------------------------------------------------
;
; This subroutine is called by TT25 when displaying a system's economy.
;
; ******************************************************************************

.TT70

 LDA #173               ; Print recursive token 13 ("MAINLY ")
 JSR TT27

 JMP TT72               ; Jump to TT72 to continue printing system data as part
                        ; of routine TT25

; ******************************************************************************
;
;       Name: spc
;       Type: Subroutine
;   Category: Text
;    Summary: Print a text token followed by a space
;
; ------------------------------------------------------------------------------
;
; Print a text token (i.e. a character, control code, two-letter token or
; recursive token) followed by a space.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The text token to be printed
;
; ******************************************************************************

.spc

 JSR TT27               ; Print the text token in A

 JMP TT162              ; Print a space and return from the subroutine using a
                        ; tail call

; ******************************************************************************
;
;       Name: TT25
;       Type: Subroutine
;   Category: Universe
;    Summary: Show the Data on System screen
;  Deep dive: Generating system data
;             Galaxy and system seeds
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   TT72                Used by TT70 to re-enter the routine after displaying
;                       "MAINLY" for the economy type
;
; ******************************************************************************

.TT25

 LDA #1                 ; Clear the top part of the screen, draw a white border,
 JSR TRADEMODE          ; and set up a printable trading screen with a view type
                        ; in QQ11 of 1

 LDA #9                 ; Move the text cursor to column 9
 JSR DOXC

 LDA #163               ; Print recursive token 3 ("DATA ON {selected system
 JSR NLIN3              ; name}" on the top row

 JSR TTX69              ; Print a paragraph break and set Sentence Case

 JSR TT146              ; If the distance to this system is non-zero, print
                        ; "DISTANCE", then the distance, "LIGHT YEARS" and a
                        ; paragraph break, otherwise just move the cursor down
                        ; a line

 LDA #194               ; Print recursive token 34 ("ECONOMY") followed by
 JSR TT68               ; a colon

 LDA QQ3                ; The system economy is determined by the value in QQ3,
                        ; so fetch it into A. First we work out the system's
                        ; prosperity as follows:
                        ;
                        ;   QQ3 = 0 or 5 = %000 or %101 = Rich
                        ;   QQ3 = 1 or 6 = %001 or %110 = Average
                        ;   QQ3 = 2 or 7 = %010 or %111 = Poor
                        ;   QQ3 = 3 or 4 = %011 or %100 = Mainly

 CLC                    ; If (QQ3 + 1) >> 1 = %10, i.e. if QQ3 = %011 or %100
 ADC #1                 ; (3 or 4), then call TT70, which prints "MAINLY " and
 LSR A                  ; jumps down to TT72 to print the type of economy
 CMP #%00000010
 BEQ TT70

 LDA QQ3                ; If (QQ3 + 1) >> 1 < %10, i.e. if QQ3 = %000, %001 or
 BCC TT71               ; %010 (0, 1 or 2), then jump to TT71 with A set to the
                        ; original value of QQ3

 SBC #5                 ; Here QQ3 = %101, %110 or %111 (5, 6 or 7), so subtract
 CLC                    ; 5 to bring it down to 0, 1 or 2 (the C flag is already
                        ; set so the SBC will be correct)

.TT71

 ADC #170               ; A is now 0, 1 or 2, so print recursive token 10 + A.
 JSR TT27               ; This means that:
                        ;
                        ;   QQ3 = 0 or 5 prints token 10 ("RICH ")
                        ;   QQ3 = 1 or 6 prints token 11 ("AVERAGE ")
                        ;   QQ3 = 2 or 7 prints token 12 ("POOR ")

.TT72

 LDA QQ3                ; Now to work out the type of economy, which is
 LSR A                  ; determined by bit 2 of QQ3, as follows:
 LSR A                  ;
                        ;   QQ3 bit 2 = 0 = Industrial
                        ;   QQ3 bit 2 = 1 = Agricultural
                        ;
                        ; So we fetch QQ3 into A and set A = bit 2 of QQ3 using
                        ; two right shifts (which will work as QQ3 is only a
                        ; 3-bit number)

 CLC                    ; Print recursive token 8 + A, followed by a paragraph
 ADC #168               ; break and Sentence Case, so:
 JSR TT60               ;
                        ;   QQ3 bit 2 = 0 prints token 8 ("INDUSTRIAL")
                        ;   QQ3 bit 2 = 1 prints token 9 ("AGRICULTURAL")

 LDA #162               ; Print recursive token 2 ("GOVERNMENT") followed by
 JSR TT68               ; a colon

 LDA QQ4                ; The system's government is determined by the value in
                        ; QQ4, so fetch it into A

 CLC                    ; Print recursive token 17 + A, followed by a paragraph
 ADC #177               ; break and Sentence Case, so:
 JSR TT60               ;
                        ;   QQ4 = 0 prints token 17 ("ANARCHY")
                        ;   QQ4 = 1 prints token 18 ("FEUDAL")
                        ;   QQ4 = 2 prints token 19 ("MULTI-GOVERNMENT")
                        ;   QQ4 = 3 prints token 20 ("DICTATORSHIP")
                        ;   QQ4 = 4 prints token 21 ("COMMUNIST")
                        ;   QQ4 = 5 prints token 22 ("CONFEDERACY")
                        ;   QQ4 = 6 prints token 23 ("DEMOCRACY")
                        ;   QQ4 = 7 prints token 24 ("CORPORATE STATE")

 LDA #196               ; Print recursive token 36 ("TECH.LEVEL") followed by a
 JSR TT68               ; colon

 LDX QQ5                ; Fetch the tech level from QQ5 and increment it, as it
 INX                    ; is stored in the range 0-14 but the displayed range
                        ; should be 1-15

 CLC                    ; Call pr2 to print the technology level as a 3-digit
 JSR pr2                ; number without a decimal point (by clearing the C
                        ; flag)

 JSR TTX69              ; Print a paragraph break and set Sentence Case

 LDA #192               ; Print recursive token 32 ("POPULATION") followed by a
 JSR TT68               ; colon

 SEC                    ; Call pr2 to print the population as a 3-digit number
 LDX QQ6                ; with a decimal point (by setting the C flag), so the
 JSR pr2                ; number printed will be population / 10

 LDA #198               ; Print recursive token 38 (" BILLION"), followed by a
 JSR TT60               ; paragraph break and Sentence Case

 LDA #'('               ; Print an opening bracket
 JSR TT27

 LDA QQ15+4             ; Now to calculate the species, so first check bit 7 of
 BMI TT75               ; s2_lo, and if it is set, jump to TT75 as this is an
                        ; alien species

 LDA #188               ; Bit 7 of s2_lo is clear, so print recursive token 28
 JSR TT27               ; ("HUMAN COLONIAL")

 JMP TT76               ; Jump to TT76 to print "S)" and a paragraph break, so
                        ; the whole species string is "(HUMAN COLONIALS)"

.TT75

 LDA QQ15+5             ; This is an alien species, and we start with the first
 LSR A                  ; adjective, so fetch bits 2-7 of s2_hi into A and push
 LSR A                  ; onto the stack so we can use this later
 PHA

 AND #%00000111         ; Set A = bits 0-2 of A (so that's bits 2-4 of s2_hi)

 CMP #3                 ; If A >= 3, jump to TT205 to skip the first adjective,
 BCS TT205

 ADC #227               ; Otherwise A = 0, 1 or 2, so print recursive token
 JSR spc                ; 67 + A, followed by a space, so:
                        ;
                        ;   A = 0 prints token 67 ("LARGE") and a space
                        ;   A = 1 prints token 68 ("FIERCE") and a space
                        ;   A = 2 prints token 69 ("SMALL") and a space

.TT205

 PLA                    ; Now for the second adjective, so restore A to bits
 LSR A                  ; 2-7 of s2_hi, and throw away bits 2-4 to leave
 LSR A                  ; A = bits 5-7 of s2_hi
 LSR A

 CMP #6                 ; If A >= 6, jump to TT206 to skip the second adjective
 BCS TT206

 ADC #230               ; Otherwise A = 0 to 5, so print recursive token
 JSR spc                ; 70 + A, followed by a space, so:
                        ;
                        ;   A = 0 prints token 70 ("GREEN") and a space
                        ;   A = 1 prints token 71 ("RED") and a space
                        ;   A = 2 prints token 72 ("YELLOW") and a space
                        ;   A = 3 prints token 73 ("BLUE") and a space
                        ;   A = 4 prints token 74 ("BLACK") and a space
                        ;   A = 5 prints token 75 ("HARMLESS") and a space

.TT206

 LDA QQ15+3             ; Now for the third adjective, so EOR the high bytes of
 EOR QQ15+1             ; s0 and s1 and extract bits 0-2 of the result:
 AND #%00000111         ;
 STA QQ19               ;   A = (s0_hi EOR s1_hi) AND %111
                        ;
                        ; storing the result in QQ19 so we can use it later

 CMP #6                 ; If A >= 6, jump to TT207 to skip the third adjective
 BCS TT207

 ADC #236               ; Otherwise A = 0 to 5, so print recursive token
 JSR spc                ; 76 + A, followed by a space, so:
                        ;
                        ;   A = 0 prints token 76 ("SLIMY") and a space
                        ;   A = 1 prints token 77 ("BUG-EYED") and a space
                        ;   A = 2 prints token 78 ("HORNED") and a space
                        ;   A = 3 prints token 79 ("BONY") and a space
                        ;   A = 4 prints token 80 ("FAT") and a space
                        ;   A = 5 prints token 81 ("FURRY") and a space

.TT207

 LDA QQ15+5             ; Now for the actual species, so take bits 0-1 of
 AND #%00000011         ; s2_hi, add this to the value of A that we used for
 CLC                    ; the third adjective, and take bits 0-2 of the result
 ADC QQ19
 AND #%00000111

 ADC #242               ; A = 0 to 7, so print recursive token 82 + A, so:
 JSR TT27               ;
                        ;   A = 0 prints token 82 ("RODENT")
                        ;   A = 1 prints token 83 ("FROG")
                        ;   A = 2 prints token 84 ("LIZARD")
                        ;   A = 3 prints token 85 ("LOBSTER")
                        ;   A = 4 prints token 86 ("BIRD")
                        ;   A = 5 prints token 87 ("HUMANOID")
                        ;   A = 6 prints token 88 ("FELINE")
                        ;   A = 7 prints token 89 ("INSECT")

.TT76

 LDA #'S'               ; Print an "S" to pluralise the species
 JSR TT27

 LDA #')'               ; And finally, print a closing bracket, followed by a
 JSR TT60               ; paragraph break and Sentence Case, to end the species
                        ; section

 LDA #193               ; Print recursive token 33 ("GROSS PRODUCTIVITY"),
 JSR TT68               ; followed by a colon

 LDX QQ7                ; Fetch the 16-bit productivity value from QQ7 into
 LDY QQ7+1              ; (Y X)

 JSR pr6                ; Print (Y X) to 5 digits with no decimal point

 JSR TT162              ; Print a space

 LDA #0                 ; Set QQ17 = 0 to switch to ALL CAPS
 STA QQ17

 LDA #'M'               ; Print "M"
 JSR TT27

 LDA #226               ; Print recursive token 66 (" CR"), followed by a
 JSR TT60               ; paragraph break and Sentence Case

 LDA #250               ; Print recursive token 90 ("AVERAGE RADIUS"), followed
 JSR TT68               ; by a colon

                        ; The average radius is calculated like this:
                        ;
                        ;   ((s2_hi AND %1111) + 11) * 256 + s1_hi
                        ;
                        ; or, in terms of memory locations:
                        ;
                        ;   ((QQ15+5 AND %1111) + 11) * 256 + QQ15+3
                        ;
                        ; Because the multiplication is by 256, this is the
                        ; same as saying a 16-bit number, with high byte:
                        ;
                        ;   (QQ15+5 AND %1111) + 11
                        ;
                        ; and low byte:
                        ;
                        ;   QQ15+3
                        ;
                        ; so we can set this up in (Y X) and call the pr5
                        ; routine to print it out

 LDA QQ15+5             ; Set A = QQ15+5
 LDX QQ15+3             ; Set X = QQ15+3

 AND #%00001111         ; Set Y = (A AND %1111) + 11
 CLC
 ADC #11
 TAY

 JSR pr5                ; Print (Y X) to 5 digits, not including a decimal
                        ; point, as the C flag will be clear (as the maximum
                        ; radius will always fit into 16 bits)

 JSR TT162              ; Print a space

 LDA #'k'               ; Print "km"
 JSR TT26
 LDA #'m'
 JSR TT26

 JSR TTX69              ; Print a paragraph break and set Sentence Case

                        ; By this point, ZZ contains the current system number
                        ; which PDESC requires. It gets put there in the TT102
                        ; routine, which calls TT111 to populate ZZ before
                        ; calling TT25 (this routine)

 JMP PDESC              ; Jump to PDESC to print the system's extended
                        ; description, returning from the subroutine using a
                        ; tail call

 RTS                    ; Return from the subroutine (though this instruction
                        ; has no effect as we already returned using a tail
                        ; call)

; ******************************************************************************
;
;       Name: TT24
;       Type: Subroutine
;   Category: Universe
;    Summary: Calculate system data from the system seeds
;  Deep dive: Generating system data
;             Galaxy and system seeds
;
; ------------------------------------------------------------------------------
;
; Calculate system data from the seeds in QQ15 and store them in the relevant
; locations. Specifically, this routine calculates the following from the three
; 16-bit seeds in QQ15 (using only s0_hi, s1_hi and s1_lo):
;
;   QQ3 = economy (0-7)
;   QQ4 = government (0-7)
;   QQ5 = technology level (0-14)
;   QQ6 = population * 10 (1-71)
;   QQ7 = productivity (96-62480)
;
; The ranges of the various values are shown in brackets. Note that the radius
; and type of inhabitant are calculated on-the-fly in the TT25 routine when
; the system data gets displayed, so they aren't calculated here.
;
; ******************************************************************************

.TT24

 LDA QQ15+1             ; Fetch s0_hi and extract bits 0-2 to determine the
 AND #%00000111         ; system's economy, and store in QQ3
 STA QQ3

 LDA QQ15+2             ; Fetch s1_lo and extract bits 3-5 to determine the
 LSR A                  ; system's government, and store in QQ4
 LSR A
 LSR A
 AND #%00000111
 STA QQ4

 LSR A                  ; If government isn't anarchy or feudal, skip to TT77,
 BNE TT77               ; as we need to fix the economy of anarchy and feudal
                        ; systems so they can't be rich

 LDA QQ3                ; Set bit 1 of the economy in QQ3 to fix the economy
 ORA #%00000010         ; for anarchy and feudal governments
 STA QQ3

.TT77

 LDA QQ3                ; Now to work out the tech level, which we do like this:
 EOR #%00000111         ;
 CLC                    ;   flipped_economy + (s1_hi AND %11) + (government / 2)
 STA QQ5                ;
                        ; or, in terms of memory locations:
                        ;
                        ;   QQ5 = (QQ3 EOR %111) + (QQ15+3 AND %11) + (QQ4 / 2)
                        ;
                        ; We start by setting QQ5 = QQ3 EOR %111

 LDA QQ15+3             ; We then take the first 2 bits of s1_hi (QQ15+3) and
 AND #%00000011         ; add it into QQ5
 ADC QQ5
 STA QQ5

 LDA QQ4                ; And finally we add QQ4 / 2 and store the result in
 LSR A                  ; QQ5, using LSR then ADC to divide by 2, which rounds
 ADC QQ5                ; up the result for odd-numbered government types
 STA QQ5

 ASL A                  ; Now to work out the population, like so:
 ASL A                  ;
 ADC QQ3                ;   (tech level * 4) + economy + government + 1
 ADC QQ4                ;
 ADC #1                 ; or, in terms of memory locations:
 STA QQ6                ;
                        ;   QQ6 = (QQ5 * 4) + QQ3 + QQ4 + 1

 LDA QQ3                ; Finally, we work out productivity, like this:
 EOR #%00000111         ;
 ADC #3                 ;  (flipped_economy + 3) * (government + 4)
 STA P                  ;                        * population
 LDA QQ4                ;                        * 8
 ADC #4                 ;
 STA Q                  ; or, in terms of memory locations:
 JSR MULTU              ;
                        ;   QQ7 = (QQ3 EOR %111 + 3) * (QQ4 + 4) * QQ6 * 8
                        ;
                        ; We do the first step by setting P to the first
                        ; expression in brackets and Q to the second, and
                        ; calling MULTU, so now (A P) = P * Q. The highest this
                        ; can be is 10 * 11 (as the maximum values of economy
                        ; and government are 7), so the high byte of the result
                        ; will always be 0, so we actually have:
                        ;
                        ;   P = P * Q
                        ;     = (flipped_economy + 3) * (government + 4)

 LDA QQ6                ; We now take the result in P and multiply by the
 STA Q                  ; population to get the productivity, by setting Q to
 JSR MULTU              ; the population from QQ6 and calling MULTU again, so
                        ; now we have:
                        ;
                        ;   (A P) = P * population

 ASL P                  ; Next we multiply the result by 8, as a 16-bit number,
 ROL A                  ; so we shift both bytes to the left three times, using
 ASL P                  ; the C flag to carry bits from bit 7 of the low byte
 ROL A                  ; into bit 0 of the high byte
 ASL P
 ROL A

 STA QQ7+1              ; Finally, we store the productivity in two bytes, with
 LDA P                  ; the low byte in QQ7 and the high byte in QQ7+1
 STA QQ7

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TT22
;       Type: Subroutine
;   Category: Charts
;    Summary: Show the Long-range Chart
;
; ******************************************************************************

.TT22

 LDA #64                ; Clear the top part of the screen, draw a white border,
 JSR TT66               ; and set the current view type in QQ11 to 32 (Long-
                        ; range Chart)

 LDA #7                 ; Move the text cursor to column 7
 STA XC

 JSR TT81               ; Set the seeds in QQ15 to those of system 0 in the
                        ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)

 LDA #199               ; Print recursive token 39 ("GALACTIC CHART{galaxy
 JSR TT27               ; number right-aligned to width 3}")

 LDA #GCYT-1            ; ???
 JSR NLIN5
 LDA #GCYB+1
 STA Y1
 LDA #31
 STA X1
 LDA #228
 STA X2
 JSR HLOIN
 LDA #30
 JSR DVLOIN
 LDA #226
 JSR DVLOIN

 JSR TT14               ; Call TT14 to draw a circle with crosshairs at the
                        ; current system's galactic coordinates

 LDX #0                 ; We're now going to plot each of the galaxy's systems,
                        ; so set up a counter in X for each system, starting at
                        ; 0 and looping through to 255

.TT83

 STX XSAV               ; Store the counter in XSAV

 LDA QQ15+3             ; ???
 JSR SCALEX
 TAX

 LDA #$FF               ; ???
 STA ZZ

 LDA QQ15+1             ; Fetch the s0_hi seed into A, which gives us the
                        ; galactic y-coordinate of this system

 JSR SCALEY             ; Scale the y-coordinate ???

 CLC                    ; Add GCYT to the scaled y-coordinate in A (so the top
 ADC #GCYT              ; of the chart is on pixel row GCYT)

 JSR PIXEL              ; Call PIXEL to draw a point at (X, A), with the size of
                        ; the point dependent on the distance specified in ZZ
                        ; (so a high value of ZZ will produce a 1-pixel point,
                        ; a medium value will produce a 2-pixel dash, and a
                        ; small value will produce a 4-pixel square)

 JSR TT20               ; We want to move on to the next system, so call TT20
                        ; to twist the three 16-bit seeds in QQ15

 LDX XSAV               ; Restore the loop counter from XSAV

 INX                    ; Increment the counter

 BNE TT83               ; If X > 0 then we haven't done all 256 systems yet, so
                        ; loop back up to TT83

 LDA QQ9                ; Set QQ19 to the selected system's x-coordinate, scaled
 JSR SCALEX             ; accordingly ???
 STA QQ19

 LDA QQ10               ; Set QQ19+1 to the selected system's y-coordinate,
 JSR SCALEY             ; scaled accordingly ???
 STA QQ19+1

 LDA #4                 ; Set QQ19+2 to size 4 for the crosshairs size
 STA QQ19+2

 LDA #GREEN             ; Switch to stripe 3-1-3-1, which is white/yellow in the
 STA COL                ; chart view

                        ; Fall through into TT15 to draw crosshairs of size 4 at
                        ; the selected system's coordinates

; ******************************************************************************
;
;       Name: TT15
;       Type: Subroutine
;   Category: Drawing lines
;    Summary: Draw a set of crosshairs
;
; ------------------------------------------------------------------------------
;
; For all views except the Short-range Chart, the centre is drawn 24 pixels to
; the right of the y-coordinate given.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   QQ19                The pixel x-coordinate of the centre of the crosshairs
;
;   QQ19+1              The pixel y-coordinate of the centre of the crosshairs
;
;   QQ19+2              The size of the crosshairs
;
; ******************************************************************************

.TT15

 LDA #GCYT              ; Set A to GCYT, which we will use as the minimum
                        ; screen indent for the crosshairs (i.e. the minimum
                        ; distance from the top-left corner of the screen)

 LDX QQ11               ; If the current view is not the Short-range Chart,
 BPL TT178              ; which is the only view with bit 7 set, then jump to
                        ; TT178 to skip the following instruction

 LDA #0                 ; This is the Short-range Chart, so set A to 0, so the
                        ; crosshairs can go right up against the screen edges

.TT178

 STA QQ19+5             ; Set QQ19+5 to A, which now contains the correct indent
                        ; for this view

 LDA QQ19               ; Set A = crosshairs x-coordinate - crosshairs size
 SEC                    ; to get the x-coordinate of the left edge of the
 SBC QQ19+2             ; crosshairs

 BIT QQ11               ; If bit 7 of QQ11 is set, then this this is the
 BMI TT84               ; Short-range Chart, so jump to TT84

 CMP #34                ; ???
 BCS TT84
 LDA #34

.TT84

 STA X1                 ; Set X1 = A (the x-coordinate of the left edge of the
                        ; crosshairs)

 LDA QQ19               ; Set A = crosshairs x-coordinate + crosshairs size + 2
 CLC                    ; to get the x-coordinate of the right edge of the
 ADC #2                 ; crosshairs
 ADC QQ19+2

 BIT QQ11               ; ???
 BMI TT85
 CMP #224
 BCC TT85
 LDA #224

.TT85

 STA X2                 ; Set X2 = A (the x-coordinate of the right edge of the
                        ; crosshairs)

 LDA QQ19+1             ; Set Y1 = crosshairs y-coordinate + indent to get the
 CLC                    ; y-coordinate of the centre of the crosshairs
 ADC QQ19+5
 STA Y1

 JSR HLOIN              ; Draw a horizontal line from (X1, Y1) to (X2, Y1),
                        ; which will draw from the left edge of the crosshairs
                        ; to the right edge, through the centre of the
                        ; crosshairs

 LDA QQ19+1             ; Set A = crosshairs y-coordinate - crosshairs size
 SEC                    ; to get the y-coordinate of the top edge of the
 SBC QQ19+2             ; crosshairs

 BCS TT86               ; If the above subtraction didn't underflow, then A is
                        ; correct, so skip the next instruction

 LDA #0                 ; The subtraction underflowed, so set A to 0 so the
                        ; crosshairs don't spill out of the top of the screen

.TT86

 CLC                    ; Set Y1 = A + indent to get the y-coordinate of the top
 ADC QQ19+5             ; edge of the indented crosshairs
 STA Y1

 LDA QQ19+1             ; Set A = crosshairs y-coordinate + crosshairs size
 CLC                    ; + indent to get the y-coordinate of the bottom edge
 ADC QQ19+2             ; of the indented crosshairs
 ADC QQ19+5

 CMP #GCYB              ; If A < GCYB then skip the following, as the crosshairs
 BCC TT87               ; won't spill out of the bottom of the screen

 LDX QQ11               ; A >= 152, so we need to check whether this will fit in
                        ; this view, so fetch the view type

 BMI TT87               ; If this is the Short-range Chart then the y-coordinate
                        ; is fine, so skip to TT87

 LDA #GCYB              ; Otherwise this is the Long-range Chart, so we need to
                        ; clip the crosshairs at a maximum y-coordinate of GCYB

.TT87

 STA Y2                 ; Set Y2 = A (the y-coordinate of the bottom edge of the
                        ; crosshairs)

 LDA QQ19               ; Set X1 = the x-coordinate of the centre of the
 STA X1                 ; crosshairs

 JMP VLOIN              ; ???

; ******************************************************************************
;
;       Name: TT14
;       Type: Subroutine
;   Category: Drawing circles
;    Summary: Draw a circle with crosshairs on a chart
;
; ------------------------------------------------------------------------------
;
; Draw a circle with crosshairs at the current system's galactic coordinates.
;
; ******************************************************************************

.TT126

 LDA #105               ; Set QQ19 = 105, for the x-coordinate of the centre of
 STA QQ19               ; the fixed circle on the Short-range Chart

 LDA #75                ; Set QQ19+1 = 75, for the y-coordinate of the centre of
 STA QQ19+1             ; the fixed circle on the Short-range Chart

 LDA #16                ; Set QQ19+2 = 16, the size of the crosshairs on the
 STA QQ19+2             ; Short-range Chart

 LDA #GREEN             ; Switch to stripe 3-1-3-1, which is white/yellow in the
 STA COL                ; chart view

 JSR TT15               ; Draw the set of crosshairs defined in QQ19, at the
                        ; exact coordinates as this is the Short-range Chart

 LDA QQ14               ; Set K to the scaled fuel level from QQ14, so this can
 JSR SCALEY2            ; act as the circle's radius (70 being a full tank)
 STA K

 JMP TT128              ; Jump to TT128 to draw a circle with the centre at the
                        ; same coordinates as the crosshairs, (QQ19, QQ19+1),
                        ; and radius K that reflects the current fuel levels,
                        ; returning from the subroutine using a tail call

.TT14

 LDA QQ11               ; If the current view is the Short-range Chart, which
 BMI TT126              ; is the only view with bit 7 set, then jump up to TT126
                        ; to draw the crosshairs and circle for that view

                        ; Otherwise this is the Long-range Chart, so we draw the
                        ; crosshairs and circle for that view instead

 LDA QQ14               ; Set K to the scaled fuel level from QQ14 divided by 4,
 LSR A                  ; so this can act as the circle's radius (70 being a
 JSR SCALEY             ; full tank, which divides down to a radius of 17)
 STA K

 LDA QQ0                ; Set QQ19 to the scaled x-coordinate of the current
 JSR SCALEX             ; system, which will be the centre of the circle and
 STA QQ19               ; crosshairs we draw

 LDA QQ1                ; Set QQ19+1 to the scled y-coordinate of the current
 JSR SCALEY             ; system, which will again be the centre of the circle
 STA QQ19+1             ; and crosshairs we draw

 LDA #7                 ; Set QQ19+2 = 7, the size of the crosshairs on the
 STA QQ19+2             ; Long-range Chart

 LDA #GREEN             ; ???
 STA COL

 JSR TT15               ; Draw the set of crosshairs defined in QQ19, which will
                        ; be drawn 24 pixels to the right of QQ19+1

 LDA QQ19+1             ; Add GCYT to the y-coordinate of the crosshairs in
 CLC                    ; QQ19+1 so that the centre of the circle matches the
 ADC #GCYT              ; centre of the crosshairs
 STA QQ19+1

                        ; Fall through into TT128 to draw a circle with the
                        ; centre at the same coordinates as the crosshairs,
                        ; (QQ19, QQ19+1), and radius K that reflects the
                        ; current fuel levels

; ******************************************************************************
;
;       Name: TT128
;       Type: Subroutine
;   Category: Drawing circles
;    Summary: Draw a circle on a chart
;  Deep dive: Drawing circles
;
; ------------------------------------------------------------------------------
;
; Draw a circle with the centre at (QQ19, QQ19+1) and radius K.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   QQ19                The x-coordinate of the centre of the circle
;
;   QQ19+1              The y-coordinate of the centre of the circle
;
;   K                   The radius of the circle
;
; ******************************************************************************

.TT128

 LDA QQ19               ; Set K3 = the x-coordinate of the centre
 STA K3

 LDA QQ19+1             ; Set K4 = the y-coordinate of the centre
 STA K4

 LDX #0                 ; Set the high bytes of K3(1 0) and K4(1 0) to 0
 STX K4+1
 STX K3+1

;STX LSX                ; This instruction is commented out in the original
                        ; source

 INX                    ; Set LSP = 1 to reset the ball line heap
 STX LSP

 LDX #2                 ; Set STP = 2, the step size for the circle
 STX STP

 JMP CIRCLE2            ; Jump to CIRCLE2 to draw a circle with the centre at
                        ; (K3(1 0), K4(1 0)) and radius K, returning from the
                        ; subroutine using a tail call

; ******************************************************************************
;
;       Name: TT219
;       Type: Subroutine
;   Category: Market
;    Summary: Show the Buy Cargo screen
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   BAY2                Jump into the main loop at FRCE, setting the key
;                       "pressed" to the Inventory key
;
; ******************************************************************************

.TT219

 LDA #2                 ; Clear the top part of the screen, draw a white border,
 JSR TRADEMODE          ; and set up a printable trading screen with a view type
                        ; in QQ11 of 2 (Buy Cargo screen)

 JSR TT163              ; Print the column headers for the prices table

 LDA #%10000000         ; Set bit 7 of QQ17 to switch to Sentence Case, with the
 STA QQ17               ; next letter in capitals

 LDA #0                 ; We're going to loop through all the available market
 STA QQ29               ; items, so we set up a counter in QQ29 to denote the
                        ; current item and start it at 0

.TT220

 JSR TT151              ; Call TT151 to print the item name, market price and
                        ; availability of the current item, and set QQ24 to the
                        ; item's price / 4, QQ25 to the quantity available and
                        ; QQ19+1 to byte #1 from the market prices table for
                        ; this item

 LDA QQ25               ; If there are some of the current item available, jump
 BNE TT224              ; to TT224 below to see if we want to buy any

 JMP TT222              ; Otherwise there are none available, so jump down to
                        ; TT222 to skip this item

.TQ4

 LDY #176               ; Set Y to the recursive token 16 ("QUANTITY")

.Tc

 JSR TT162              ; Print a space

 TYA                    ; Print the recursive token in Y followed by a question
 JSR prq                ; mark

.TTX224

 JSR dn2                ; Call dn2 to make a short, high beep and delay for 1
                        ; second

.TT224

 JSR CLYNS              ; Clear the bottom three text rows of the upper screen,
                        ; and move the text cursor to column 1 on row 21, i.e.
                        ; the start of the top row of the three bottom rows

 LDA #204               ; Print recursive token 44 ("QUANTITY OF ")
 JSR TT27

 LDA QQ29               ; Print recursive token 48 + QQ29, which will be in the
 CLC                    ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
 ADC #208               ; prints the current item's name
 JSR TT27

 LDA #'/'               ; Print "/"
 JSR TT27

 JSR TT152              ; Print the unit ("t", "kg" or "g") for the current item
                        ; (as the call to TT151 above set QQ19+1 with the
                        ; appropriate value)

 LDA #'?'               ; Print "?"
 JSR TT27

 JSR TT67               ; Print a newline

 LDX #0                 ; These instructions have no effect, as they are
 STX R                  ; repeated at the start of gnum, which we call next.
 LDX #12                ; Perhaps they were left behind when code was moved from
 STX T1                 ; here into gnum, and weren't deleted?

{
.TT223                  ; This label is a duplicate of a label in gnum (which is
                        ; why we need to surround it with braces, as BeebAsm
                        ; doesn't allow us to redefine labels, unlike BBC
                        ; BASIC). This could be a remnant if the code in gnum
                        ; was originally here, but got moved into the gnum
                        ; subroutine without removing the original

}

 JSR gnum               ; Call gnum to get a number from the keyboard, which
                        ; will be the quantity of this item we want to purchase,
                        ; returning the number entered in A and R

 BCS TQ4                ; If gnum set the C flag, the number entered is greater
                        ; than the quantity available, so jump up to TQ4 to
                        ; display a "Quantity?" error, beep, clear the number
                        ; and try again

 STA P                  ; Otherwise we have a valid purchase quantity entered,
                        ; so store the amount we want to purchase in P

 JSR tnpr               ; Call tnpr to work out whether there is room in the
                        ; cargo hold for this item

 LDY #206               ; Set Y to recursive token 46 (" CARGO{sentence case}")
                        ; to pass to the Tc routine if we call it

 LDA R                  ; If R = 0, then we didn't enter a number above, so skip
 BEQ P%+4               ; the following instruction

 BCS Tc                 ; If the C flag is set, then there is no room in the
                        ; cargo hold, jump up to Tc to print a "Cargo?" error,
                        ; beep, clear the number and try again

 LDA QQ24               ; There is room in the cargo hold, so now to check
 STA Q                  ; whether we have enough cash, so fetch the item's
                        ; price / 4, which was returned in QQ24 by the call
                        ; to TT151 above and store it in Q

 JSR GCASH              ; Call GCASH to calculate:
                        ;
                        ;   (Y X) = P * Q * 4
                        ;
                        ; which will be the total price of this transaction
                        ; (as P contains the purchase quantity and Q contains
                        ; the item's price / 4)

 JSR LCASH              ; Subtract (Y X) cash from the cash pot in CASH

 LDY #197               ; If the C flag is clear, we didn't have enough cash,
 BCC Tc                 ; so set Y to the recursive token 37 ("CASH") and jump
                        ; up to Tc to print a "Cash?" error, beep, clear the
                        ; number and try again

 LDY QQ29               ; Fetch the current market item number from QQ29 into Y

 LDA R                  ; Set A to the number of items we just purchased (this
                        ; was set by gnum above)

 PHA                    ; Store the quantity just purchased on the stack

 CLC                    ; Add the number purchased to the Y-th byte of QQ20,
 ADC QQ20,Y             ; which contains the number of items of this type in
 STA QQ20,Y             ; our hold (so this transfers the bought items into our
                        ; cargo hold)

 LDA AVL,Y              ; Subtract the number of items from the Y-th byte of
 SEC                    ; AVL, which contains the number of items of this type
 SBC R                  ; that are available on the market
 STA AVL,Y

 PLA                    ; Restore the quantity just purchased

 BEQ TT222              ; If we didn't buy anything, jump to TT222 to skip the
                        ; following instruction

 JSR dn                 ; Call dn to print the amount of cash left in the cash
                        ; pot, then make a short, high beep to confirm the
                        ; purchase, and delay for 1 second

.TT222

 LDA QQ29               ; Move the text cursor to row QQ29 + 5 (where QQ29 is
 CLC                    ; the item number, starting from 0)
 ADC #5
 JSR DOYC

 LDA #0                 ; Move the text cursor to column 0
 JSR DOXC

 INC QQ29               ; Increment QQ29 to point to the next item

 LDA QQ29               ; If QQ29 >= 17 then jump to BAY2 as we have done the
 CMP #17                ; last item
 BCS BAY2

 JMP TT220              ; Otherwise loop back to TT220 to print the next market
                        ; item

.BAY2

;LDA #$10               ; These instructions are commented out in the original
;STA COL2               ; source

 LDA #f9                ; Jump into the main loop at FRCE, setting the key
 JMP FRCE               ; "pressed" to red key f9 (so we show the Inventory
                        ; screen)

; ******************************************************************************
;
;       Name: gnum
;       Type: Subroutine
;   Category: Market
;    Summary: Get a number from the keyboard
;
; ------------------------------------------------------------------------------
;
; Get a number from the keyboard, up to the maximum number in QQ25, for the
; buying and selling of cargo and equipment.
;
; Pressing "Y" will return the maximum number (i.e. buy/sell all items), while
; pressing "N" will abort the sale and return a 0.
;
; Pressing a key with an ASCII code less than ASCII "0" will return a 0 in A (so
; that includes pressing Space or Return), while pressing a key with an ASCII
; code greater than ASCII "9" will jump to the Inventory screen (so that
; includes all letters and most punctuation).
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   QQ25                The maximum number allowed
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   A                   The number entered
;
;   R                   Also contains the number entered
;
;   C flag              Set if the number is too large (> QQ25), clear otherwise
;
; ******************************************************************************

.gnum

;LDA #MAG2              ; These instructions are commented out in the original
;STA COL2               ; source

 LDX #0                 ; We will build the number entered in R, so initialise
 STX R                  ; it with 0

 LDX #12                ; We will check for up to 12 key presses, so set a
 STX T1                 ; counter in T1

.TT223

 JSR TT217              ; Scan the keyboard until a key is pressed, and return
                        ; the key's ASCII code in A (and X)

 LDX R                  ; If R is non-zero then skip to NWDAV2, as we are
 BNE NWDAV2             ; already building a number

 CMP #'Y'               ; If "Y" was pressed, jump to NWDAV1 to return the
 BEQ NWDAV1             ; maximum number allowed (i.e. buy/sell the whole stock)

 CMP #'N'               ; If "N" was pressed, jump to NWDAV3 to return from the
 BEQ NWDAV3             ; subroutine with a result of 0 (i.e. abort transaction)

.NWDAV2

 STA Q                  ; Store the key pressed in Q

 SEC                    ; Subtract ASCII "0" from the key pressed, to leave the
 SBC #'0'               ; numeric value of the key in A (if it was a number key)

 BCC OUT                ; If A < 0, jump to OUT to load the current number and
                        ; return from the subroutine, as the key pressed was
                        ; RETURN (or some other ncharacter with a value less
                        ; than ASCII "0")

 CMP #10                ; If A >= 10, jump to BAY2 to display the Inventory
 BCS BAY2               ; screen, as the key pressed was a letter or other
                        ; non-digit and is greater than ASCII "9"

 STA S                  ; Store the numeric value of the key pressed in S

 LDA R                  ; Fetch the result so far into A

 CMP #26                ; If A >= 26, where A is the number entered so far, then
 BCS OUT                ; adding a further digit will make it bigger than 256,
                        ; so jump to OUT to return from the subroutine with the
                        ; result in R (i.e. ignore the last key press)

 ASL A                  ; Set A = (A * 2) + (A * 8) = A * 10
 STA T
 ASL A
 ASL A
 ADC T

 ADC S                  ; Add the pressed digit to A and store in R, so R now
 STA R                  ; contains its previous value with the new key press
                        ; tacked onto the end

 CMP QQ25               ; If the result in R = the maximum allowed in QQ25, jump
 BEQ TT226              ; to TT226 to print the key press and keep looping (the
                        ; BEQ is needed because the BCS below would jump to OUT
                        ; if R >= QQ25, which we don't want)

 BCS OUT                ; If the result in R > QQ25, jump to OUT to return from
                        ; the subroutine with the result in R

.TT226

 LDA Q                  ; Print the character in Q (i.e. the key that was
 JSR TT26               ; pressed, as we stored the ASCII value in Q earlier)

 DEC T1                 ; Decrement the loop counter

 BNE TT223              ; Loop back to TT223 until we have checked for 12 digits

.OUT

;LDA #$10               ; These instructions are commented out in the original
;STA COL2               ; source

 LDA R                  ; Set A to the result we have been building in R

 RTS                    ; Return from the subroutine

.NWDAV1

                        ; If we get here then "Y" was pressed, so we return the
                        ; maximum number allowed, which is in QQ25

 JSR TT26               ; Print the character for the key that was pressed

 LDA QQ25               ; Set R = QQ25, so we return the maximum value allowed
 STA R

 JMP OUT                ; Jump to OUT to return from the subroutine

.NWDAV3

                        ; If we get here then "N" was pressed, so we return 0

 JSR TT26               ; Print the character for the key that was pressed

 LDA #0                 ; Set R = 0, so we return 0
 STA R

 JMP OUT                ; Jump to OUT to return from the subroutine

; ******************************************************************************
;
;       Name: NWDAV4
;       Type: Subroutine
;   Category: Market
;    Summary: Print an "ITEM?" error, make a beep and rejoin the TT210 routine
;
; ******************************************************************************

.NWDAV4

 JSR TT67               ; Print a newline

 LDA #176               ; Print recursive token 127 ("ITEM") followed by a
 JSR prq                ; question mark

 JSR dn2                ; Call dn2 to make a short, high beep and delay for 1
                        ; second

 LDY QQ29               ; Fetch the item number we are selling from QQ29

 JMP NWDAVxx            ; Jump back into the TT210 routine that called NWDAV4

; ******************************************************************************
;
;       Name: TT208
;       Type: Subroutine
;   Category: Market
;    Summary: Show the Sell Cargo screen
;
; ******************************************************************************

.TT208

 LDA #4                 ; Clear the top part of the screen, draw a white border,
 JSR TRADEMODE          ; and set up a printable trading screen with a view type
                        ; in QQ11 of 4 (Sell Cargo screen)

 LDA #10                ; Move the text cursor to column 10
 JSR DOXC

 LDA #205               ; Print recursive token 45 ("SELL")
 JSR TT27

 LDA #206               ; Print recursive token 46 (" CARGO{sentence case}")
 JSR NLIN3              ; draw a horizontal line at pixel row 19 to box in the
                        ; title

 JSR TT67               ; Print a newline

                        ; Fall through into TT210 to show the Inventory screen
                        ; with the option to sell

; ******************************************************************************
;
;       Name: TT210
;       Type: Subroutine
;   Category: Market
;    Summary: Show a list of current cargo in our hold, optionally to sell
;
; ------------------------------------------------------------------------------
;
; Show a list of current cargo in our hold, either with the ability to sell (the
; Sell Cargo screen) or without (the Inventory screen), depending on the current
; view.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   QQ11                The current view:
;
;                           * 4 = Sell Cargo
;
;                           * 8 = Inventory
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   NWDAVxx             Used to rejoin this routine from the call to NWDAV4
;
; ******************************************************************************

.TT210

 LDY #0                 ; We're going to loop through all the available market
                        ; items and check whether we have any in the hold (and,
                        ; if we are in the Sell Cargo screen, whether we want
                        ; to sell any items), so we set up a counter in Y to
                        ; denote the current item and start it at 0

.TT211

 STY QQ29               ; Store the current item number in QQ29

.NWDAVxx

 LDX QQ20,Y             ; Fetch into X the amount of the current item that we
 BEQ TT212              ; have in our cargo hold, which is stored in QQ20+Y,
                        ; and if there are no items of this type in the hold,
                        ; jump down to TT212 to skip to the next item

 TYA                    ; Set Y = Y * 4, so this will act as an index into the
 ASL A                  ; market prices table at QQ23 for this item (as there
 ASL A                  ; are four bytes per item in the table)
 TAY

 LDA QQ23+1,Y           ; Fetch byte #1 from the market prices table for the
 STA QQ19+1             ; current item and store it in QQ19+1, for use by the
                        ; call to TT152 below

 TXA                    ; Store the amount of item in the hold (in X) on the
 PHA                    ; stack

 JSR TT69               ; Call TT69 to set Sentence Case and print a newline

 CLC                    ; Print recursive token 48 + QQ29, which will be in the
 LDA QQ29               ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
 ADC #208               ; prints the current item's name
 JSR TT27

 LDA #14                ; Move the text cursor to column 14, for the item's
 JSR DOXC               ; quantity

 PLA                    ; Restore the amount of item in the hold into X
 TAX

 STA QQ25               ; Store the amount of this item in the hold in QQ25

 CLC                    ; Print the 8-bit number in X to 3 digits, without a
 JSR pr2                ; decimal point

 JSR TT152              ; Print the unit ("t", "kg" or "g") for the market item
                        ; whose byte #1 from the market prices table is in
                        ; QQ19+1 (which we set up above)

 LDA QQ11               ; If the current view type in QQ11 is not 4 (Sell Cargo
 CMP #4                 ; screen), jump to TT212 to skip the option to sell
 BNE TT212              ; items

;JSR TT162              ; This instruction is commented out in the original
                        ; source

 LDA #205               ; Print recursive token 45 ("SELL")
 JSR TT27

 LDA #206               ; Print extended token 206 ("{all caps}(Y/N)?")
 JSR DETOK

 JSR gnum               ; Call gnum to get a number from the keyboard, which
                        ; will be the number of the item we want to sell,
                        ; returning the number entered in A and R, and setting
                        ; the C flag if the number is bigger than the available
                        ; amount of this item in QQ25

 BEQ TT212              ; If no number was entered, jump to TT212 to move on to
                        ; the next item

 BCS NWDAV4             ; If the number entered was too big, jump to NWDAV4 to
                        ; print an "ITEM?" error, make a beep and rejoin the
                        ; routine at NWDAVxx above

 LDA QQ29               ; We are selling this item, so fetch the item number
                        ; from QQ29

 LDX #255               ; Set QQ17 = 255 to disable printing
 STX QQ17

 JSR TT151              ; Call TT151 to set QQ24 to the item's price / 4 (the
                        ; routine doesn't print the item details, as we just
                        ; disabled printing)

 LDY QQ29               ; Subtract R (the number of items we just asked to buy)
 LDA QQ20,Y             ; from the available amount of this item in QQ20, as we
 SEC                    ; just bought them
 SBC R
 STA QQ20,Y

 LDA R                  ; Set P to the amount of this item we just bought
 STA P

 LDA QQ24               ; Set Q to the item's price / 4
 STA Q

 JSR GCASH              ; Call GCASH to calculate
                        ;
                        ;   (Y X) = P * Q * 4
                        ;
                        ; which will be the total price we make from this sale
                        ; (as P contains the quantity we're selling and Q
                        ; contains the item's price / 4)

 JSR MCASH              ; Add (Y X) cash to the cash pot in CASH

 LDA #0                 ; We've made the sale, so set the amount

 STA QQ17               ; Set QQ17 = 0, which enables printing again

.TT212

 LDY QQ29               ; Fetch the item number from QQ29 into Y, and increment
 INY                    ; Y to point to the next item

 CPY #17                ; Loop back to TT211 to print the next item in the hold
 BCC TT211              ; until Y = 17 (at which point we have done the last
                        ; item)

 LDA QQ11               ; If the current view type in QQ11 is not 4 (Sell Cargo
 CMP #4                 ; screen), skip the next two instructions and move on to
 BNE P%+8               ; printing the number of Trumbles

 JSR dn2                ; This is the Sell Cargo screen, so call dn2 to make a
                        ; short, high beep and delay for 1 second

 JMP BAY2               ; And then jump to BAY2 to display the Inventory
                        ; screen, as we have finished selling cargo

 JSR TT69               ; Call TT69 to set Sentence Case and print a newline

 LDA TRIBBLE            ; If there are any Trumbles in the hold, skip the
 ORA TRIBBLE+1          ; following RTS and continue on (in the Master version,
 BNE P%+3               ; there are never any Trumbles, so this value will
                        ; always be zero)

.zebra

 RTS                    ; There are no Trumbles in the hold, so return from the
                        ; subroutine

                        ; If we get here then we have Trumbles in the hold, so
                        ; we print out the number (though we never get here in
                        ; the Master version)

 CLC                    ; Clear the C flag, so the call to TT11 below doesn't
                        ; include a decimal point

 LDA #0                 ; Set A = 0, for the call to TT11 below, so we don't pad
                        ; out the number of Trumbles

 LDX TRIBBLE            ; Fetch the number of Trumbles into (Y X)
 LDY TRIBBLE+1

 JSR TT11               ; Call TT11 to print the number of Trumbles in (Y X),
                        ; with no decimal point

 JSR DORND              ; Print out a random extended token from 111 to 114, all
 AND #3                 ; of which are blank in this version of Elite
 CLC
 ADC #111
 JSR DETOK

 LDA #198               ; Print extended token 198, which is blank, but would
 JSR DETOK              ; contain the text "LITTLE TRUMBLE" if the Trumbles
                        ; mission was enabled

 LDA TRIBBLE+1          ; If we have more than 256 Trumbles, skip to DOANS
 BNE DOANS

 LDX TRIBBLE            ; If we have exactly one Trumble, return from the
 DEX                    ; subroutine (as zebra contains an RTS)
 BEQ zebra

.DOANS

 LDA #'s'               ; We have more than one Trumble, so print an 's' and
 JMP DASC               ; return from the subroutine using a tail call

; ******************************************************************************
;
;       Name: TT213
;       Type: Subroutine
;   Category: Market
;    Summary: Show the Inventory screen
;
; ******************************************************************************

.TT213

 LDA #8                 ; Clear the top part of the screen, draw a white border,
 JSR TRADEMODE          ; and set up a printable trading screen with a view type
                        ; in QQ11 of 4 (Inventory screen)

 LDA #11                ; Move the text cursor to column 11 to print the screen
 JSR DOXC               ; title

 LDA #164               ; Print recursive token 4 ("INVENTORY{crlf}") followed
 JSR TT60               ; by a paragraph break and Sentence Case

 JSR NLIN4              ; Draw a horizontal line at pixel row 19 to box in the
                        ; title. The authors could have used a call to NLIN3
                        ; instead and saved the above call to TT60, but you
                        ; just can't optimise everything

 JSR fwl                ; Call fwl to print the fuel and cash levels on two
                        ; separate lines

 LDA CRGO               ; If our ship's cargo capacity is < 26 (i.e. we do not
 CMP #26                ; have a cargo bay extension), skip the following two
 BCC P%+7               ; instructions

 LDA #107               ; We do have a cargo bay extension, so print recursive
 JSR TT27               ; token 107 ("LARGE CARGO{sentence case} BAY")

 JMP TT210              ; Jump to TT210 to print the contents of our cargo bay
                        ; and return from the subroutine using a tail call

; ******************************************************************************
;
;       Name: TT214
;       Type: Subroutine
;   Category: Keyboard
;    Summary: Ask a question with a "Y/N?" prompt and return the response
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The text token to print before the "Y/N?" prompt
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              Set if the response was "yes", clear otherwise
;
; ******************************************************************************

.TT214

;.TT214                 ; These instructions are commented out in the original
;PHA                    ; source
;JSR TT162
;PLA

.TT221

 JSR TT27               ; Print the text token in A

 LDA #206               ; Print extended token 206 ("{all caps}(Y/N)?")
 JSR DETOK

 JSR TT217              ; Scan the keyboard until a key is pressed, and return
                        ; the key's ASCII code in A and X

 ORA #%00100000         ; Set bit 5 in the value of the key pressed, which
                        ; converts it to lower case

 CMP #'y'               ; If "y" was pressed, jump to TT218
 BEQ TT218

 LDA #'n'               ; Otherwise jump to TT26 to print "n" and return from
 JMP TT26               ; the subroutine using a tail call (so all other
                        ; responses apart from "y" indicate a no)

.TT218

 JSR TT26               ; Print the character in A, i.e. print "y"

 SEC                    ; Set the C flag to indicate a "yes" response

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TT16
;       Type: Subroutine
;   Category: Charts
;    Summary: Move the crosshairs on a chart
;
; ------------------------------------------------------------------------------
;
; Move the chart crosshairs by the amount in X and Y.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The amount to move the crosshairs in the x-axis
;
;   Y                   The amount to move the crosshairs in the y-axis
;
; ******************************************************************************

.TT16

 TXA                    ; Push the change in X onto the stack (let's call this
 PHA                    ; the x-delta)

 DEY                    ; Negate the change in Y and push it onto the stack
 TYA                    ; (let's call this the y-delta)
 EOR #$FF
 PHA

 JSR WSCAN              ; Call WSCAN to wait for the vertical sync, so the whole
                        ; screen gets drawn and we can move the crosshairs with
                        ; no screen flicker

 JSR TT103              ; Draw small crosshairs at coordinates (QQ9, QQ10),
                        ; which will erase the crosshairs currently there

 PLA                    ; Store the y-delta in QQ19+3 and fetch the current
 STA QQ19+3             ; y-coordinate of the crosshairs from QQ10 into A, ready
 LDA QQ10               ; for the call to TT123

 JSR TT123              ; Call TT123 to move the selected system's galactic
                        ; y-coordinate by the y-delta, putting the new value in
                        ; QQ19+4

 LDA QQ19+4             ; Store the updated y-coordinate in QQ10 (the current
 STA QQ10               ; y-coordinate of the crosshairs)

 STA QQ19+1             ; This instruction has no effect, as QQ19+1 is
                        ; overwritten below, both in TT103 and TT105

 PLA                    ; Store the x-delta in QQ19+3 and fetch the current
 STA QQ19+3             ; x-coordinate of the crosshairs from QQ10 into A, ready
 LDA QQ9                ; for the call to TT123

 JSR TT123              ; Call TT123 to move the selected system's galactic
                        ; x-coordinate by the x-delta, putting the new value in
                        ; QQ19+4

 LDA QQ19+4             ; Store the updated x-coordinate in QQ9 (the current
 STA QQ9                ; x-coordinate of the crosshairs)

 STA QQ19               ; This instruction has no effect, as QQ19 is overwritten
                        ; below, both in TT103 and TT105

                        ; Now we've updated the coordinates of the crosshairs,
                        ; fall through into TT103 to redraw them at their new
                        ; location

; ******************************************************************************
;
;       Name: TT103
;       Type: Subroutine
;   Category: Charts
;    Summary: Draw a small set of crosshairs on a chart
;
; ------------------------------------------------------------------------------
;
; Draw a small set of crosshairs on a galactic chart at the coordinates in
; (QQ9, QQ10).
;
; ******************************************************************************

.TT103

 LDA #GREEN             ; Switch to stripe 3-1-3-1, which is white/yellow in the
 STA COL                ; chart view

 LDA QQ11               ; Fetch the current view type into A

 BMI TT105              ; If this is the Short-range Chart screen, jump to TT105

 LDA QQ9                ; Store the scaled crosshairs x-coordinate in QQ19
 JSR SCALEX
 STA QQ19

 LDA QQ10               ; Store the scaled crosshairs y-coordinate and in QQ19
 JSR SCALEY
 STA QQ19+1

 LDA #4                 ; Set QQ19+2 to 4 denote crosshairs of size 4
 STA QQ19+2

 JMP TT15               ; Jump to TT15 to draw crosshairs of size 4 at the
                        ; crosshairs coordinates, returning from the subroutine
                        ; using a tail call

; ******************************************************************************
;
;       Name: TT123
;       Type: Subroutine
;   Category: Charts
;    Summary: Move galactic coordinates by a signed delta
;
; ------------------------------------------------------------------------------
;
; Move an 8-bit galactic coordinate by a certain distance in either direction
; (i.e. a signed 8-bit delta), but only if it doesn't cause the coordinate to
; overflow. The coordinate is in a single axis, so it's either an x-coordinate
; or a y-coordinate.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The galactic coordinate to update
;
;   QQ19+3              The delta (can be positive or negative)
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   QQ19+4              The updated coordinate after moving by the delta (this
;                       will be the same as A if moving by the delta overflows)
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   TT180               Contains an RTS
;
; ******************************************************************************

.TT123

 STA QQ19+4             ; Store the original coordinate in temporary storage at
                        ; QQ19+4

 CLC                    ; Set A = A + QQ19+3, so A now contains the original
 ADC QQ19+3             ; coordinate, moved by the delta

 LDX QQ19+3             ; If the delta is negative, jump to TT124
 BMI TT124

 BCC TT125              ; If the C flag is clear, then the above addition didn't
                        ; overflow, so jump to TT125 to return the updated value

 RTS                    ; Otherwise the C flag is set and the above addition
                        ; overflowed, so do not update the return value

.TT124

 BCC TT180              ; If the C flag is clear, then because the delta is
                        ; negative, this indicates the addition (which is
                        ; effectively a subtraction) underflowed, so jump to
                        ; TT180 to return from the subroutine without updating
                        ; the return value

.TT125

 STA QQ19+4             ; Store the updated coordinate in QQ19+4

.TT180

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TT105
;       Type: Subroutine
;   Category: Charts
;    Summary: Draw crosshairs on the Short-range Chart, with clipping
;
; ------------------------------------------------------------------------------
;
; Check whether the crosshairs are close enough to the current system to appear
; on the Short-range Chart, and if so, draw them.
;
; ******************************************************************************

.TT105

 LDA QQ9                ; Set A = QQ9 - QQ0, the horizontal distance between the
 SEC                    ; crosshairs (QQ9) and the current system (QQ0)
 SBC QQ0

 CMP #29                ; If the horizontal distance in A < 29, then the
 BCC TT179              ; crosshairs are close enough to the current system to
                        ; appear in the Short-range Chart, so jump to TT179 to
                        ; check the vertical distance

 CMP #227               ; If the horizontal distance in A < -29, then the
 BCC TT180              ; crosshairs are too far from the current system to
                        ; appear in the Short-range Chart, so jump to TT180 to
                        ; return from the subroutine (as TT180 contains an RTS)

.TT179

 ASL A                  ; Set QQ19 = 105 + A * 4
 ASL A                  ;
 CLC                    ; 105 is the x-coordinate of the centre of the chart,
 ADC #105*4/3           ; so this sets QQ19 to the scaled screen pixel
 JSR SCALEY2            ; x-coordinate ???
 STA QQ19

 LDA QQ10               ; Set A = QQ10 - QQ1, the vertical distance between the
 SEC                    ; crosshairs (QQ10) and the current system (QQ1)
 SBC QQ1

 CMP #35                ; If the vertical distance in A is < 35, then the
 BCC P%+6               ; crosshairs are close enough to the current system to
                        ; appear in the Short-range Chart, so skip the next two
                        ; instructions

 CMP #230               ; If the horizontal distance in A is < -26, then the
 BCC TT180              ; crosshairs are too far from the current system to
                        ; appear in the Short-range Chart, so jump to TT180 to
                        ; return from the subroutine (as TT180 contains an RTS)

 ASL A                  ; Set QQ19+1 = 99 + A * 2
 CLC                    ;
 ADC #99                ; 90 is the y-coordinate of the centre of the chart,
 JSR SCALEY2            ; so this sets QQ19+1 to the scaled screen pixel
 STA QQ19+1             ; x-coordinate of the crosshairs

 LDA #8                 ; Set QQ19+2 to 8 denote crosshairs of size 8
 STA QQ19+2

 LDA #GREEN             ; Switch to stripe 3-1-3-1, which is white/yellow in the
 STA COL                ; chart view

 JMP TT15               ; Jump to TT15 to draw crosshairs of size 8 at the
                        ; crosshairs coordinates, returning from the subroutine
                        ; using a tail call

; ******************************************************************************
;
;       Name: TT23
;       Type: Subroutine
;   Category: Charts
;    Summary: Show the Short-range Chart
;
; ******************************************************************************

.TT23

 LDA #128               ; Clear the top part of the screen, draw a white border,
 JSR TT66               ; and set the current view type in QQ11 to 128 (Short-
                        ; range Chart)

 LDA #7                 ; Move the text cursor to column 7
 STA XC

 LDA #190               ; Print recursive token 30 ("SHORT RANGE CHART") and
 JSR NLIN3              ; draw a horizontal line at pixel row 19 to box in the
                        ; title

 JSR TT14               ; Call TT14 to draw a circle with crosshairs at the
                        ; current system's galactic coordinates

 JSR TT103              ; Draw small crosshairs at coordinates (QQ9, QQ10),
                        ; i.e. at the selected system

 JSR TT81               ; Set the seeds in QQ15 to those of system 0 in the
                        ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)

 LDA #0                 ; Set A = 0, which we'll use below to zero out the INWK
                        ; workspace

 STA XX20               ; We're about to start working our way through each of
                        ; the galaxy's systems, so set up a counter in XX20 for
                        ; each system, starting at 0 and looping through to 255

 LDX #24                ; First, though, we need to zero out the 25 bytes at
                        ; INWK so we can use them to work out which systems have
                        ; room for a label, so set a counter in X for 25 bytes

.EE3

 STA INWK,X             ; Set the X-th byte of INWK to zero

 DEX                    ; Decrement the counter

 BPL EE3                ; Loop back to EE3 for the next byte until we've zeroed
                        ; all 25 bytes

                        ; We now loop through every single system in the galaxy
                        ; and check the distance from the current system whose
                        ; coordinates are in (QQ0, QQ1). We get the galactic
                        ; coordinates of each system from the system's seeds,
                        ; like this:
                        ;
                        ;   x = s1_hi (which is stored in QQ15+3)
                        ;   y = s0_hi (which is stored in QQ15+1)
                        ;
                        ; so the following loops through each system in the
                        ; galaxy in turn and calculates the distance between
                        ; (QQ0, QQ1) and (s1_hi, s0_hi) to find the closest one

.TT182

 LDA QQ15+3             ; Set A = s1_hi - QQ0, the horizontal distance between
 SEC                    ; (s1_hi, s0_hi) and (QQ0, QQ1)
 SBC QQ0

 BCS TT184              ; If a borrow didn't occur, i.e. s1_hi >= QQ0, then the
                        ; result is positive, so jump to TT184 and skip the
                        ; following two instructions

 EOR #$FF               ; Otherwise negate the result in A, so A is always
 ADC #1                 ; positive (i.e. A = |s1_hi - QQ0|)

.TT184

 CMP #29                ; If the horizontal distance in A is >= 29, then this
 BCS TT187s             ; system is too far away from the current system to
                        ; appear in the Short-range Chart, so jump to TT187 via
                        ; TT187s to move on to the next system

 LDA QQ15+1             ; Set A = s0_hi - QQ1, the vertical distance between
 SEC                    ; (s1_hi, s0_hi) and (QQ0, QQ1)
 SBC QQ1

 BCS TT186              ; If a borrow didn't occur, i.e. s0_hi >= QQ1, then the
                        ; result is positive, so jump to TT186 and skip the
                        ; following two instructions

 EOR #$FF               ; Otherwise negate the result in A, so A is always
 ADC #1                 ; positive (i.e. A = |s0_hi - QQ1|)

.TT186

 CMP #40                ; If the vertical distance in A is >= 40, then this
 BCS TT187s             ; system is too far away from the current system to
                        ; appear in the Short-range Chart, so jump to TT187 via
                        ; TT187s to move on to the next system

                        ; This system should be shown on the Short-range Chart,
                        ; so now we need to work out where the label should go,
                        ; and set up the various variables we need to draw the
                        ; system's filled circle on the chart

 LDA QQ15+3             ; Set A = s1_hi - QQ0, the horizontal distance between
 SEC                    ; this system and the current system, where |A| < 20.
 SBC QQ0                ; Let's call this the x-delta, as it's the horizontal
                        ; difference between the current system at the centre of
                        ; the chart, and this system (and this time we keep the
                        ; sign of A, so it can be negative if it's to the left
                        ; of the chart's centre, or positive if it's to the
                        ; right)

 ASL A                  ; Set XX12 = 105 + x-delta * 4
 ASL A                  ;
 ADC #105*4/3           ; 105 is the x-coordinate of the centre of the chart,
 JSR SCALEY2            ; so this sets XX12 to the centre 104 +/- 76, to give
 STA XX12               ; the scaled pixel x-coordinate of this system

 LSR A                  ; Move the text cursor to column x-delta / 2 + 1
 LSR A                  ; which will be in the range 1-10
 LSR A
 CLC
 ADC #1
 STA XC

 LDA QQ15+1             ; Set A = s0_hi - QQ1, the vertical distance between
 SEC                    ; this system and the current system, where |A| < 38.
 SBC QQ1                ; Let's call this the y-delta, as it's the vertical
                        ; difference between the current system at the centre of
                        ; the chart, and this system (and this time we keep the
                        ; sign of A, so it can be negative if it's above the
                        ; chart's centre, or positive if it's below)

 ASL A                  ; Set K4 = 99 + y-delta * 2
 ADC #99                ;
 JSR SCALEY2            ; 99 is the y-coordinate of the centre of the chart,
 STA K4                 ; so this sets K4 to the centre 99 +/- 74, to give the
                        ; scaled pixel y-coordinate of this system

 LSR A                  ; Set Y = K4 / 8, so Y contains the number of the text
 LSR A                  ; row that contains this system
 LSR A
 TAY

                        ; Now to see if there is room for this system's label.
                        ; Ideally we would print the system name on the same
                        ; text row as the system, but we only want to print one
                        ; label per row, to prevent overlap, so now we check
                        ; this system's row, and if that's already occupied,
                        ; the row above, and if that's already occupied, the
                        ; row below... and if that's already occupied, we give
                        ; up and don't print a label for this system

 LDX INWK,Y             ; If the value in INWK+Y is 0 (i.e. the text row
 BEQ EE4                ; containing this system does not already have another
                        ; system's label on it), jump to EE4 to store this
                        ; system's label on this row

 INY                    ; If the value in INWK+Y+1 is 0 (i.e. the text row below
 LDX INWK,Y             ; the one containing this system does not already have
 BEQ EE4                ; another system's label on it), jump to EE4 to store
                        ; this system's label on this row

 DEY                    ; If the value in INWK+Y-1 is 0 (i.e. the text row above
 DEY                    ; the one containing this system does not already have
 LDX INWK,Y             ; another system's label on it), fall through into to
 BNE ee1                ; EE4 to store this system's label on this row,
                        ; otherwise jump to ee1 to skip printing a label for
                        ; this system (as there simply isn't room)

.EE4

 STY YC                 ; Now to print the label, so move the text cursor to row
                        ; Y (which contains the row where we can print this
                        ; system's label)

 CPY #3                 ; If Y < 3, then the system would clash with the chart
 BCC TT187              ; title, so jump to TT187 to skip showing the system

 CPY #17                ; If Y > 17, then the label will be off the bottom of
 BCS TT187              ; the chart, so jump to TT187 to skip showing the system

 TYA                    ; Store Y on the stack so it can be preserved across the
 PHA                    ; call to readdistnce

 LDA QQ15+3             ; Set A = s1_hi, so A contains the galactic x-coordinate
                        ; of the system we are displaying on the chart

 JSR readdistnce        ; Call readdistnce to calculate the distance between the
                        ; system with galactic coordinates (A, QQ15+1) - i.e.
                        ; the system we are displaying - and the current system
                        ; at (QQ0, QQ1), returning the result in QQ8(1 0)

 PLA                    ; Restore Y from the stack
 TAY

 LDA QQ8+1              ; If the high byte of the distance in QQ8(1 0) is
 BNE TT187              ; non-zero, jump to TT187 to skip showing the system as
                        ; it is too far away from the current system

 LDA QQ8                ; If the low byte of the distance in QQ8(1 0) is >= 70,
 CMP #70                ; jump to TT187 to skip showing the system as it is too
                        ; far away from the current system

.TT187s

 BCS TT187              ; If we get here from the instruction above, we jump to
                        ; TT187 if QQ8(1 0) >= 70, so we only show systems that
                        ; are within distance 70 (i.e. 7 light years) of the
                        ; current system
                        ;
                        ; If we jump here from elsewhere with a BCS TT187s, we
                        ; jump straight on to TT187

 LDA #$FF               ; Store $FF in INWK+Y, to denote that this row is now
 STA INWK,Y             ; occupied so we don't try to print another system's
                        ; label on this row

 LDA #%10000000         ; Set bit 7 of QQ17 to switch to Sentence Case
 STA QQ17

 JSR cpl                ; Call cpl to print out the system name for the seeds
                        ; in QQ15 (which now contains the seeds for the current
                        ; system)

.ee1

 LDA #0                 ; Now to plot the star, so set the high bytes of K, K3
 STA K3+1               ; and K4 to 0
 STA K4+1
 STA K+1

 LDA XX12               ; Set the low byte of K3 to XX12, the pixel x-coordinate
 STA K3                 ; of this system

 LDA QQ15+5             ; Fetch s2_hi for this system from QQ15+5, extract bit 0
 AND #1                 ; and add 2 to get the size of the star, which we store
 ADC #2                 ; in K. This will be either 2, 3 or 4, depending on the
 STA K                  ; value of bit 0, and whether the C flag is set (which
                        ; will vary depending on what happens in the above call
                        ; to cpl). Incidentally, the planet's average radius
                        ; also uses s2_hi, bits 0-3 to be precise, but that
                        ; doesn't mean the two sizes affect each other

                        ; We now have the following:
                        ;
                        ;   K(1 0)  = radius of star (2, 3 or 4)
                        ;
                        ;   K3(1 0) = pixel x-coordinate of system
                        ;
                        ;   K4(1 0) = pixel y-coordinate of system
                        ;
                        ; which we can now pass to the SUN routine to draw a
                        ; small "sun" on the Short-range Chart for this system

 JSR FLFLLS             ; Call FLFLLS to reset the LSO block

 JSR SUN                ; Call SUN to plot a sun with radius K at pixel
                        ; coordinate (K3, K4)

 JSR FLFLLS             ; Call FLFLLS to reset the LSO block

.TT187

 JSR TT20               ; We want to move on to the next system, so call TT20
                        ; to twist the three 16-bit seeds in QQ15

 INC XX20               ; Increment the counter

 BEQ P%+5               ; If X = 0 then we have done all 256 systems, so skip
                        ; the next instruction to return from the subroutine

 JMP TT182              ; Otherwise jump back up to TT182 to process the next
                        ; system

;LDA #0                 ; These instructions are commented out in the original
;STA dontclip           ; source
;LDA #2*Y-1
;STA Yx2M1

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TT81
;       Type: Subroutine
;   Category: Universe
;    Summary: Set the selected system's seeds to those of system 0
;
; ------------------------------------------------------------------------------
;
; Copy the three 16-bit seeds for the current galaxy's system 0 (QQ21) into the
; seeds for the selected system (QQ15) - in other words, set the selected
; system's seeds to those of system 0.
;
; ******************************************************************************

.TT81

 LDX #5                 ; Set up a counter in X to copy six bytes (for three
                        ; 16-bit numbers)

 LDA QQ21,X             ; Copy the X-th byte in QQ21 to the X-th byte in QQ15
 STA QQ15,X

 DEX                    ; Decrement the counter

 BPL TT81+2             ; Loop back up to the LDA instruction if we still have
                        ; more bytes to copy

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TT111
;       Type: Subroutine
;   Category: Universe
;    Summary: Set the current system to the nearest system to a point
;
; ------------------------------------------------------------------------------
;
; Given a set of galactic coordinates in (QQ9, QQ10), find the nearest system
; to this point in the galaxy, and set this as the currently selected system.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   QQ9                 The x-coordinate near which we want to find a system
;
;   QQ10                The y-coordinate near which we want to find a system
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   QQ8(1 0)            The distance from the current system to the nearest
;                       system to the original coordinates
;
;   QQ9                 The x-coordinate of the nearest system to the original
;                       coordinates
;
;   QQ10                The y-coordinate of the nearest system to the original
;                       coordinates
;
;   QQ15 to QQ15+5      The three 16-bit seeds of the nearest system to the
;                       original coordinates
;
;   ZZ                  The system number of the nearest system
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   TT111-1             Contains an RTS
;
;   readdistnce         Calculate the distance between the system with galactic
;                       coordinates (A, QQ15+1) and the system at (QQ0, QQ1),
;                       returning the result in QQ8(1 0)
;
; ******************************************************************************

.TT111

 JSR TT81               ; Set the seeds in QQ15 to those of system 0 in the
                        ; current galaxy (i.e. copy the seeds from QQ21 to QQ15)

                        ; We now loop through every single system in the galaxy
                        ; and check the distance from (QQ9, QQ10). We get the
                        ; galactic coordinates of each system from the system's
                        ; seeds, like this:
                        ;
                        ;   x = s1_hi (which is stored in QQ15+3)
                        ;   y = s0_hi (which is stored in QQ15+1)
                        ;
                        ; so the following loops through each system in the
                        ; galaxy in turn and calculates the distance between
                        ; (QQ9, QQ10) and (s1_hi, s0_hi) to find the closest one

 LDY #127               ; Set Y = T = 127 to hold the shortest distance we've
 STY T                  ; found so far, which we initially set to half the
                        ; distance across the galaxy, or 127, as our coordinate
                        ; system ranges from (0,0) to (255, 255)

 LDA #0                 ; Set A = U = 0 to act as a counter for each system in
 STA U                  ; the current galaxy, which we start at system 0 and
                        ; loop through to 255, the last system

.TT130

 LDA QQ15+3             ; Set A = s1_hi - QQ9, the horizontal distance between
 SEC                    ; (s1_hi, s0_hi) and (QQ9, QQ10)
 SBC QQ9

 BCS TT132              ; If a borrow didn't occur, i.e. s1_hi >= QQ9, then the
                        ; result is positive, so jump to TT132 and skip the
                        ; following two instructions

 EOR #$FF               ; Otherwise negate the result in A, so A is always
 ADC #1                 ; positive (i.e. A = |s1_hi - QQ9|)

.TT132

 LSR A                  ; Set S = A / 2
 STA S                  ;       = |s1_hi - QQ9| / 2

 LDA QQ15+1             ; Set A = s0_hi - QQ10, the vertical distance between
 SEC                    ; (s1_hi, s0_hi) and (QQ9, QQ10)
 SBC QQ10

 BCS TT134              ; If a borrow didn't occur, i.e. s0_hi >= QQ10, then the
                        ; result is positive, so jump to TT134 and skip the
                        ; following two instructions

 EOR #$FF               ; Otherwise negate the result in A, so A is always
 ADC #1                 ; positive (i.e. A = |s0_hi - QQ10|)

.TT134

 LSR A                  ; Set A = S + A / 2
 CLC                    ;       = |s1_hi - QQ9| / 2 + |s0_hi - QQ10| / 2
 ADC S                  ;
                        ; So A now contains the sum of the horizontal and
                        ; vertical distances, both divided by 2 so the result
                        ; fits into one byte, and although this doesn't contain
                        ; the actual distance between the systems, it's a good
                        ; enough approximation to use for comparing distances

 CMP T                  ; If A >= T, then this system's distance is bigger than
 BCS TT135              ; our "minimum distance so far" stored in T, so it's no
                        ; closer than the systems we have already found, so
                        ; skip to TT135 to move on to the next system

 STA T                  ; This system is the closest to (QQ9, QQ10) so far, so
                        ; update T with the new "distance" approximation

 LDX #5                 ; As this system is the closest we have found yet, we
                        ; want to store the system's seeds in case it ends up
                        ; being the closest of all, so we set up a counter in X
                        ; to copy six bytes (for three 16-bit numbers)

.TT136

 LDA QQ15,X             ; Copy the X-th byte in QQ15 to the X-th byte in QQ19,
 STA QQ19,X             ; where QQ15 contains the seeds for the system we just
                        ; found to be the closest so far, and QQ19 is temporary
                        ; storage

 DEX                    ; Decrement the counter

 BPL TT136              ; Loop back to TT136 if we still have more bytes to
                        ; copy

 LDA U                  ; Store the system number U in ZZ, so when we are done
 STA ZZ                 ; looping through all the candidates, the winner's
                        ; number will be in ZZ

.TT135

 JSR TT20               ; We want to move on to the next system, so call TT20
                        ; to twist the three 16-bit seeds in QQ15

 INC U                  ; Increment the system counter in U

 BNE TT130              ; If U > 0 then we haven't done all 256 systems yet, so
                        ; loop back up to TT130

                        ; We have now finished checking all the systems in the
                        ; galaxy, and the seeds for the closest system are in
                        ; QQ19, so now we want to copy these seeds to QQ15,
                        ; to set the selected system to this closest system

 LDX #5                 ; So we set up a counter in X to copy six bytes (for
                        ; three 16-bit numbers)

.TT137

 LDA QQ19,X             ; Copy the X-th byte in QQ19 to the X-th byte in QQ15
 STA QQ15,X

 DEX                    ; Decrement the counter

 BPL TT137              ; Loop back to TT137 if we still have more bytes to
                        ; copy

 LDA QQ15+1             ; The y-coordinate of the system described by the seeds
 STA QQ10               ; in QQ15 is in QQ15+1 (s0_hi), so we copy this to QQ10
                        ; as this is where we store the selected system's
                        ; y-coordinate

 LDA QQ15+3             ; The x-coordinate of the system described by the seeds
 STA QQ9                ; in QQ15 is in QQ15+3 (s1_hi), so we copy this to QQ9
                        ; as this is where we store the selected system's
                        ; x-coordinate

                        ; We have now found the closest system to (QQ9, QQ10)
                        ; and have set it as the selected system, so now we
                        ; need to work out the distance between the selected
                        ; system and the current system

.readdistnce

 SEC                    ; Set A = QQ9 - QQ0, the horizontal distance between
 SBC QQ0                ; the selected system's x-coordinate (QQ9) and the
                        ; current system's x-coordinate (QQ0)

 BCS TT139              ; If a borrow didn't occur, i.e. QQ9 >= QQ0, then the
                        ; result is positive, so jump to TT139 and skip the
                        ; following two instructions

 EOR #$FF               ; Otherwise negate the result in A, so A is always
 ADC #1                 ; positive (i.e. A = |QQ9 - QQ0|)

                        ; A now contains the difference between the two
                        ; systems' x-coordinates, with the sign removed. We
                        ; will refer to this as the x-delta ("delta" means
                        ; change or difference in maths)

.TT139

 JSR SQUA2              ; Set (A P) = A * A
                        ;           = |QQ9 - QQ0| ^ 2
                        ;           = x_delta ^ 2

 STA K+1                ; Store (A P) in K(1 0)
 LDA P
 STA K

 LDA QQ15+1             ; Set A = QQ15+1 - QQ1, the vertical distance between
;LDA QQ10               ; the selected system's y-coordinate (QQ15+1) and the
 SEC                    ; current system's y-coordinate (QQ1)
 SBC QQ1                ;
                        ; The LDA instruction is commented out in the original
                        ; source

 BCS TT141              ; If a borrow didn't occur, i.e. QQ10 >= QQ1, then the
                        ; result is positive, so jump to TT141 and skip the
                        ; following two instructions

 EOR #$FF               ; Otherwise negate the result in A, so A is always
 ADC #1                 ; positive (i.e. A = |QQ10 - QQ1|)

.TT141

 LSR A                  ; Set A = A / 2

                        ; A now contains the difference between the two
                        ; systems' y-coordinates, with the sign removed, and
                        ; halved. We halve the value because the galaxy in
                        ; in Elite is rectangular rather than square, and is
                        ; twice as wide (x-axis) as it is high (y-axis), so to
                        ; get a distance that matches the shape of the
                        ; long-range galaxy chart, we need to halve the
                        ; distance between the vertical y-coordinates. We will
                        ; refer to this as the y-delta

 JSR SQUA2              ; Set (A P) = A * A
                        ;           = (|QQ10 - QQ1| / 2) ^ 2
                        ;           = y_delta ^ 2

                        ; By this point we have the following results:
                        ;
                        ;   K(1 0) = x_delta ^ 2
                        ;    (A P) = y_delta ^ 2
                        ;
                        ; so to find the distance between the two points, we
                        ; can use Pythagoras - so first we need to add the two
                        ; results together, and then take the square root

 PHA                    ; Store the high byte of the y-axis value on the stack,
                        ; so we can use A for another purpose

 LDA P                  ; Set Q = P + K, which adds the low bytes of the two
 CLC                    ; calculated values
 ADC K
 STA Q

 PLA                    ; Restore the high byte of the y-axis value from the
                        ; stack into A again

 ADC K+1                ; Set A = A + K+1, which adds the high bytes of the two
                        ; calculated values

 BCC P%+4               ; If the above addition overflowed, set A = 255
 LDA #255

 STA R                  ; Store A in R, so we now have R = A + K+1, and:
                        ;
                        ;   (R Q) = K(1 0) + (A P)
                        ;         = (x_delta ^ 2) + (y_delta ^ 2)

 JSR LL5                ; Set Q = SQRT(R Q), so Q now contains the distance
                        ; between the two systems, in terms of coordinates

                        ; We now store the distance to the selected system * 4
                        ; in the two-byte location QQ8, by taking (0 Q) and
                        ; shifting it left twice, storing it in QQ8(1 0)

 LDA Q                  ; First we shift the low byte left by setting
 ASL A                  ; A = Q * 2, with bit 7 of A going into the C flag

 LDX #0                 ; Now we set the high byte in QQ8+1 to 0 and rotate
 STX QQ8+1              ; the C flag into bit 0 of QQ8+1
 ROL QQ8+1

 ASL A                  ; And then we repeat the shift left of (QQ8+1 A)
 ROL QQ8+1

 STA QQ8                ; And store A in the low byte, QQ8, so QQ8(1 0) now
                        ; contains Q * 4. Given that the width of the galaxy is
                        ; 256 in coordinate terms, the width of the galaxy
                        ; would be 1024 in the units we store in QQ8

 JMP TT24               ; Call TT24 to calculate system data from the seeds in
                        ; QQ15 and store them in the relevant locations, so our
                        ; new selected system is fully set up, and return from
                        ; the subroutine using a tail call

; ******************************************************************************
;
;       Name: dockEd
;       Type: Subroutine
;   Category: Flight
;    Summary: Print a message to say there is no hyperspacing allowed inside the
;             station
;
; ------------------------------------------------------------------------------
;
; Print "Docked" at the bottom of the screen to indicate we can't hyperspace
; when docked.
;
; ******************************************************************************

.dockEd

 JSR CLYNS              ; Clear the bottom three text rows of the upper screen,
                        ; and move the text cursor to column 1 on row 21, i.e.
                        ; the start of the top row of the three bottom rows

 LDA #15                ; Move the text cursor to column 15
 JSR DOXC

;LDA #RED               ; These instructions are commented out in the original
;JSR DOCOL              ; source (they are left over from the 6502 Second
                        ; Processor version of Elite and would change the colour
                        ; to red)

 LDA #205               ; Print extended token 205 ("DOCKED") and return from
 JMP DETOK              ; the subroutine using a tail call

; ******************************************************************************
;
;       Name: hyp
;       Type: Subroutine
;   Category: Flight
;    Summary: Start the hyperspace process
;
; ------------------------------------------------------------------------------
;
; Called when "H" or "G" is pressed during flight. Checks the following:
;
;   * We are in space
;
;   * We are not already in a hyperspace countdown
;
; If "G" is being pressed, we jump to Ghy to engage the galactic hyperdrive,
; otherwise we check that:
;
;   * The selected system is not the current system
;
;   * We have enough fuel to make the jump
;
; and if all the pre-jump checks are passed, we print the destination on-screen
; and start the countdown.
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   TTX111              Used to rejoin this routine from the call to TTX110
;
; ******************************************************************************

.hyp

 LDA QQ12               ; If we are docked (QQ12 = $FF) then jump to dockEd to
 BNE dockEd             ; print an error message and return from the subroutine
                        ; using a tail call (as we can't hyperspace when docked)

 LDA QQ22+1             ; Fetch QQ22+1, which contains the number that's shown
                        ; on-screen during hyperspace countdown

 BEQ P%+3               ; If it is zero, skip the next instruction

 RTS                    ; The count is non-zero, so return from the subroutine

;LDA #CYAN              ; These instructions are commented out in the original
;JSR DOCOL              ; source (they are left over from the 6502 Second
                        ; Processor version of Elite and would change the colour
                        ; to cyan)

 LDA KL                 ; If "G" is being pressed, then the galactic hyperdrive
 CMP #'G'               ; has been activated, so jump to Ghy to process it
 BEQ Ghy

 LDA QQ11               ; If the current view is 0 (i.e. the space view) then
 BEQ TTX110             ; jump to TTX110, which calls TT111 to set the current
                        ; system to the nearest system to (QQ9, QQ10), and jumps
                        ; back into this routine at TTX111 below

 AND #%11000000         ; If either bit 6 or 7 of the view type is set - so
 BNE P%+3               ; this is either the Short-range or Long-range Chart -
                        ; then skip the following instruction

 RTS                    ; This is not a chart view, so return from the
                        ; subroutine

 JSR hm                 ; This is a chart view, so call hm to redraw the chart
                        ; crosshairs

.TTX111

                        ; If we get here then the current view is either the
                        ; space view or a chart

 LDA QQ8                ; If either byte of the distance to the selected system
 ORA QQ8+1              ; in QQ8 are zero, skip the next instruction to make a
 BNE P%+3               ; copy of the destination seeds in safehouse

 RTS                    ; The selected system is the same as the current system,
                        ; so return from the subroutine

 LDX #5                 ; We now want to copy those seeds into safehouse, so we
                        ; so set a counter in X to copy 6 bytes

.sob

 LDA QQ15,X             ; Copy the X-th byte of QQ15 into the X-th byte of
 STA safehouse,X        ; safehouse

 DEX                    ; Decrement the loop counter

 BPL sob                ; Loop back to copy the next byte until we have copied
                        ; all six seed bytes

 LDA #7                 ; ???
 STA XC
 LDA #22
 LDY text
 BMI P%+4
 LDA #16
 STA YC

 LDA #0                 ; Set QQ17 = 0 to switch to ALL CAPS
 STA QQ17

 LDA #189               ; Print recursive token 29 ("HYPERSPACE ")
 JSR TT27

 LDA QQ8+1              ; If the high byte of the distance to the selected
 BNE goTT147            ; system in QQ8 is > 0, then it is definitely too far to
                        ; jump (as our maximum range is 7.0 light years, or a
                        ; value of 70 in QQ8(1 0)), so jump to TT147 via goTT147
                        ; to print "RANGE?" and return from the subroutine using
                        ; a tail call

 LDA QQ14               ; Fetch our current fuel level from Q114 into A

 CMP QQ8                ; If our fuel reserves are greater than or equal to the
 BCS P%+5               ; distance to the selected system, then we have enough
                        ; fuel for this jump, so skip the following instruction
                        ; to start the hyperspace countdown

.goTT147

 JMP TT147              ; We don't have enough fuel to reach the destination, so
                        ; jump to TT147 to print "RANGE?" and return from the
                        ; subroutine using a tail call

 LDA #'-'               ; Print a hyphen
 JSR TT27

 JSR cpl                ; Call cpl to print the name of the selected system

                        ; Fall through into wW to start the hyperspace countdown

; ******************************************************************************
;
;       Name: wW
;       Type: Subroutine
;   Category: Flight
;    Summary: Start a hyperspace countdown
;
; ------------------------------------------------------------------------------
;
; Start the hyperspace countdown (for both inter-system hyperspace and the
; galactic hyperdrive).
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   wW2                 Start the hyperspace countdown, starting the countdown
;                       from the value in A
;
; ******************************************************************************

.wW

 LDA #15                ; The hyperspace countdown starts from 15, so set A to
                        ; 15 so we can set the two hyperspace counters

.wW2

 STA QQ22+1             ; Set the number in QQ22+1 to A, which is the number
                        ; that's shown on-screen during the hyperspace countdown

 STA QQ22               ; Set the number in QQ22 to 15, which is the internal
                        ; counter that counts down by 1 each iteration of the
                        ; main game loop, and each time it reaches zero, the
                        ; on-screen counter gets decremented, and QQ22 gets set
                        ; to 5, so setting QQ22 to 15 here makes the first tick
                        ; of the hyperspace counter longer than subsequent ticks

 TAX                    ; Print the 8-bit number in X (i.e. 15) at text location
 JMP ee3                ; (0, 1), padded to 5 digits, so it appears in the top
                        ; left corner of the screen, and return from the
                        ; subroutine using a tail call

;.hy5                   ; This instruction and the hy5 label are commented out
;RTS                    ; in the original - they can actually be found at the
                        ; end of the jmp routine below, so perhaps this is where
                        ; they were originally, but the authors realised they
                        ; could save a byte by using a tail call instead of an
                        ; RTS?

; ******************************************************************************
;
;       Name: TTX110
;       Type: Subroutine
;   Category: Flight
;    Summary: Set the current system to the nearest system and return to hyp
;
; ******************************************************************************

.TTX110

                        ; This routine is only called from the hyp routine, and
                        ; it jumps back into hyp at label TTX111

 JSR TT111              ; Call TT111 to set the current system to the nearest
                        ; system to (QQ9, QQ10), and put the seeds of the
                        ; nearest system into QQ15 to QQ15+5

 JMP TTX111             ; Return to TTX111 in the hyp routine

; ******************************************************************************
;
;       Name: Ghy
;       Type: Subroutine
;   Category: Flight
;    Summary: Perform a galactic hyperspace jump
;  Deep dive: Twisting the system seeds
;             Galaxy and system seeds
;
; ------------------------------------------------------------------------------
;
; Engage the galactic hyperdrive. Called from the hyp routine above if CTRL-H is
; being pressed.
;
; This routine also updates the galaxy seeds to point to the next galaxy. Using
; a galactic hyperdrive rotates each seed byte to the left, rolling each byte
; left within itself like this:
;
;   01234567 -> 12345670
;
; to get the seeds for the next galaxy. So after 8 galactic jumps, the seeds
; roll round to those of the first galaxy again.
;
; We always arrive in a new galaxy at galactic coordinates (96, 96), and then
; find the nearest system and set that as our location.
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   zZ+1                Contains an RTS
;
; ******************************************************************************

.Ghy

 LDX GHYP               ; Fetch GHYP, which tells us whether we own a galactic
 BEQ zZ+1               ; hyperdrive, and if it is zero, which means we don't,
                        ; return from the subroutine (as zZ+1 contains an RTS)

 INX                    ; We own a galactic hyperdrive, so X is $FF, so this
                        ; instruction sets X = 0

;STX QQ8                ; These instructions are commented out in the original
;STX QQ8+1              ; source

 STX GHYP               ; The galactic hyperdrive is a one-use item, so set GHYP
                        ; to 0 so we no longer have one fitted

 STX FIST               ; Changing galaxy also clears our criminal record, so
                        ; set our legal status in FIST to 0 ("clean")

 LDA #2                 ; Call wW2 with A = 2 to start the hyperspace countdown,
 JSR wW2                ; but starting the countdown from 2

 LDX #5                 ; To move galaxy, we rotate the galaxy's seeds left, so
                        ; set a counter in X for the 6 seed bytes

 INC GCNT               ; Increment the current galaxy number in GCNT

 LDA GCNT               ; Clear bit 3 of GCNT, so we jump from galaxy 7 back
 AND #%11110111         ; to galaxy 0 (shown in-game as going from galaxy 8 back
 STA GCNT               ; to the starting point in galaxy 1). We also retain any
                        ; set bits in the high nibble, so if the galaxy number
                        ; is manually set to 16 or higher, it will stay high
                        ; (though the high nibble doesn't seem to get set by
                        ; the game at any point, so it isn't clear what this is
                        ; for, though Lave in galaxy 16 does show a unique
                        ; system description override, so something is going on
                        ; here...)

.G1

 LDA QQ21,X             ; Load the X-th seed byte into A

 ASL A                  ; Set the C flag to bit 7 of the seed

 ROL QQ21,X             ; Rotate the seed in memory, which will add bit 7 back
                        ; in as bit 0, so this rolls the seed around on itself

 DEX                    ; Decrement the counter

 BPL G1                 ; Loop back for the next seed byte, until we have
                        ; rotated them all

;JSR DORND              ; This instruction is commented out in the original
                        ; source, and would set A and X to random numbers, so
                        ; perhaps the original plan was to arrive in each new
                        ; galaxy in a random place?

.zZ

 LDA #96                ; Set (QQ9, QQ10) to (96, 96), which is where we always
 STA QQ9                ; arrive in a new galaxy (the selected system will be
 STA QQ10               ; set to the nearest actual system later on)

 JSR TT110              ; Call TT110 to show the front space view

 JSR TT111              ; Call TT111 to set the current system to the nearest
                        ; system to (QQ9, QQ10), and put the seeds of the
                        ; nearest system into QQ15 to QQ15+5
                        ;
                        ; This call fixes a bug in the cassette version, where
                        ; the galactic hyperdrive will take us to coordinates
                        ; (96, 96) in the new galaxy, even if there isn't
                        ; actually a system there, so if we jump when we are
                        ; low on fuel, it is possible to get stuck in the
                        ; middle of nowhere when changing galaxy
                        ;
                        ; This call sets the current system correctly, so we
                        ; always arrive at the nearest system to (96, 96)

 LDX #5                 ; We now want to copy those seeds into safehouse, so we
                        ; so set a counter in X to copy 6 bytes

.dumdeedum

 LDA QQ15,X             ; Copy the X-th byte of QQ15 into the X-th byte of
 STA safehouse,X        ; safehouse

 DEX                    ; Decrement the loop counter

 BPL dumdeedum          ; Loop back to copy the next byte until we have copied
                        ; all six seed bytes

 LDX #0                 ; Set the distance to the selected system in QQ8(1 0)
 STX QQ8                ; to 0
 STX QQ8+1

 LDA #116               ; Print recursive token 116 (GALACTIC HYPERSPACE ")
 JSR MESS               ; as an in-flight message

                        ; Fall through into jmp to set the system to the
                        ; current system and return from the subroutine there

; ******************************************************************************
;
;       Name: jmp
;       Type: Subroutine
;   Category: Universe
;    Summary: Set the current system to the selected system
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   (QQ0, QQ1)          The galactic coordinates of the new system
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   hy5                 Contains an RTS
;
; ******************************************************************************

.jmp

 LDA QQ9                ; Set the current system's galactic x-coordinate to the
 STA QQ0                ; x-coordinate of the selected system

 LDA QQ10               ; Set the current system's galactic y-coordinate to the
 STA QQ1                ; y-coordinate of the selected system

.hy5

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: ee3
;       Type: Subroutine
;   Category: Flight
;    Summary: Print the hyperspace countdown in the top-left of the screen
;
; ------------------------------------------------------------------------------
;
; 5 digits, left-padding with spaces for numbers with fewer than 3 digits (so
; numbers < 10000 are right-aligned), with no decimal point.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The number to print
;
; ******************************************************************************

.ee3

;LDA #RED               ; These instructions are commented out in the original
;JSR DOCOL              ; source (they are left over from the 6502 Second
                        ; Processor version of Elite and would change the colour
                        ; to red)

 LDA #1                 ; Move the text cursor to column 1 on row 1
 JSR DOXC
 JSR DOYC

 LDY #0                 ; Set Y = 0 for the high byte in pr6

 CLC                    ; Call TT11 to print X to 3 digits with no decimal point
 LDA #3                 ; and return from the subroutine using a tail call
 JMP TT11

; ******************************************************************************
;
;       Name: pr6
;       Type: Subroutine
;   Category: Text
;    Summary: Print 16-bit number, left-padded to 5 digits, no point
;
; ------------------------------------------------------------------------------
;
; Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
; numbers with fewer than 3 digits (so numbers < 10000 are right-aligned),
; with no decimal point.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The low byte of the number to print
;
;   Y                   The high byte of the number to print
;
; ******************************************************************************

.pr6

 CLC                    ; Do not display a decimal point when printing

                        ; Fall through into pr5 to print X to 5 digits

; ******************************************************************************
;
;       Name: pr5
;       Type: Subroutine
;   Category: Text
;    Summary: Print a 16-bit number, left-padded to 5 digits, and optional point
;
; ------------------------------------------------------------------------------
;
; Print the 16-bit number in (Y X) to 5 digits, left-padding with spaces for
; numbers with fewer than 3 digits (so numbers < 10000 are right-aligned).
; Optionally include a decimal point.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The low byte of the number to print
;
;   Y                   The high byte of the number to print
;
;   C flag              If set, include a decimal point
;
; ******************************************************************************

.pr5

 LDA #5                 ; Set the number of digits to print to 5

 JMP TT11               ; Call TT11 to print (Y X) to 5 digits and return from
                        ; the subroutine using a tail call

; ******************************************************************************
;
;       Name: TT147
;       Type: Subroutine
;   Category: Flight
;    Summary: Print an error when a system is out of hyperspace range
;
; ------------------------------------------------------------------------------
;
; Print "RANGE?" for when the hyperspace distance is too far
;
; ******************************************************************************

.TT147

 LDA #202               ; Load A with token 42 ("RANGE") and fall through into
                        ; prq to print it, followed by a question mark

; ******************************************************************************
;
;       Name: prq
;       Type: Subroutine
;   Category: Text
;    Summary: Print a text token followed by a question mark
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The text token to be printed
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   prq+3               Print a question mark
;
; ******************************************************************************

.prq

 JSR TT27               ; Print the text token in A

 LDA #'?'               ; Print a question mark and return from the
 JMP TT27               ; subroutine using a tail call

; ******************************************************************************
;
;       Name: TT151
;       Type: Subroutine
;   Category: Market
;    Summary: Print the name, price and availability of a market item
;  Deep dive: Market item prices and availability
;             Galaxy and system seeds
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The number of the market item to print, 0-16 (see QQ23
;                       for details of item numbers)
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   QQ19+1              Byte #1 from the market prices table for this item
;
;   QQ24                The item's price / 4
;
;   QQ25                The item's availability
;
; ******************************************************************************

.TT151q

                        ; We jump here from below if we are in witchspace

 PLA                    ; Restore the item number from the stack

 RTS                    ; Return from the subroutine

.TT151

 PHA                    ; Store the item number on the stack and in QQ19+4
 STA QQ19+4

 ASL A                  ; Store the item number * 4 in QQ19, so this will act as
 ASL A                  ; an index into the market prices table at QQ23 for this
 STA QQ19               ; item (as there are four bytes per item in the table)

 LDA MJ                 ; If we are in witchspace, we can't trade items, so jump
 BNE TT151q             ; up to TT151q to return from the subroutine

 LDA #1                 ; Set A = 1 to denote column 1

IF _IB_DISK

 STA XC                 ; Move the text cursor to column 1, for the item's name

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 JSR DOXC               ; Move the text cursor to column 1, for the item's name

ENDIF

 PLA                    ; Restore the item number

 ADC #208               ; Print recursive token 48 + A, which will be in the
 JSR TT27               ; range 48 ("FOOD") to 64 ("ALIEN ITEMS"), so this
                        ; prints the item's name

 LDA #14                ; Move the text cursor to column 14, for the price
 STA XC

 LDX QQ19               ; Fetch byte #1 from the market prices table (units and
 LDA QQ23+1,X           ; economic_factor) for this item and store in QQ19+1
 STA QQ19+1

 LDA QQ26               ; Fetch the random number for this system visit and
 AND QQ23+3,X           ; AND with byte #3 from the market prices table (mask)
                        ; to give:
                        ;
                        ;   A = random AND mask

 CLC                    ; Add byte #0 from the market prices table (base_price),
 ADC QQ23,X             ; so we now have:
 STA QQ24               ;
                        ;   A = base_price + (random AND mask)

 JSR TT152              ; Call TT152 to print the item's unit ("t", "kg" or
                        ; "g"), padded to a width of two characters

 JSR var                ; Call var to set QQ19+3 = economy * |economic_factor|
                        ; (and set the availability of alien items to 0)

 LDA QQ19+1             ; Fetch the byte #1 that we stored above and jump to
 BMI TT155              ; TT155 if it is negative (i.e. if the economic_factor
                        ; is negative)

 LDA QQ24               ; Set A = QQ24 + QQ19+3
 ADC QQ19+3             ;
                        ;       = base_price + (random AND mask)
                        ;         + (economy * |economic_factor|)
                        ;
                        ; which is the result we want, as the economic_factor
                        ; is positive

 JMP TT156              ; Jump to TT156 to multiply the result by 4

.TT155

 LDA QQ24               ; Set A = QQ24 - QQ19+3
 SEC                    ;
 SBC QQ19+3             ;       = base_price + (random AND mask)
                        ;         - (economy * |economic_factor|)
                        ;
                        ; which is the result we want, as economic_factor
                        ; is negative

.TT156

 STA QQ24               ; Store the result in QQ24 and P
 STA P

 LDA #0                 ; Set A = 0 and call GC2 to calculate (Y X) = (A P) * 4,
 JSR GC2                ; which is the same as (Y X) = P * 4 because A = 0

 SEC                    ; We now have our final price, * 10, so we can call pr5
 JSR pr5                ; to print (Y X) to 5 digits, including a decimal
                        ; point, as the C flag is set

 LDY QQ19+4             ; We now move on to availability, so fetch the market
                        ; item number that we stored in QQ19+4 at the start

 LDA #5                 ; Set A to 5 so we can print the availability to 5
                        ; digits (right-padded with spaces)

 LDX AVL,Y              ; Set X to the item's availability, which is given in
                        ; the AVL table

 STX QQ25               ; Store the availability in QQ25

 CLC                    ; Clear the C flag

 BEQ TT172              ; If none are available, jump to TT172 to print a tab
                        ; and a "-"

 JSR pr2+2              ; Otherwise print the 8-bit number in X to 5 digits,
                        ; right-aligned with spaces. This works because we set
                        ; A to 5 above, and we jump into the pr2 routine just
                        ; after the first instruction, which would normally
                        ; set the number of digits to 3

 JMP TT152              ; Print the unit ("t", "kg" or "g") for the market item,
                        ; with a following space if required to make it two
                        ; characters long, and return from the subroutine using
                        ; a tail call

.TT172

 LDA #25                ; Set A = 25 to denote column 25

IF _IB_DISK

 STA XC                 ; Move the text cursor to column 25

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 JSR DOXC               ; Move the text cursor to column 25

ENDIF

 LDA #'-'               ; Print a "-" character by jumping to TT162+2, which
 BNE TT162+2            ; contains JMP TT27 (this BNE is effectively a JMP as A
                        ; will never be zero), and return from the subroutine
                        ; using a tail call

; ******************************************************************************
;
;       Name: TT152
;       Type: Subroutine
;   Category: Market
;    Summary: Print the unit ("t", "kg" or "g") for a market item
;
; ------------------------------------------------------------------------------
;
; Print the unit ("t", "kg" or "g") for the market item whose byte #1 from the
; market prices table is in QQ19+1, right-padded with spaces to a width of two
; characters (so that's "t ", "kg" or "g ").
;
; ******************************************************************************

.TT152

 LDA QQ19+1             ; Fetch the economic_factor from QQ19+1

 AND #96                ; If bits 5 and 6 are both clear, jump to TT160 to
 BEQ TT160              ; print "t" for tonne, followed by a space, and return
                        ; from the subroutine using a tail call

 CMP #32                ; If bit 5 is set, jump to TT161 to print "kg" for
 BEQ TT161              ; kilograms, and return from the subroutine using a tail
                        ; call

 JSR TT16a              ; Otherwise call TT16a to print "g" for grams, and fall
                        ; through into TT162 to print a space and return from
                        ; the subroutine

; ******************************************************************************
;
;       Name: TT162
;       Type: Subroutine
;   Category: Text
;    Summary: Print a space
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   TT162+2             Jump to TT27 to print the text token in A
;
; ******************************************************************************

.TT162

 LDA #' '               ; Load a space character into A

 JMP TT27               ; Print the text token in A and return from the
                        ; subroutine using a tail call

; ******************************************************************************
;
;       Name: TT160
;       Type: Subroutine
;   Category: Market
;    Summary: Print "t" (for tonne) and a space
;
; ******************************************************************************

.TT160

 LDA #'t'               ; Load a "t" character into A

 JSR TT26               ; Print the character, using TT216 so that it doesn't
                        ; change the character case

 BCC TT162              ; Jump to TT162 to print a space and return from the
                        ; subroutine using a tail call (this BCC is effectively
                        ; a JMP as the C flag is cleared by TT26)

; ******************************************************************************
;
;       Name: TT161
;       Type: Subroutine
;   Category: Market
;    Summary: Print "kg" (for kilograms)
;
; ******************************************************************************

.TT161

 LDA #'k'               ; Load a "k" character into A

 JSR TT26               ; Print the character, using TT216 so that it doesn't
                        ; change the character case, and fall through into
                        ; TT16a to print a "g" character

; ******************************************************************************
;
;       Name: TT16a
;       Type: Subroutine
;   Category: Market
;    Summary: Print "g" (for grams)
;
; ******************************************************************************

.TT16a

 LDA #'g'               ; Load a "g" character into A

 JMP TT26               ; Print the character, using TT216 so that it doesn't
                        ; change the character case, and return from the
                        ; subroutine using a tail call

; ******************************************************************************
;
;       Name: TT163
;       Type: Subroutine
;   Category: Market
;    Summary: Print the headers for the table of market prices
;
; ------------------------------------------------------------------------------
;
; Print the column headers for the prices table in the Buy Cargo and Market
; Price screens.
;
; ******************************************************************************

.TT163

 LDA #17                ; Set A = 17 to denote column 17

IF _IB_DISK

 STA XC                 ; Move the text cursor in XC to column 17

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 JSR DOXC               ; Move the text cursor in XC to column 17

ENDIF

 LDA #255               ; Print recursive token 95 token ("UNIT  QUANTITY
 BNE TT162+2            ; {crlf} PRODUCT   UNIT PRICE FOR SALE{crlf}{lf}") by
                        ; jumping to TT162+2, which contains JMP TT27 (this BNE
                        ; is effectively a JMP as A will never be zero), and
                        ; return from the subroutine using a tail call

; ******************************************************************************
;
;       Name: TT167
;       Type: Subroutine
;   Category: Market
;    Summary: Show the Market Price screen
;
; ******************************************************************************

.TT167

 LDA #16                ; Clear the top part of the screen, draw a white border,
 JSR TRADEMODE          ; and set up a printable trading screen with a view type
                        ; in QQ11 of 32 (Market Price screen)

 LDA #5                 ; Move the text cursor to column 5
 STA XC

 LDA #167               ; Print recursive token 7 ("{current system name} MARKET
 JSR NLIN3              ; PRICES") and draw a horizontal line at pixel row 19
                        ; to box in the title

 LDA #3                 ; Move the text cursor to row 3
 STA YC

 JSR TT163              ; Print the column headers for the prices table

 LDA #6                 ; Move the text cursor to row 6
 STA YC

 LDA #0                 ; We're going to loop through all the available market
 STA QQ29               ; items, so we set up a counter in QQ29 to denote the
                        ; current item and start it at 0

.TT168

 LDX #%10000000         ; Set bit 7 of QQ17 to switch to Sentence Case, with the
 STX QQ17               ; next letter in capitals

 JSR TT151              ; Call TT151 to print the item name, market price and
                        ; availability of the current item, and set QQ24 to the
                        ; item's price / 4, QQ25 to the quantity available and
                        ; QQ19+1 to byte #1 from the market prices table for
                        ; this item

 INC YC                 ; Move the text cursor down one row

 INC QQ29               ; Increment QQ29 to point to the next item

 LDA QQ29               ; If QQ29 >= 17 then jump to TT168 as we have done the
 CMP #17                ; last item
 BCC TT168

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: var
;       Type: Subroutine
;   Category: Market
;    Summary: Calculate QQ19+3 = economy * |economic_factor|
;
; ------------------------------------------------------------------------------
;
; Set QQ19+3 = economy * |economic_factor|, given byte #1 of the market prices
; table for an item. Also sets the availability of alien items to 0.
;
; This routine forms part of the calculations for market item prices (TT151)
; and availability (GVL).
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   QQ19+1              Byte #1 of the market prices table for this market item
;                       (which contains the economic_factor in bits 0-5, and the
;                       sign of the economic_factor in bit 7)
;
; ******************************************************************************

.var

 LDA QQ19+1             ; Extract bits 0-5 from QQ19+1 into A, to get the
 AND #31                ; economic_factor without its sign, in other words:
                        ;
                        ;   A = |economic_factor|

 LDY QQ28               ; Set Y to the economy byte of the current system

 STA QQ19+2             ; Store A in QQ19+2

 CLC                    ; Clear the C flag so we can do additions below

 LDA #0                 ; Set AVL+16 (availability of alien items) to 0,
 STA AVL+16             ; setting A to 0 in the process

.TT153

                        ; We now do the multiplication by doing a series of
                        ; additions in a loop, building the result in A. Each
                        ; loop adds QQ19+2 (|economic_factor|) to A, and it
                        ; loops the number of times given by the economy byte;
                        ; in other words, because A starts at 0, this sets:
                        ;
                        ;   A = economy * |economic_factor|

 DEY                    ; Decrement the economy in Y, exiting the loop when it
 BMI TT154              ; becomes negative

 ADC QQ19+2             ; Add QQ19+2 to A

 JMP TT153              ; Loop back to TT153 to do another addition

.TT154

 STA QQ19+3             ; Store the result in QQ19+3

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: hyp1
;       Type: Subroutine
;   Category: Universe
;    Summary: Process a jump to the system closest to (QQ9, QQ10)
;
; ------------------------------------------------------------------------------
;
; Do a hyperspace jump to the system closest to galactic coordinates
; (QQ9, QQ10), and set up the current system's state to those of the new system.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   (QQ0, QQ1)          The galactic coordinates of the new system
;
;   QQ2 to QQ2+6        The seeds of the new system
;
;   EV                  Set to 0
;
;   QQ28                The new system's economy
;
;   tek                 The new system's tech level
;
;   gov                 The new system's government
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   hyp1+3              Jump straight to the system at (QQ9, QQ10) without
;                       first calculating which system is closest. We do this
;                       if we already know that (QQ9, QQ10) points to a system
;
; ******************************************************************************

.hyp1

 JSR TT111              ; Select the system closest to galactic coordinates
                        ; (QQ9, QQ10)

 JSR jmp                ; Set the current system to the selected system

 LDX #5                 ; We now want to copy the seeds for the selected system
                        ; in QQ15 into QQ2, where we store the seeds for the
                        ; current system, so set up a counter in X for copying
                        ; 6 bytes (for three 16-bit seeds)

.TT112

 LDA safehouse,X        ; Copy the X-th byte in safehouse to the X-th byte in
 STA QQ2,X              ; QQ2

 DEX                    ; Decrement the counter

 BPL TT112              ; Loop back to TT112 if we still have more bytes to
                        ; copy

 INX                    ; Set X = 0 (as we ended the above loop with X = $FF)

 STX EV                 ; Set EV, the extra vessels spawning counter, to 0, as
                        ; we are entering a new system with no extra vessels
                        ; spawned

 LDA QQ3                ; Set the current system's economy in QQ28 to the
 STA QQ28               ; selected system's economy from QQ3

 LDA QQ5                ; Set the current system's tech level in tek to the
 STA tek                ; selected system's economy from QQ5

 LDA QQ4                ; Set the current system's government in gov to the
 STA gov                ; selected system's government from QQ4

; ******************************************************************************
;
;       Name: GVL
;       Type: Subroutine
;   Category: Universe
;    Summary: Calculate the availability of market items
;  Deep dive: Market item prices and availability
;             Galaxy and system seeds
;
; ------------------------------------------------------------------------------
;
; Calculate the availability for each market item and store it in AVL. This is
; called on arrival in a new system.
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   hyR                 Contains an RTS
;
; ******************************************************************************

.GVL

 JSR DORND              ; Set A and X to random numbers

 STA QQ26               ; Set QQ26 to the random byte that's used in the market
                        ; calculations

 LDX #0                 ; We are now going to loop through the market item
 STX XX4                ; availability table in AVL, so set a counter in XX4
                        ; (and X) for the market item number, starting with 0

.hy9

 LDA QQ23+1,X           ; Fetch byte #1 from the market prices table (units and
 STA QQ19+1             ; economic_factor) for item number X and store it in
                        ; QQ19+1

 JSR var                ; Call var to set QQ19+3 = economy * |economic_factor|
                        ; (and set the availability of alien items to 0)

 LDA QQ23+3,X           ; Fetch byte #3 from the market prices table (mask) and
 AND QQ26               ; AND with the random number for this system visit
                        ; to give:
                        ;
                        ;   A = random AND mask

 CLC                    ; Add byte #2 from the market prices table
 ADC QQ23+2,X           ; (base_quantity) so we now have:
                        ;
                        ;   A = base_quantity + (random AND mask)

 LDY QQ19+1             ; Fetch the byte #1 that we stored above and jump to
 BMI TT157              ; TT157 if it is negative (i.e. if the economic_factor
                        ; is negative)

 SEC                    ; Set A = A - QQ19+3
 SBC QQ19+3             ;
                        ;       = base_quantity + (random AND mask)
                        ;         - (economy * |economic_factor|)
                        ;
                        ; which is the result we want, as the economic_factor
                        ; is positive

 JMP TT158              ; Jump to TT158 to skip TT157

.TT157

 CLC                    ; Set A = A + QQ19+3
 ADC QQ19+3             ;
                        ;       = base_quantity + (random AND mask)
                        ;         + (economy * |economic_factor|)
                        ;
                        ; which is the result we want, as the economic_factor
                        ; is negative

.TT158

 BPL TT159              ; If A < 0, then set A = 0, so we don't have negative
 LDA #0                 ; availability

.TT159

 LDY XX4                ; Fetch the counter (the market item number) into Y

 AND #%00111111         ; Take bits 0-5 of A, i.e. A mod 64, and store this as
 STA AVL,Y              ; this item's availability in the Y=th byte of AVL, so
                        ; each item has a maximum availability of 63t

 INY                    ; Increment the counter into XX44, Y and A
 TYA
 STA XX4

 ASL A                  ; Set X = counter * 4, so that X points to the next
 ASL A                  ; item's entry in the four-byte market prices table,
 TAX                    ; ready for the next loop

 CMP #63                ; If A < 63, jump back up to hy9 to set the availability
 BCC hy9                ; for the next market item

.hyR

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: GTHG
;       Type: Subroutine
;   Category: Universe
;    Summary: Spawn a Thargoid ship and a Thargon companion
;  Deep dive: Fixing ship positions
;
; ******************************************************************************

.GTHG

 JSR Ze                 ; Call Ze to initialise INWK
                        ;
                        ; Note that because Ze uses the value of X returned by
                        ; DORND, and X contains the value of A returned by the
                        ; previous call to DORND, this does not set the new ship
                        ; to a totally random location. See the deep dive on
                        ; "Fixing ship positions" for details

 LDA #%11111111         ; Set the AI flag in byte #32 so that the ship has AI,
 STA INWK+32            ; is extremely and aggressively hostile, and has E.C.M.

 LDA #THG               ; Call NWSHP to add a new Thargoid ship to our local
 JSR NWSHP              ; bubble of universe

 LDA #TGL               ; Call NWSHP to add a new Thargon ship to our local
 JMP NWSHP              ; bubble of universe, and return from the subroutine
                        ; using a tail call

; ******************************************************************************
;
;       Name: MJP
;       Type: Subroutine
;   Category: Flight
;    Summary: Process a mis-jump into witchspace
;
; ------------------------------------------------------------------------------
;
; Process a mis-jump into witchspace (which happens very rarely). Witchspace has
; a strange, almost dust-free aspect to it, and it is populated by hostile
; Thargoids. Using our escape pod will be fatal, and our position on the
; galactic chart is in-between systems. It is a scary place...
;
; There is a 0.78% chance that this routine is called from TT18 instead of doing
; a normal hyperspace, or we can manually trigger a mis-jump by holding down
; CTRL after first enabling the "author display" configuration option ("X") when
; paused.
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   ptg                 Called when the user manually forces a mis-jump
;
;   RTS111              Contains an RTS
;
; ******************************************************************************

.ptg

 LSR COK                ; Set bit 0 of the competition flags in COK, so that the
 SEC                    ; competition code will include the fact that we have
 ROL COK                ; manually forced a mis-jump into witchspace

.MJP

;JSR CATLOD             ; This instruction is commented out in the original
                        ; source

 LDA #3                 ; Clear the top part of the screen, draw a white border,
 JSR TT66               ; and set the current view type in QQ11 to 3

 JSR LL164              ; Call LL164 to show the hyperspace tunnel and make the
                        ; hyperspace sound for a second time (as we already
                        ; called LL164 in TT18)

 JSR RES2               ; Reset a number of flight variables and workspaces, as
                        ; well as setting Y to $FF

 STY MJ                 ; Set the mis-jump flag in MJ to $FF, to indicate that
                        ; we are now in witchspace

.MJP1

 JSR GTHG               ; Call GTHG to spawn a Thargoid ship and a Thargon
                        ; companion

IF _IB_DISK OR _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES

 LDA #2                 ; Fetch the number of Thargoid ships from MANY+THG, and
 CMP MANY+THG           ; if it is less than or equal to 2, loop back to MJP1 to
 BCS MJP1               ; spawn another one, until we have three Thargoids

ELIF _SOURCE_DISK_CODE_FILES

 LDA #3                 ; Fetch the number of Thargoid ships from MANY+THG, and
 CMP MANY+THG           ; if it is greater than 3, loop back to MJP1 to spawn
 BCC MJP1               ; another one ???

ENDIF

 STA NOSTM              ; Set NOSTM (the maximum number of stardust particles)
                        ; to 3, so there are fewer bits of stardust in
                        ; witchspace (normal space has a maximum of 18)

 LDX #0                 ; Initialise the front space view
 JSR LOOK1

 LDA QQ1                ; Fetch the current system's galactic y-coordinate in
 EOR #%00011111         ; QQ1 and flip bits 0-5, so we end up somewhere in the
 STA QQ1                ; vicinity of our original destination, but above or
                        ; below it in the galactic chart

 RTS                    ; Return from the subroutine

.RTS111

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TT18
;       Type: Subroutine
;   Category: Flight
;    Summary: Try to initiate a jump into hyperspace
;
; ------------------------------------------------------------------------------
;
; Try to go through hyperspace. Called from TT102 in the main loop when the
; hyperspace countdown has finished.
;
; ******************************************************************************

.TT18

 LDA QQ14               ; Subtract the distance to the selected system (in QQ8)
 SEC                    ; from the amount of fuel in our tank (in QQ14) into A
 SBC QQ8

 BCS P%+4               ; If the subtraction didn't overflow, skip the next
                        ; instruction

 LDA #0                 ; The subtraction overflowed, so set A = 0 so we don't
                        ; end up with a negative amount of fuel

 STA QQ14               ; Store the updated fuel amount in QQ14

 LDA QQ11               ; If the current view is not a space view, jump to ee5
 BNE ee5                ; to skip the following

 JSR TT66               ; Clear the top part of the screen, draw a white border,
                        ; and set the current view type in QQ11 to 0 (space
                        ; view)

 JSR LL164              ; Call LL164 to show the hyperspace tunnel and make the
                        ; hyperspace sound

.ee5

 JSR RDKEY              ; ???
 CMP #9
 BNE nopatg

 LDA PATG               ; If the game is configured to show the author's names
                        ; on the start-up screen, then PATG will contain $FF,
                        ; otherwise it will be 0

 BMI ptg                ; We only get here if we are holding down ???
                        ; and author names are configured, which is what we have
                        ; to do in order to trigger a manual mis-jump, so jump
                        ; to ptg to do a mis-jump (ptg not only mis-jumps, but
                        ; updates the competition flags, so Acornsoft could tell
                        ; from the competition code whether this feature had
                        ; been used)

.nopatg

 JSR DORND              ; Set A and X to random numbers

 CMP #253               ; If A >= 253 (0.78% chance) then jump to MJP to trigger
 BCS MJP                ; a mis-jump into witchspace

;JSR TT111              ; This instruction is commented out in the original
                        ; source. It finds the closest system to coordinates
                        ; (QQ9, QQ10), but we don't need to do this as the
                        ; crosshairs will already be on a system by this point

 JSR hyp1+3             ; Jump straight to the system at (QQ9, QQ10) without
                        ; first calculating which system is closest

 JSR RES2               ; Reset a number of flight variables and workspaces

 JSR SOLAR              ; Halve our legal status, update the missile indicators,
                        ; and set up data blocks and slots for the planet and
                        ; sun

;JSR CATLOD             ; These instructions are commented out in the original
;JSR LOMOD              ; source

 LDA QQ11               ; If the current view in QQ11 is not a space view (0) or
 AND #%00111111         ; one of the charts (64 or 128), return from the
 BNE RTS111             ; subroutine (as RTS111 contains an RTS)

 JSR TTX66              ; Otherwise clear the screen and draw a white border

 LDA QQ11               ; If the current view is one of the charts, jump to
 BNE TT114              ; TT114 (from which we jump to the correct routine to
                        ; display the chart)

 INC QQ11               ; This is a space view, so increment QQ11 to 1

                        ; Fall through into TT110 to show the front space view

; ******************************************************************************
;
;       Name: TT110
;       Type: Subroutine
;   Category: Flight
;    Summary: Launch from a station or show the front space view
;
; ------------------------------------------------------------------------------
;
; Launch the ship (if we are docked), or show the front space view (if we are
; already in space).
;
; Called when the launch button is pressed while docked, after we arrive in a
; new galaxy, or after a hyperspace if the current view is a space view.
;
; ******************************************************************************

.TT110

 LDX QQ12               ; If we are not docked (QQ12 = 0) then jump to NLUNCH
 BEQ NLUNCH             ; to skip the launch tunnel and setup process

 JSR LAUN               ; Show the space station launch tunnel

 JSR RES2               ; Reset a number of flight variables and workspaces

 JSR TT111              ; Select the system closest to galactic coordinates
                        ; (QQ9, QQ10)

 INC INWK+8             ; Increment z_sign ready for the call to SOS, so the
                        ; planet appears at a z_sign of 1 in front of us when
                        ; we launch

 JSR SOS1               ; Call SOS1 to set up the planet's data block and add it
                        ; to FRIN, where it will get put in the first slot as
                        ; it's the first one to be added to our local bubble of
                        ; universe following the call to RES2 above

 LDA #128               ; For the space station, set z_sign to $80, so it's
 STA INWK+8             ; behind us ($80 is negative)

 INC INWK+7             ; And increment z_hi, so it's only just behind us

 JSR NWSPS              ; Add a new space station to our local bubble of
                        ; universe

 LDA #12                ; Set our launch speed in DELTA to 12
 STA DELTA

 JSR BAD                ; Call BAD to work out how much illegal contraband we
                        ; are carrying in our hold (A is up to 40 for a
                        ; standard hold crammed with contraband, up to 70 for
                        ; an extended cargo hold full of narcotics and slaves)

 ORA FIST               ; OR the value in A with our legal status in FIST to
                        ; get a new value that is at least as high as both
                        ; values, to reflect the fact that launching with a
                        ; hold full of contraband can only make matters worse

 STA FIST               ; Update our legal status with the new value

 LDA #255               ; Set the view type in QQ11 to 255
 STA QQ11

 JSR HFS1               ; Call HFS1 to draw 8 concentric rings to remove the
                        ; launch tunnel that we drew above

.NLUNCH

 LDX #0                 ; Set QQ12 to 0 to indicate we are not docked
 STX QQ12

 JMP LOOK1              ; Jump to LOOK1 to switch to the front view (X = 0),
                        ; returning from the subroutine using a tail call

; ******************************************************************************
;
;       Name: TT114
;       Type: Subroutine
;   Category: Charts
;    Summary: Display either the Long-range or Short-range Chart
;
; ------------------------------------------------------------------------------
;
; Display either the Long-range or Short-range Chart, depending on the current
; view setting. Called from TT18 once we know the current view is one of the
; charts.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The current view, loaded from QQ11
;
; ******************************************************************************

.TT114

 BMI TT115              ; If bit 7 of the current view is set (i.e. the view is
                        ; the Short-range Chart, 128), skip to TT115 below to
                        ; jump to TT23 to display the chart

 JMP TT22               ; Otherwise the current view is the Long-range Chart, so
                        ; jump to TT22 to display it

.TT115

 JMP TT23               ; Jump to TT23 to display the Short-range Chart

; ******************************************************************************
;
;       Name: LCASH
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Subtract an amount of cash from the cash pot
;
; ------------------------------------------------------------------------------
;
; Subtract (Y X) cash from the cash pot in CASH, but only if there is enough
; cash in the pot. As CASH is a four-byte number, this calculates:
;
;   CASH(0 1 2 3) = CASH(0 1 2 3) - (0 0 Y X)
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              If set, there was enough cash to do the subtraction
;
;                       If clear, there was not enough cash to do the
;                       subtraction
;
; ******************************************************************************

.LCASH

 STX T1                 ; Subtract the least significant bytes:
 LDA CASH+3             ;
 SEC                    ;   CASH+3 = CASH+3 - X
 SBC T1
 STA CASH+3

 STY T1                 ; Then the second most significant bytes:
 LDA CASH+2             ;
 SBC T1                 ;   CASH+2 = CASH+2 - Y
 STA CASH+2

 LDA CASH+1             ; Then the third most significant bytes (which are 0):
 SBC #0                 ;
 STA CASH+1             ;   CASH+1 = CASH+1 - 0

 LDA CASH               ; And finally the most significant bytes (which are 0):
 SBC #0                 ;
 STA CASH               ;   CASH = CASH - 0

 BCS TT113              ; If the C flag is set then the subtraction didn't
                        ; underflow, so the value in CASH is correct and we can
                        ; jump to TT113 to return from the subroutine with the
                        ; C flag set to indicate success (as TT113 contains an
                        ; RTS)

                        ; Otherwise we didn't have enough cash in CASH to
                        ; subtract (Y X) from it, so fall through into
                        ; MCASH to reverse the sum and restore the original
                        ; value in CASH, and returning with the C flag clear

; ******************************************************************************
;
;       Name: MCASH
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Add an amount of cash to the cash pot
;
; ------------------------------------------------------------------------------
;
; Add (Y X) cash to the cash pot in CASH. As CASH is a four-byte number, this
; calculates:
;
;   CASH(0 1 2 3) = CASH(0 1 2 3) + (Y X)
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   TT113               Contains an RTS
;
; ******************************************************************************

.MCASH

 TXA                    ; Add the least significant bytes:
 CLC                    ;
 ADC CASH+3             ;   CASH+3 = CASH+3 + X
 STA CASH+3

 TYA                    ; Then the second most significant bytes:
 ADC CASH+2             ;
 STA CASH+2             ;   CASH+2 = CASH+2 + Y

 LDA CASH+1             ; Then the third most significant bytes (which are 0):
 ADC #0                 ;
 STA CASH+1             ;   CASH+1 = CASH+1 + 0

 LDA CASH               ; And finally the most significant bytes (which are 0):
 ADC #0                 ;
 STA CASH               ;   CASH = CASH + 0

 CLC                    ; Clear the C flag, so if the above was done following
                        ; a failed LCASH call, the C flag correctly indicates
                        ; failure

.TT113

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: GCASH
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (Y X) = P * Q * 4
;
; ------------------------------------------------------------------------------
;
; Calculate the following multiplication of unsigned 8-bit numbers:
;
;   (Y X) = P * Q * 4
;
; ******************************************************************************

.GCASH

 JSR MULTU              ; Call MULTU to calculate (A P) = P * Q

; ******************************************************************************
;
;       Name: GC2
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (Y X) = (A P) * 4
;
; ------------------------------------------------------------------------------
;
; Calculate the following multiplication of unsigned 16-bit numbers:
;
;   (Y X) = (A P) * 4
;
; ******************************************************************************

.GC2

 ASL P                  ; Set (A P) = (A P) * 4
 ROL A
 ASL P
 ROL A

 TAY                    ; Set (Y X) = (A P)
 LDX P

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: EQSHP
;       Type: Subroutine
;   Category: Equipment
;    Summary: Show the Equip Ship screen
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   err                 Beep, pause and go to the docking bay (i.e. show the
;                       Status Mode screen)
;
;   pres                Given an item number A with the item name in recursive
;                       token Y, show an error to say that the item is already
;                       present, refund the cost of the item, and then beep and
;                       exit to the docking bay (i.e. show the Status Mode
;                       screen)
;
; ******************************************************************************

.bay

 JMP BAY                ; Go to the docking bay (i.e. show the Status Mode
                        ; screen)

.EQSHP

 LDA #32                ; Clear the top part of the screen, draw a white border,
 JSR TRADEMODE          ; and set up a printable trading screen with a view type
                        ; in QQ11 of 32 (Equip Ship screen)

 LDA #12                ; Sety A = 12 to denote column 12

IF _IB_DISK

 STA XC                 ; Move the text cursor to column 12

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 JSR DOXC               ; Move the text cursor to column 12

ENDIF

 LDA #207               ; Print recursive token 47 ("EQUIP") followed by a space
 JSR spc

 LDA #185               ; Print recursive token 25 ("SHIP") and draw a
 JSR NLIN3              ; horizontal line at pixel row 19 to box in the title

 LDA #%10000000         ; Set bit 7 of QQ17 to switch to Sentence Case, with the
 STA QQ17               ; next letter in capitals

 JSR INCYC              ; Move the text cursor down one line

 LDA tek                ; Fetch the tech level of the current system from tek
 CLC                    ; and add 3 (the tech level is stored as 0-14, so A is
 ADC #3                 ; now set to between 3 and 17)

 CMP #12                ; If A >= 12 then set A = 14, so A is now set to between
 BCC P%+4               ; 3 and 14
 LDA #14

 STA Q                  ; Set QQ25 = A (so QQ25 is in the range 3-14 and
 STA QQ25               ; represents number of the most advanced item available
 INC Q                  ; in this system, which we can pass to gnum below when
                        ; asking which item we want to buy)
                        ;
                        ; Set Q = A + 1 (so Q is in the range 4-15 and contains
                        ; QQ25 + 1, i.e. the highest item number on sale + 1)

 LDA #70                ; Set A = 70 - QQ14, where QQ14 contains the current
 SEC                    ; fuel in light years * 10, so this leaves the amount
 SBC QQ14               ; of fuel we need to fill 'er up (in light years * 10)

 ASL A                  ; The price of fuel is always 2 Cr per light year, so we
 STA PRXS               ; double A and store it in PRXS, as the first price in
                        ; the price list (which is reserved for fuel), and
                        ; because the table contains prices as price * 10, it's
                        ; in the right format (so tank containing 7.0 light
                        ; years of fuel would be 14.0 Cr, or a PRXS value of
                        ; 140)

 LDX #1                 ; We are now going to work our way through the equipment
                        ; price list at PRXS, printing out the equipment that is
                        ; available at this station, so set a counter in X,
                        ; starting at 1, to hold the number of the current item
                        ; plus 1 (so the item number in X loops through 1-13)

.EQL1

 STX XX13               ; Store the current item number + 1 in XX13

 JSR TT67               ; Print a newline

 LDX XX13               ; Print the current item number + 1 to 3 digits, left-
 CLC                    ; padding with spaces, and with no decimal point, so the
 JSR pr2                ; items are numbered from 1

 JSR TT162              ; Print a space

 LDA XX13               ; Print recursive token 104 + XX13, which will be in the
 CLC                    ; range 105 ("FUEL") to 116 ("GALACTIC HYPERSPACE ")
 ADC #104               ; so this prints the current item's name
 JSR TT27

 LDA XX13               ; Call prx-3 to set (Y X) to the price of the item with
 JSR prx-3              ; number XX13 - 1 (as XX13 contains the item number + 1)

 SEC                    ; Set the C flag so we will print a decimal point when
                        ; we print the price

 LDA #25                ; Set A = 25 to denote column 25

IF _IB_DISK

 STA XC                 ; Move the text cursor to column 25

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 JSR DOXC               ; Move the text cursor to column 25

ENDIF

 LDA #6                 ; Print the number in (Y X) to 6 digits, left-padding
 JSR TT11               ; with spaces and including a decimal point, which will
                        ; be the correct price for this item as (Y X) contains
                        ; the price * 10, so the trailing zero will go after the
                        ; decimal point (i.e. 5250 will be printed as 525.0)

 LDX XX13               ; Increment the current item number in XX13
 INX

 CPX Q                  ; If X < Q, loop back up to print the next item on the
 BCC EQL1               ; list of equipment available at this station

 JSR CLYNS              ; Clear the bottom three text rows of the upper screen,
                        ; and move the text cursor to column 1 on row 21, i.e.
                        ; the start of the top row of the three bottom rows

 LDA #127               ; Print recursive token 127 ("ITEM") followed by a
 JSR prq                ; question mark

 JSR gnum               ; Call gnum to get a number from the keyboard, which
                        ; will be the number of the item we want to purchase,
                        ; returning the number entered in A and R, and setting
                        ; the C flag if the number is bigger than the highest
                        ; item number in QQ25

 BEQ bay                ; If no number was entered, jump up to bay to go to the
                        ; docking bay (i.e. show the Status Mode screen)

 BCS bay                ; If the number entered was too big, jump up to bay to
                        ; go to the docking bay (i.e. show the Status Mode
                        ; screen)

 SBC #0                 ; Set A to the number entered - 1 (because the C flag is
                        ; clear), which will be the actual item number we want
                        ; to buy

 PHA                    ; Store A on the stack so we can restore it after the
                        ; following call to DOXC

 LDA #2                 ; Set A = 2 to denote column 2

IF _IB_DISK

 STA XC                 ; Move the text cursor to column 2

 INC YC                 ; Move the text cursor down one line

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 JSR DOXC               ; Move the text cursor to column 2

 JSR INCYC              ; Move the text cursor down one line

ENDIF

 PLA                    ; Restore A from the stack

 PHA                    ; While preserving the value in A, call eq to subtract
 JSR eq                 ; the price of the item we want to buy (which is in A)
 PLA                    ; from our cash pot, but only if we have enough cash in
                        ; the pot. If we don't have enough cash, exit to the
                        ; docking bay (i.e. show the Status Mode screen)

 BNE et0                ; If A is not 0 (i.e. the item we've just bought is not
                        ; fuel), skip to et0

 LDX #70                ; Set the current fuel level * 10 in QQ14 to 70, or 7.0
 STX QQ14               ; light years (a full tank)

.et0

 CMP #1                 ; If A is not 1 (i.e. the item we've just bought is not
 BNE et1                ; a missile), skip to et1

 LDX NOMSL              ; Fetch the current number of missiles from NOMSL into X

 INX                    ; Increment X to the new number of missiles

 LDY #124               ; Set Y to recursive token 124 ("ALL")

 CPX #5                 ; If buying this missile would give us 5 missiles, this
 BCS pres               ; is more than the maximum of 4 missiles that we can
                        ; fit, so jump to pres to show the error "All Present",
                        ; beep and exit to the docking bay (i.e. show the Status
                        ; Mode screen)

 STX NOMSL              ; Otherwise update the number of missiles in NOMSL

 JSR msblob             ; Reset the dashboard's missile indicators so none of
                        ; them are targeted

 LDA #1                 ; Set A to 1 as the call to msblob will have overwritten
                        ; the original value, and we still need it set
                        ; correctly so we can continue through the conditional
                        ; statements for all the other equipment

.et1

 LDY #107               ; Set Y to recursive token 107 ("LARGE CARGO{sentence
                        ; case} BAY")

 CMP #2                 ; If A is not 2 (i.e. the item we've just bought is not
 BNE et2                ; a large cargo bay), skip to et2

 LDX #37                ; If our current cargo capacity in CRGO is 37, then we
 CPX CRGO               ; already have a large cargo bay fitted, so jump to pres
 BEQ pres               ; to show the error "Large Cargo Bay Present", beep and
                        ; exit to the docking bay (i.e. show the Status Mode
                        ; screen)

 STX CRGO               ; Otherwise we just scored ourselves a large cargo bay,
                        ; so update our current cargo capacity in CRGO to 37

.et2

 CMP #3                 ; If A is not 3 (i.e. the item we've just bought is not
 BNE et3                ; an E.C.M. system), skip to et3

 INY                    ; Increment Y to recursive token 108 ("E.C.M.SYSTEM")

 LDX ECM                ; If we already have an E.C.M. fitted (i.e. ECM is
 BNE pres               ; non-zero), jump to pres to show the error "E.C.M.
                        ; System Present", beep and exit to the docking bay
                        ; (i.e. show the Status Mode screen)

 DEC ECM                ; Otherwise we just took delivery of a brand new E.C.M.
                        ; system, so set ECM to $FF (as ECM was 0 before the DEC
                        ; instruction)

.et3

 CMP #4                 ; If A is not 4 (i.e. the item we've just bought is not
 BNE et4                ; an extra pulse laser), skip to et4

 JSR qv                 ; Print a menu listing the four views, with a "View ?"
                        ; prompt, and ask for a view number, which is returned
                        ; in X (which now contains 0-3)

 LDA #POW               ; Call refund with A set to the power of the new pulse
 JSR refund             ; laser to install the new laser and process a refund if
                        ; we already have a laser fitted to this view

 LDA #4                 ; Set A to 4 as we just overwrote the original value,
                        ; and we still need it set correctly so we can continue
                        ; through the conditional statements for all the other
                        ; equipment

.et4

 CMP #5                 ; If A is not 5 (i.e. the item we've just bought is not
 BNE et5                ; an extra beam laser), skip to et5

 JSR qv                 ; Print a menu listing the four views, with a "View ?"
                        ; prompt, and ask for a view number, which is returned
                        ; in X (which now contains 0-3)

 LDA #POW+128           ; Call refund with A set to the power of the new beam
 JSR refund             ; laser to install the new laser and process a refund if
                        ; we already have a laser fitted to this view

.et5

 LDY #111               ; Set Y to recursive token 107 ("FUEL SCOOPS")

 CMP #6                 ; If A is not 6 (i.e. the item we've just bought is not
 BNE et6                ; a fuel scoop), skip to et6

 LDX BST                ; If we already have fuel scoops fitted (i.e. BST is
 BEQ ed9                ; zero), jump to ed9, otherwise fall through into pres
                        ; to show the error "Fuel Scoops Present", beep and
                        ; exit to the docking bay (i.e. show the Status Mode
                        ; screen)

.pres

                        ; If we get here we need to show an error to say that
                        ; the item whose name is in recursive token Y is already
                        ; present, and then process a refund for the cost of
                        ; item number A

 STY K                  ; Store the item's name in K

 JSR prx                ; Call prx to set (Y X) to the price of equipment item
                        ; number A

 JSR MCASH              ; Add (Y X) cash to the cash pot in CASH, as the station
                        ; already took the money for this item in the JSR eq
                        ; instruction above, but we can't fit the item, so need
                        ; our money back

 LDA K                  ; Print the recursive token in K (the item's name)
 JSR spc                ; followed by a space

 LDA #31                ; Print recursive token 145 ("PRESENT")
 JSR TT27

.err

 JSR dn2                ; Call dn2 to make a short, high beep and delay for 1
                        ; second

 JMP BAY                ; Jump to BAY to go to the docking bay (i.e. show the
                        ; Status Mode screen)

.ed9

 DEC BST                ; We just bought a shiny new fuel scoop, so set BST to
                        ; $FF (as BST was 0 before the jump to ed9 above)

.et6

 INY                    ; Increment Y to recursive token 112 ("E.C.M.SYSTEM")

 CMP #7                 ; If A is not 7 (i.e. the item we've just bought is not
 BNE et7                ; an escape pod), skip to et7

 LDX ESCP               ; If we already have an escape pod fitted (i.e. ESCP is
 BNE pres               ; non-zero), jump to pres to show the error "Escape Pod
                        ; Present", beep and exit to the docking bay (i.e. show
                        ; the Status Mode screen)

 DEC ESCP               ; Otherwise we just bought an escape pod, so set ESCP
                        ; to $FF (as ESCP was 0 before the DEC instruction)

.et7

 INY                    ; Increment Y to recursive token 113 ("ENERGY BOMB")

 CMP #8                 ; If A is not 8 (i.e. the item we've just bought is not
 BNE et8                ; an energy bomb), skip to et8

 LDX BOMB               ; If we already have an energy bomb fitted (i.e. BOMB
 BNE pres               ; is non-zero), jump to pres to show the error "Energy
                        ; Bomb Present", beep and exit to the docking bay (i.e.
                        ; show the Status Mode screen)

 LDX #$7F               ; Otherwise we just bought an energy bomb, so set BOMB
 STX BOMB               ; to $7F

.et8

 INY                    ; Increment Y to recursive token 114 ("ENERGY UNIT")

 CMP #9                 ; If A is not 9 (i.e. the item we've just bought is not
 BNE etA                ; an energy unit), skip to etA

 LDX ENGY               ; If we already have an energy unit fitted (i.e. ENGY is
 BNE pres               ; non-zero), jump to pres to show the error "Energy Unit
                        ; Present", beep and exit to the docking bay (i.e. show
                        ; the Status Mode screen)

 INC ENGY               ; Otherwise we just picked up an energy unit, so set
                        ; ENGY to 1 (as ENGY was 0 before the INC instruction)

.etA

 INY                    ; Increment Y to recursive token 115 ("DOCKING
                        ; COMPUTERS")

 CMP #10                ; If A is not 10 (i.e. the item we've just bought is not
 BNE etB                ; a docking computer), skip to etB

 LDX DKCMP              ; If we already have a docking computer fitted (i.e.
 BNE pres               ; DKCMP is non-zero), jump to pres to show the error
                        ; "Docking Computer Present", beep and exit to the
                        ; docking bay (i.e. show the Status Mode screen)

 DEC DKCMP              ; Otherwise we just got hold of a docking computer, so
                        ; set DKCMP to $FF (as DKCMP was 0 before the DEC
                        ; instruction)

.etB

 INY                    ; Increment Y to recursive token 116 ("GALACTIC
                        ; HYPERSPACE ")

 CMP #11                ; If A is not 11 (i.e. the item we've just bought is not
 BNE et9                ; a galactic hyperdrive), skip to et9

 LDX GHYP               ; If we already have a galactic hyperdrive fitted (i.e.
 BNE pres               ; GHYP is non-zero), jump to pres to show the error
                        ; "Galactic Hyperspace Present", beep and exit to the
                        ; docking bay (i.e. show the Status Mode screen)

 DEC GHYP               ; Otherwise we just splashed out on a galactic
                        ; hyperdrive, so set GHYP to $FF (as GHYP was 0 before
                        ; the DEC instruction)

.et9

 INY                    ; Increment Y to recursive token 117 ("MILITARY  LASER")

 CMP #12                ; If A is not 12 (i.e. the item we've just bought is not
 BNE et10               ; a military laser), skip to et10

 JSR qv                 ; Print a menu listing the four views, with a "View ?"
                        ; prompt, and ask for a view number, which is returned
                        ; in X (which now contains 0-3)

 LDA #Armlas            ; Call refund with A set to the power of the new
 JSR refund             ; military laser to install the new laser and process a
                        ; refund if we already have a laser fitted to this view

.et10

 INY                    ; Increment Y to recursive token 118 ("MINING  LASER")

 CMP #13                ; If A is not 13 (i.e. the item we've just bought is not
 BNE et11               ; a mining laser), skip to et11

 JSR qv                 ; Print a menu listing the four views, with a "View ?"
                        ; prompt, and ask for a view number, which is returned
                        ; in X (which now contains 0-3)

 LDA #Mlas              ; Call refund with A set to the power of the new mining
 JSR refund             ; laser to install the new laser and process a refund if
                        ; we already have a laser fitted to this view

.et11

 JSR dn                 ; We are done buying equipment, so print the amount of
                        ; cash left in the cash pot, then make a short, high
                        ; beep to confirm the purchase, and delay for 1 second

 JMP EQSHP              ; Jump back up to EQSHP to show the Equip Ship screen
                        ; again and see if we can't track down another bargain

; ******************************************************************************
;
;       Name: dn
;       Type: Subroutine
;   Category: Market
;    Summary: Print the amount of money we have left in the cash pot, then make
;             a short, high beep and delay for 1 second
;
; ******************************************************************************

.dn

 JSR TT162              ; Print a space

 LDA #119               ; Print recursive token 119 ("CASH:{cash} CR{crlf}")
 JSR spc                ; followed by a space

                        ; Fall through into dn2 to make a beep and delay for
                        ; 1 second before returning from the subroutine

; ******************************************************************************
;
;       Name: dn2
;       Type: Subroutine
;   Category: Text
;    Summary: Make a low, long beep and delay for 0.5 seconds
;
; ******************************************************************************

.dn2

 JSR BOOP               ; Call the BOOP routine to make a low, long beep

 LDY #25                ; Delay for 25 vertical syncs (25/50 = 0.5 second) and
 JMP DELAY              ; return from the subroutine using a tail call

; ******************************************************************************
;
;       Name: eq
;       Type: Subroutine
;   Category: Equipment
;    Summary: Subtract the price of equipment from the cash pot
;
; ------------------------------------------------------------------------------
;
; If we have enough cash, subtract the price of a specified piece of equipment
; from our cash pot and return from the subroutine. If we don't have enough
; cash, exit to the docking bay (i.e. show the Status Mode screen).
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The item number of the piece of equipment (0-11) as
;                       shown in the table at PRXS
;
; ******************************************************************************

.eq

 JSR prx                ; Call prx to set (Y X) to the price of equipment item
                        ; number A

 JSR LCASH              ; Subtract (Y X) cash from the cash pot, but only if
                        ; we have enough cash

 BCS c                  ; If the C flag is set then we did have enough cash for
                        ; the transaction, so jump to c to return from the
                        ; subroutine (as c contains an RTS)

 LDA #197               ; Otherwise we don't have enough cash to buy this piece
 JSR prq                ; of equipment, so print recursive token 37 ("CASH")
                        ; followed by a question mark

 JMP err                ; Jump to err to beep, pause and go to the docking bay
                        ; (i.e. show the Status Mode screen)

; ******************************************************************************
;
;       Name: prx
;       Type: Subroutine
;   Category: Equipment
;    Summary: Return the price of a piece of equipment
;
; ------------------------------------------------------------------------------
;
; This routine returns the price of equipment as listed in the table at PRXS.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The item number of the piece of equipment (0-13) as
;                       shown in the table at PRXS
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   (Y X)               The item price in Cr * 10 (Y = high byte, X = low byte)
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   prx-3               Return the price of the item with number A - 1
;
;   c                   Contains an RTS
;
; ******************************************************************************

 SEC                    ; Decrement A (for when this routine is called via
 SBC #1                 ; prx-3)

.prx

 ASL A                  ; Set Y = A * 2, so it can act as an index into the
 TAY                    ; PRXS table, which has two bytes per entry

 LDX PRXS,Y             ; Fetch the low byte of the price into X

 LDA PRXS+1,Y           ; Fetch the high byte of the price into A and transfer
 TAY                    ; it to X, so the price is now in (Y X)

.c

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: qv
;       Type: Subroutine
;   Category: Equipment
;    Summary: Print a menu of the four space views, for buying lasers
;
; ------------------------------------------------------------------------------
;
; Print a menu in the bottom-middle of the screen, at row 16, column 12, that
; lists the four available space views, like this:
;
;                 0 Front
;                 1 Rear
;                 2 Left
;                 3 Right
;
; Also print a "View ?" prompt and ask for a view number. The menu is shown
; when we choose to buy a new laser in the Equip Ship screen.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   X                   The chosen view number (0-3)
;
; ******************************************************************************

.qv

 LDA tek                ; If the current system's tech level is less than 8,
 CMP #8                 ; skip the next two instructions, otherwise we clear the
 BCC P%+7               ; screen to prevent the view menu from clashing with the
                        ; longer equipment menu available in higher tech systems

 LDA #32                ; Clear the top part of the screen, draw a white border,
 JSR TT66               ; and set the current view type in QQ11 to 32 (Equip
                        ; Ship screen)

 LDA #16                ; Set A = 16 to denote row 16

 TAY                    ; Set Y to a counter going from 16 to 19 in the loop
                        ; below

IF _IB_DISK

 STA YC                 ; Move the text cursor to row 16

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 JSR DOYC               ; Move the text cursor to row 16

ENDIF

.qv1

 LDA #12                ; Set A = 12 to denote column 12

IF _IB_DISK

 STA XC                 ; Move the text cursor to column 12

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 JSR DOXC               ; Move the text cursor to column 12

ENDIF

 TYA                    ; Transfer the counter value from Y to A

 CLC                    ; Print ASCII character "0" - 16 + A, so as A goes from
 ADC #'0'-16            ; 16 to 19, this prints "0" through "3" followed by a
 JSR spc                ; space

 LDA YC                 ; Print recursive text token 80 + YC, so as YC goes from
 CLC                    ; 16 to 19, this prints "FRONT", "REAR", "LEFT" and
 ADC #80                ; "RIGHT"
 JSR TT27

IF _IB_DISK

 INC YC                 ; Move the text cursor down a row, and increment the
                        ; counter in YC at the same time

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 JSR INCYC              ; Move the text cursor down a row, and increment the
                        ; counter in YC at the same time

ENDIF

 LDY YC                 ; Update Y with the incremented counter in YC

 CPY #20                ; If Y < 20 then loop back up to qv1 to print the next
 BCC qv1                ; view in the menu

 JSR CLYNS              ; Clear the bottom three text rows of the upper screen,
                        ; and move the text cursor to column 1 on row 21, i.e.
                        ; the start of the top row of the three bottom rows

.qv2

 LDA #175               ; Print recursive text token 15 ("VIEW ") followed by
 JSR prq                ; a question mark

 JSR TT217              ; Scan the keyboard until a key is pressed, and return
                        ; the key's ASCII code in A (and X)

 SEC                    ; Subtract ASCII "0" from the key pressed, to leave the
 SBC #'0'               ; numeric value of the key in A (if it was a number key)

 CMP #4                 ; If the number entered in A < 4, then it is a valid
 BCC qv3                ; view number, so jump down to qv3 as we are done

 JSR CLYNS              ; Otherwise we didn't get a valid view number, so clear
                        ; the bottom three text rows of the upper screen, and
                        ; move the text cursor to column 1 on row 21

 JMP qv2                ; Jump back to qv2 to try again

.qv3

 TAX                    ; We have a valid view number, so transfer it to X

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: hm
;       Type: Subroutine
;   Category: Charts
;    Summary: Select the closest system and redraw the chart crosshairs
;
; ------------------------------------------------------------------------------
;
; Set the system closest to galactic coordinates (QQ9, QQ10) as the selected
; system, redraw the crosshairs on the chart accordingly (if they are being
; shown), and, if this is not a space view, clear the bottom three text rows of
; the screen.
;
; ******************************************************************************

.hm

 JSR TT103              ; Draw small crosshairs at coordinates (QQ9, QQ10),
                        ; which will erase the crosshairs currently there

 JSR TT111              ; Select the system closest to galactic coordinates
                        ; (QQ9, QQ10)

 JSR TT103              ; Draw small crosshairs at coordinates (QQ9, QQ10),
                        ; which will draw the crosshairs at our current home
                        ; system

 JMP CLYNS              ; Clear the bottom three text rows of the upper screen,
                        ; and move the text cursor to column 1 on row 21, i.e.
                        ; the start of the top row of the three bottom rows

                        ; Return from the subroutine using a tail call

; ******************************************************************************
;
;       Name: refund
;       Type: Subroutine
;   Category: Equipment
;    Summary: Install a new laser, processing a refund if applicable
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The power of the new laser to be fitted
;
;   X                   The view number for fitting the new laser (0-3)
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   A                   A is preserved
;
;   X                   X is preserved
;
; ******************************************************************************

;.ref2                  ; These instructions are commented out in the original
;LDY #187               ; source, but they would jump to pres in the EQSHP
;JMP pres               ; routine with Y = 187, which would show the error:
;Belgium                ; "LASER PRESENT" (this code was part of the refund
                        ; bug in the disc version of Elite, which is why it is
                        ; commented out)
                        ;
                        ; There is also a comment in the original source - the
                        ; solitary word "Belgium"
                        ;
                        ; This is presumably a reference to the Hitchhiker's
                        ; Guide to the Galaxy, which says that Belgium is the
                        ; galaxy's most unspeakably rude word, so this no doubt
                        ; reflects the authors' strong feelings on the refund
                        ; bug

.refund

 STA T1                 ; Store A in T1 so we can retrieve it later

 LDA LASER,X            ; If there is no laser in view X (i.e. the laser power
 BEQ ref3               ; is zero), jump to ref3 to skip the refund code

;CMP T1                 ; These instructions are commented out in the original
;BEQ ref2               ; source, but they would jump to ref2 above if we were
                        ; trying to replace a laser with one of the same type
                        ; (this code was part of the refund bug in the disc
                        ; version of Elite, which is why it is commented out)

 LDY #4                 ; If the current laser has power #POW (pulse laser),
 CMP #POW               ; jump to ref1 with Y = 4 (the item number of a pulse
 BEQ ref1               ; laser in the table at PRXS)

 LDY #5                 ; If the current laser has power #POW+128 (beam laser),
 CMP #POW+128           ; jump to ref1 with Y = 5 (the item number of a beam
 BEQ ref1               ; laser in the table at PRXS)

 LDY #12                ; If the current laser has power #Armlas (military
 CMP #Armlas            ; laser), jump to ref1 with Y = 12 (the item number of a
 BEQ ref1               ; military laser in the table at PRXS)

 LDY #13                ; Otherwise this is a mining laser, so fall through into
                        ; ref1 with Y = 13 (the item number of a mining laser in
                        ; the table at PRXS)

.ref1

                        ; We now want to refund the laser of type Y that we are
                        ; exchanging for the new laser

 STX ZZ                 ; Store the view number in ZZ so we can retrieve it
                        ; later

 TYA                    ; Copy the laser type to be refunded from Y to A

 JSR prx                ; Call prx to set (Y X) to the price of equipment item
                        ; number A

 JSR MCASH              ; Call MCASH to add (Y X) to the cash pot

 LDX ZZ                 ; Retrieve the view number from ZZ

.ref3

                        ; Finally, we install the new laser

 LDA T1                 ; Retrieve the new laser's power from T1 into A

 STA LASER,X            ; Set the laser view to the new laser's power

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: PRXS
;       Type: Variable
;   Category: Equipment
;    Summary: Equipment prices
;
; ------------------------------------------------------------------------------
;
; Equipment prices are stored as 10 * the actual value, so we can support prices
; with fractions of credits (0.1 Cr). This is used for the price of fuel only.
;
; ******************************************************************************

.PRXS

 EQUW 1                 ; 0  Fuel, calculated in EQSHP  140.0 Cr (full tank)
 EQUW 300               ; 1  Missile                     30.0 Cr
 EQUW 4000              ; 2  Large Cargo Bay            400.0 Cr
 EQUW 6000              ; 3  E.C.M. System              600.0 Cr
 EQUW 4000              ; 4  Extra Pulse Lasers         400.0 Cr
 EQUW 10000             ; 5  Extra Beam Lasers         1000.0 Cr
 EQUW 5250              ; 6  Fuel Scoops                525.0 Cr
 EQUW 10000             ; 7  Escape Pod                1000.0 Cr
 EQUW 9000              ; 8  Energy Bomb                900.0 Cr
 EQUW 15000             ; 9  Energy Unit               1500.0 Cr
 EQUW 10000             ; 10 Docking Computer          1000.0 Cr
 EQUW 50000             ; 11 Galactic Hyperspace       5000.0 Cr
 EQUW 60000             ; 12 Extra Military Lasers     6000.0 Cr
 EQUW 8000              ; 13 Extra Mining Lasers        800.0 Cr

; ******************************************************************************
;
; Save ELTD.bin
;
; ******************************************************************************

 PRINT "ELITE D"
 PRINT "Assembled at ", ~CODE_D%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_D%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_D%

 PRINT "S.ELTD ", ~CODE_D%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_D%
 SAVE "3-assembled-output/ELTD.bin", CODE_D%, P%, LOAD%

; ******************************************************************************
;
; ELITE E FILE
;
; Produces the binary file ELTE.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_E% = P%

 LOAD_E% = LOAD% + P% - CODE%

; ******************************************************************************
;
;       Name: cpl
;       Type: Subroutine
;   Category: Universe
;    Summary: Print the selected system name
;  Deep dive: Generating system names
;             Galaxy and system seeds
;
; ------------------------------------------------------------------------------
;
; Print control code 3 (the selected system name, i.e. the one in the crosshairs
; in the Short-range Chart).
;
; ******************************************************************************

.cpl

 LDX #5                 ; First we need to back up the seeds in QQ15, so set up
                        ; a counter in X to cover three 16-bit seeds (i.e.
                        ; 6 bytes)

.TT53

 LDA QQ15,X             ; Copy byte X from QQ15 to QQ19
 STA QQ19,X

 DEX                    ; Decrement the loop counter

 BPL TT53               ; Loop back for the next byte to back up

 LDY #3                 ; Step 1: Now that the seeds are backed up, we can
                        ; start the name-generation process. We will either
                        ; need to loop three or four times, so for now set
                        ; up a counter in Y to loop four times

 BIT QQ15               ; Check bit 6 of s0_lo, which is stored in QQ15

 BVS P%+3               ; If bit 6 is set then skip over the next instruction

 DEY                    ; Bit 6 is clear, so we only want to loop three times,
                        ; so decrement the loop counter in Y

 STY T                  ; Store the loop counter in T

.TT55

 LDA QQ15+5             ; Step 2: Load s2_hi, which is stored in QQ15+5, and
 AND #%00011111         ; extract bits 0-4 by AND'ing with %11111

 BEQ P%+7               ; If all those bits are zero, then skip the following
                        ; two instructions to go to step 3

 ORA #%10000000         ; We now have a number in the range 1-31, which we can
                        ; easily convert into a two-letter token, but first we
                        ; need to add 128 (or set bit 7) to get a range of
                        ; 129-159

 JSR TT27               ; Print the two-letter token in A

 JSR TT54               ; Step 3: twist the seeds in QQ15

 DEC T                  ; Decrement the loop counter

 BPL TT55               ; Loop back for the next two letters

 LDX #5                 ; We have printed the system name, so we can now
                        ; restore the seeds we backed up earlier. Set up a
                        ; counter in X to cover three 16-bit seeds (i.e. 6
                        ; bytes)

.TT56

 LDA QQ19,X             ; Copy byte X from QQ19 to QQ15
 STA QQ15,X

 DEX                    ; Decrement the loop counter

 BPL TT56               ; Loop back for the next byte to restore

 RTS                    ; Once all the seeds are restored, return from the
                        ; subroutine

; ******************************************************************************
;
;       Name: cmn
;       Type: Subroutine
;   Category: Status
;    Summary: Print the commander's name
;
; ------------------------------------------------------------------------------
;
; Print control code 4 (the commander's name).
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   cmn-1               Contains an RTS
;
; ******************************************************************************

.cmn

 LDY #0                 ; Set up a counter in Y, starting from 0

.QUL4

 LDA NAME,Y             ; The commander's name is stored at NAME, so load the
                        ; Y-th character from NAME

 CMP #13                ; If we have reached the end of the name, return from
 BEQ ypl-1              ; the subroutine (ypl-1 points to the RTS below)

 JSR TT26               ; Print the character we just loaded

 INY                    ; Increment the loop counter

 BNE QUL4               ; Loop back for the next character

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: ypl
;       Type: Subroutine
;   Category: Universe
;    Summary: Print the current system name
;
; ------------------------------------------------------------------------------
;
; Print control code 2 (the current system name).
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   ypl-1               Contains an RTS
;
; ******************************************************************************

.ypl

 BIT MJ                 ; Check the mis-jump flag at MJ, and if bit 7 is set
 BMI ypl16              ; then we are in witchspace, and witchspace doesn't have
                        ; a system name, so jump to ypl16 to return from the
                        ; subroutine

 JSR TT62               ; Call TT62 below to swap the three 16-bit seeds in
                        ; QQ2 and QQ15 (before the swap, QQ2 contains the seeds
                        ; for the current system, while QQ15 contains the seeds
                        ; for the selected system)

 JSR cpl                ; Call cpl to print out the system name for the seeds
                        ; in QQ15 (which now contains the seeds for the current
                        ; system)

                        ; Now we fall through into the TT62 subroutine, which
                        ; will swap QQ2 and QQ15 once again, so everything goes
                        ; back into the right place, and the RTS at the end of
                        ; TT62 will return from the subroutine

.TT62

 LDX #5                 ; Set up a counter in X for the three 16-bit seeds we
                        ; want to swap (i.e. 6 bytes)

.TT78

 LDA QQ15,X             ; Swap byte X between QQ2 and QQ15
 LDY QQ2,X
 STA QQ2,X
 STY QQ15,X

 DEX                    ; Decrement the loop counter

 BPL TT78               ; Loop back for the next byte to swap

.ypl16

 RTS                    ; Once all bytes are swapped, return from the
                        ; subroutine

; ******************************************************************************
;
;       Name: tal
;       Type: Subroutine
;   Category: Universe
;    Summary: Print the current galaxy number
;
; ------------------------------------------------------------------------------
;
; Print control code 1 (the current galaxy number, right-aligned to width 3).
;
; ******************************************************************************

.tal

 CLC                    ; We don't want to print the galaxy number with a
                        ; decimal point, so clear the C flag for pr2 to take as
                        ; an argument

 LDX GCNT               ; Load the current galaxy number from GCNT into X

 INX                    ; Add 1 to the galaxy number, as the galaxy numbers
                        ; are 0-7 internally, but we want to display them as
                        ; galaxy 1 through 8

 JMP pr2                ; Jump to pr2, which prints the number in X to a width
                        ; of 3 figures, left-padding with spaces to a width of
                        ; 3, and return from the subroutine using a tail call

; ******************************************************************************
;
;       Name: fwl
;       Type: Subroutine
;   Category: Status
;    Summary: Print fuel and cash levels
;
; ------------------------------------------------------------------------------
;
; Print control code 5 ("FUEL: ", fuel level, " LIGHT YEARS", newline, "CASH:",
; control code 0).
;
; ******************************************************************************

.fwl

 LDA #105               ; Print recursive token 105 ("FUEL") followed by a
 JSR TT68               ; colon

 LDX QQ14               ; Load the current fuel level from QQ14

 SEC                    ; We want to print the fuel level with a decimal point,
                        ; so set the C flag for pr2 to take as an argument

 JSR pr2                ; Call pr2, which prints the number in X to a width of
                        ; 3 figures (i.e. in the format x.x, which will always
                        ; be exactly 3 characters as the maximum fuel is 7.0)

 LDA #195               ; Print recursive token 35 ("LIGHT YEARS") followed by
 JSR plf                ; a newline

.PCASH

 LDA #119               ; Print recursive token 119 ("CASH:" then control code
 BNE TT27               ; 0, which prints cash levels, then " CR" and newline)

; ******************************************************************************
;
;       Name: csh
;       Type: Subroutine
;   Category: Status
;    Summary: Print the current amount of cash
;
; ------------------------------------------------------------------------------
;
; Print control code 0 (the current amount of cash, right-aligned to width 9,
; followed by " CR" and a newline).
;
; ******************************************************************************

.csh

 LDX #3                 ; We are going to use the BPRNT routine to print out
                        ; the current amount of cash, which is stored as a
                        ; 32-bit number at location CASH. BPRNT prints out
                        ; the 32-bit number stored in K, so before we call
                        ; BPRNT, we need to copy the four bytes from CASH into
                        ; K, so first we set up a counter in X for the 4 bytes

.pc1

 LDA CASH,X             ; Copy byte X from CASH to K
 STA K,X

 DEX                    ; Decrement the loop counter

 BPL pc1                ; Loop back for the next byte to copy

 LDA #9                 ; We want to print the cash amount using up to 9 digits
 STA U                  ; (including the decimal point), so store this in U
                        ; for BRPNT to take as an argument

 SEC                    ; We want to print the cash amount with a decimal point,
                        ; so set the C flag for BRPNT to take as an argument

 JSR BPRNT              ; Print the amount of cash to 9 digits with a decimal
                        ; point

 LDA #226               ; Print recursive token 66 (" CR") followed by a
                        ; newline by falling through into plf

; ******************************************************************************
;
;       Name: plf
;       Type: Subroutine
;   Category: Text
;    Summary: Print a text token followed by a newline
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The text token to be printed
;
; ******************************************************************************

.plf

 JSR TT27               ; Print the text token in A

 JMP TT67               ; Jump to TT67 to print a newline and return from the
                        ; subroutine using a tail call

; ******************************************************************************
;
;       Name: TT68
;       Type: Subroutine
;   Category: Text
;    Summary: Print a text token followed by a colon
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The text token to be printed
;
; ******************************************************************************

.TT68

 JSR TT27               ; Print the text token in A and fall through into TT73
                        ; to print a colon

; ******************************************************************************
;
;       Name: TT73
;       Type: Subroutine
;   Category: Text
;    Summary: Print a colon
;
; ******************************************************************************

.TT73

 LDA #':'               ; Set A to ASCII ":" and fall through into TT27 to
                        ; actually print the colon

; ******************************************************************************
;
;       Name: TT27
;       Type: Subroutine
;   Category: Text
;    Summary: Print a text token
;  Deep dive: Printing text tokens
;
; ------------------------------------------------------------------------------
;
; Print a text token (i.e. a character, control code, two-letter token or
; recursive token).
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The text token to be printed
;
; ******************************************************************************

.TT27

 TAX                    ; Copy the token number from A to X. We can then keep
                        ; decrementing X and testing it against zero, while
                        ; keeping the original token number intact in A; this
                        ; effectively implements a switch statement on the
                        ; value of the token

 BEQ csh                ; If token = 0, this is control code 0 (current amount
                        ; of cash and newline), so jump to csh to print the
                        ; amount of cash and return from the subroutine using
                        ; a tail call

 BMI TT43               ; If token > 127, this is either a two-letter token
                        ; (128-159) or a recursive token (160-255), so jump
                        ; to TT43 to process tokens

 DEX                    ; If token = 1, this is control code 1 (current galaxy
 BEQ tal                ; number), so jump to tal to print the galaxy number and
                        ; return from the subroutine using a tail call

 DEX                    ; If token = 2, this is control code 2 (current system
 BEQ ypl                ; name), so jump to ypl to print the current system name
                        ; and return from the subroutine using a tail call

 DEX                    ; If token > 3, skip the following instruction
 BNE P%+5

 JMP cpl                ; This token is control code 3 (selected system name)
                        ; so jump to cpl to print the selected system name
                        ; and return from the subroutine using a tail call

 DEX                    ; If token = 4, this is control code 4 (commander
 BEQ cmn                ; name), so jump to cmm to print the commander name
                        ; and return from the subroutine using a tail call

 DEX                    ; If token = 5, this is control code 5 (fuel, newline,
 BEQ fwl                ; cash, newline), so jump to fwl to print the fuel level
                        ; and return from the subroutine using a tail call

 DEX                    ; If token > 6, skip the following three instructions
 BNE P%+7

 LDA #%10000000         ; This token is control code 6 (switch to Sentence
 STA QQ17               ; Case), so set bit 7 of QQ17 to switch to Sentence Case
 RTS                    ; and return from the subroutine as we are done

 DEX                    ; If token > 8, skip the following two instructions
 DEX
 BNE P%+5

 STX QQ17               ; This token is control code 8 (switch to ALL CAPS), so
 RTS                    ; set QQ17 to 0 to switch to ALL CAPS and return from
                        ; the subroutine as we are done

 DEX                    ; If token = 9, this is control code 9 (tab to column
 BEQ crlf               ; 21 and print a colon), so jump to crlf

 CMP #96                ; By this point, token is either 7, or in 10-127.
 BCS ex                 ; Check token number in A and if token >= 96, then the
                        ; token is in 96-127, which is a recursive token, so
                        ; jump to ex, which prints recursive tokens in this
                        ; range (i.e. where the recursive token number is
                        ; correct and doesn't need correcting)

 CMP #14                ; If token < 14, skip the following two instructions
 BCC P%+6

 CMP #32                ; If token < 32, then this means token is in 14-31, so
 BCC qw                 ; this is a recursive token that needs 114 adding to it
                        ; to get the recursive token number, so jump to qw
                        ; which will do this

                        ; By this point, token is either 7 (beep) or in 10-13
                        ; (line feeds and carriage returns), or in 32-95
                        ; (ASCII letters, numbers and punctuation)

 LDX QQ17               ; Fetch QQ17, which controls letter case, into X

 BEQ TT74               ; If QQ17 = 0, then ALL CAPS is set, so jump to TT74
                        ; to print this character as is (i.e. as a capital)

 BMI TT41               ; If QQ17 has bit 7 set, then we are using Sentence
                        ; Case, so jump to TT41, which will print the
                        ; character in upper or lower case, depending on
                        ; whether this is the first letter in a word

 BIT QQ17               ; If we get here, QQ17 is not 0 and bit 7 is clear, so
 BVS TT46               ; either it is bit 6 that is set, or some other flag in
                        ; QQ17 is set (bits 0-5). So check whether bit 6 is set.
                        ; If it is, then ALL CAPS has been set (as bit 7 is
                        ; clear) but bit 6 is still indicating that the next
                        ; character should be printed in lower case, so we need
                        ; to fix this. We do this with a jump to TT46, which
                        ; will print this character in upper case and clear bit
                        ; 6, so the flags are consistent with ALL CAPS going
                        ; forward

                        ; If we get here, some other flag is set in QQ17 (one
                        ; of bits 0-5 is set), which shouldn't happen in this
                        ; version of Elite. If this were the case, then we
                        ; would fall through into TT42 to print in lower case,
                        ; which is how printing all words in lower case could
                        ; be supported (by setting QQ17 to 1, say)

; ******************************************************************************
;
;       Name: TT42
;       Type: Subroutine
;   Category: Text
;    Summary: Print a letter in lower case
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The character to be printed. Can be one of the
;                       following:
;
;                         * 7 (beep)
;
;                         * 10-13 (line feeds and carriage returns)
;
;                         * 32-95 (ASCII capital letters, numbers and
;                           punctuation)
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   TT44                Jumps to TT26 to print the character in A (used to
;                       enable us to use a branch instruction to jump to TT26)
;
; ******************************************************************************

.TT42

 CMP #'A'               ; If A < ASCII "A", then this is punctuation, so jump
 BCC TT44               ; to TT26 (via TT44) to print the character as is, as
                        ; we don't care about the character's case

 CMP #'Z'+1             ; If A >= (ASCII "Z" + 1), then this is also
 BCS TT44               ; punctuation, so jump to TT26 (via TT44) to print the
                        ; character as is, as we don't care about the
                        ; character's case

 ADC #32                ; Add 32 to the character, to convert it from upper to
                        ; lower case

.TT44

 JMP TT26               ; Print the character in A

; ******************************************************************************
;
;       Name: TT41
;       Type: Subroutine
;   Category: Text
;    Summary: Print a letter according to Sentence Case
;
; ------------------------------------------------------------------------------
;
; The rules for printing in Sentence Case are as follows:
;
;   * If QQ17 bit 6 is set, print lower case (via TT45)
;
;   * If QQ17 bit 6 is clear, then:
;
;       * If character is punctuation, just print it
;
;       * If character is a letter, set QQ17 bit 6 and print letter as a capital
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The character to be printed. Can be one of the
;                       following:
;
;                         * 7 (beep)
;
;                         * 10-13 (line feeds and carriage returns)
;
;                         * 32-95 (ASCII capital letters, numbers and
;                           punctuation)
;
;   X                   Contains the current value of QQ17
;
;   QQ17                Bit 7 is set
;
; ******************************************************************************

.TT41

                        ; If we get here, then QQ17 has bit 7 set, so we are in
                        ; Sentence Case

 BIT QQ17               ; If QQ17 also has bit 6 set, jump to TT45 to print
 BVS TT45               ; this character in lower case

                        ; If we get here, then QQ17 has bit 6 clear and bit 7
                        ; set, so we are in Sentence Case and we need to print
                        ; the next letter in upper case

 CMP #'A'               ; If A < ASCII "A", then this is punctuation, so jump
 BCC TT74               ; to TT26 (via TT44) to print the character as is, as
                        ; we don't care about the character's case

 PHA                    ; Otherwise this is a letter, so store the token number

 TXA                    ; Set bit 6 in QQ17 (X contains the current QQ17)
 ORA #%1000000          ; so the next letter after this one is printed in lower
 STA QQ17               ; case

 PLA                    ; Restore the token number into A

 BNE TT44               ; Jump to TT26 (via TT44) to print the character in A
                        ; (this BNE is effectively a JMP as A will never be
                        ; zero)

; ******************************************************************************
;
;       Name: qw
;       Type: Subroutine
;   Category: Text
;    Summary: Print a recursive token in the range 128-145
;
; ------------------------------------------------------------------------------
;
; Print a recursive token where the token number is in 128-145 (so the value
; passed to TT27 is in the range 14-31).
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   A value from 128-145, which refers to a recursive token
;                       in the range 14-31
;
; ******************************************************************************

.qw

 ADC #114               ; This is a recursive token in the range 0-95, so add
 BNE ex                 ; 114 to the argument to get the token number 128-145
                        ; and jump to ex to print it

; ******************************************************************************
;
;       Name: crlf
;       Type: Subroutine
;   Category: Text
;    Summary: Tab to column 21 and print a colon
;
; ------------------------------------------------------------------------------
;
; Print control code 9 (tab to column 21 and print a colon). The subroutine
; name is pretty misleading, as it doesn't have anything to do with carriage
; returns or line feeds.
;
; ******************************************************************************

.crlf

 LDA #21                ; Set A = 21 to denote column 21

IF _IB_DISK

 STA XC                 ; Set the X-column in XC to 21

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 JSR DOXC               ; Set the X-column in XC to 21

ENDIF

 JMP TT73               ; Jump to TT73, which prints a colon (this BNE is
                        ; effectively a JMP as A will never be zero)

; ******************************************************************************
;
;       Name: TT45
;       Type: Subroutine
;   Category: Text
;    Summary: Print a letter in lower case
;
; ------------------------------------------------------------------------------
;
; This routine prints a letter in lower case. Specifically:
;
;   * If QQ17 = 255, abort printing this character as printing is disabled
;
;   * If this is a letter then print in lower case
;
;   * Otherwise this is punctuation, so clear bit 6 in QQ17 and print
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The character to be printed. Can be one of the
;                       following:
;
;                         * 7 (beep)
;
;                         * 10-13 (line feeds and carriage returns)
;
;                         * 32-95 (ASCII capital letters, numbers and
;                           punctuation)
;
;   X                   Contains the current value of QQ17
;
;   QQ17                Bits 6 and 7 are set
;
; ******************************************************************************

.TT45

                        ; If we get here, then QQ17 has bit 6 and 7 set, so we
                        ; are in Sentence Case and we need to print the next
                        ; letter in lower case

 CPX #255               ; If QQ17 = 255 then printing is disabled, so return
 BEQ TT48               ; from the subroutine (as TT48 contains an RTS)

 CMP #'A'               ; If A >= ASCII "A", then jump to TT42, which will
 BCS TT42               ; print the letter in lowercase

                        ; Otherwise this is not a letter, it's punctuation, so
                        ; this is effectively a word break. We therefore fall
                        ; through to TT46 to print the character and set QQ17
                        ; to ensure the next word starts with a capital letter

; ******************************************************************************
;
;       Name: TT46
;       Type: Subroutine
;   Category: Text
;    Summary: Print a character and switch to capitals
;
; ------------------------------------------------------------------------------
;
; Print a character and clear bit 6 in QQ17, so that the next letter that gets
; printed after this will start with a capital letter.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The character to be printed. Can be one of the
;                       following:
;
;                         * 7 (beep)
;
;                         * 10-13 (line feeds and carriage returns)
;
;                         * 32-95 (ASCII capital letters, numbers and
;                           punctuation)
;
;   X                   Contains the current value of QQ17
;
;   QQ17                Bits 6 and 7 are set
;
; ******************************************************************************

.TT46

 PHA                    ; Store the token number

 TXA                    ; Clear bit 6 in QQ17 (X contains the current QQ17) so
 AND #%10111111         ; the next letter after this one is printed in upper
 STA QQ17               ; case

 PLA                    ; Restore the token number into A

                        ; Now fall through into TT74 to print the character

; ******************************************************************************
;
;       Name: TT74
;       Type: Subroutine
;   Category: Text
;    Summary: Print a character
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The character to be printed
;
; ******************************************************************************

.TT74

 JMP TT26               ; Print the character in A

; ******************************************************************************
;
;       Name: TT43
;       Type: Subroutine
;   Category: Text
;    Summary: Print a two-letter token or recursive token 0-95
;
; ------------------------------------------------------------------------------
;
; Print a two-letter token, or a recursive token where the token number is in
; 0-95 (so the value passed to TT27 is in the range 160-255).
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   One of the following:
;
;                         * 128-159 (two-letter token)
;
;                         * 160-255 (the argument to TT27 that refers to a
;                           recursive token in the range 0-95)
;
; ******************************************************************************

.TT43

 CMP #160               ; If token >= 160, then this is a recursive token, so
 BCS TT47               ; jump to TT47 below to process it

 AND #127               ; This is a two-letter token with number 128-159. The
 ASL A                  ; set of two-letter tokens is stored in a lookup table
                        ; at QQ16, with each token taking up two bytes, so to
                        ; convert this into the token's position in the table,
                        ; we subtract 128 (or just clear bit 7) and multiply
                        ; by 2 (or shift left)

 TAY                    ; Transfer the token's position into Y so we can look
                        ; up the token using absolute indexed mode

 LDA QQ16,Y             ; Get the first letter of the token and print it
 JSR TT27

 LDA QQ16+1,Y           ; Get the second letter of the token

 CMP #'?'               ; If the second letter of the token is a question mark
 BEQ TT48               ; then this is a one-letter token, so just return from
                        ; the subroutine without printing (as TT48 contains an
                        ; RTS)

 JMP TT27               ; Print the second letter and return from the
                        ; subroutine

.TT47

 SBC #160               ; This is a recursive token in the range 160-255, so
                        ; subtract 160 from the argument to get the token
                        ; number 0-95 and fall through into ex to print it

; ******************************************************************************
;
;       Name: ex
;       Type: Subroutine
;   Category: Text
;    Summary: Print a recursive token
;  Deep dive: Printing text tokens
;
; ------------------------------------------------------------------------------
;
; This routine works its way through the recursive text tokens that are stored
; in tokenised form in the table at QQ18, and when it finds token number A,
; it prints it. Tokens are null-terminated in memory and fill three pages,
; but there is no lookup table as that would consume too much memory, so the
; only way to find the correct token is to start at the beginning and look
; through the table byte by byte, counting tokens as we go until we are in the
; right place. This approach might not be terribly speed efficient, but it is
; certainly memory-efficient.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The recursive token to be printed, in the range 0-148
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   TT48                Contains an RTS
;
; ******************************************************************************

.ex

 TAX                    ; Copy the token number into X

 LDA #LO(QQ18)          ; Set V(1 0) to point to the recursive token table at
 STA V                  ; location QQ18
 LDA #HI(QQ18)
 STA V+1

 LDY #0                 ; Set a counter Y to point to the character offset
                        ; as we scan through the table

 TXA                    ; Copy the token number back into A, so both A and X
                        ; now contain the token number we want to print

 BEQ TT50               ; If the token number we want is 0, then we have
                        ; already found the token we are looking for, so jump
                        ; to TT50, otherwise start working our way through the
                        ; null-terminated token table until we find the X-th
                        ; token

.TT51

 LDA (V),Y              ; Fetch the Y-th character from the token table page
                        ; we are currently scanning

 BEQ TT49               ; If the character is null, we've reached the end of
                        ; this token, so jump to TT49

 INY                    ; Increment character pointer and loop back around for
 BNE TT51               ; the next character in this token, assuming Y hasn't
                        ; yet wrapped around to 0

 INC V+1                ; If it has wrapped round to 0, we have just crossed
 BNE TT51               ; into a new page, so increment V+1 so that V points
                        ; to the start of the new page

.TT49

 INY                    ; Increment the character pointer

 BNE TT59               ; If Y hasn't just wrapped around to 0, skip the next
                        ; instruction

 INC V+1                ; We have just crossed into a new page, so increment
                        ; V+1 so that V points to the start of the new page

.TT59

 DEX                    ; We have just reached a new token, so decrement the
                        ; token number we are looking for

 BNE TT51               ; Assuming we haven't yet reached the token number in
                        ; X, look back up to keep fetching characters

.TT50

                        ; We have now reached the correct token in the token
                        ; table, with Y pointing to the start of the token as
                        ; an offset within the page pointed to by V, so let's
                        ; print the recursive token. Because recursive tokens
                        ; can contain other recursive tokens, we need to store
                        ; our current state on the stack, so we can retrieve
                        ; it after printing each character in this token

 TYA                    ; Store the offset in Y on the stack
 PHA

 LDA V+1                ; Store the high byte of V (the page containing the
 PHA                    ; token we have found) on the stack, so the stack now
                        ; contains the address of the start of this token

 LDA (V),Y              ; Load the character at offset Y in the token table,
                        ; which is the next character of this token that we
                        ; want to print

 EOR #RE                ; Tokens are stored in memory having been EOR'd with the
                        ; value of RE - which is 35 for all versions of Elite
                        ; except for NES, where RE is 62 - so we repeat the
                        ; EOR to get the actual character to print

 JSR TT27               ; Print the text token in A, which could be a letter,
                        ; number, control code, two-letter token or another
                        ; recursive token

 PLA                    ; Restore the high byte of V (the page containing the
 STA V+1                ; token we have found) into V+1

 PLA                    ; Restore the offset into Y
 TAY

 INY                    ; Increment Y to point to the next character in the
                        ; token we are printing

 BNE P%+4               ; If Y is zero then we have just crossed into a new
 INC V+1                ; page, so increment V+1 so that V points to the start
                        ; of the new page

 LDA (V),Y              ; Load the next character we want to print into A

 BNE TT50               ; If this is not the null character at the end of the
                        ; token, jump back up to TT50 to print the next
                        ; character, otherwise we are done printing

.TT48

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: SWAPPZERO
;       Type: Subroutine
;   Category: Utility routines
;    Summary: An unused routine that swaps bytes in and out of zero page
;
; ******************************************************************************

.SWAPPZERO

 LDX #K3+1              ; This routine starts copying zero page from $0015 and
                        ; up, using X as an index ???

.SWPZL

 LDA ZP,X               ; These instructions have no effect, as they simply swap
 LDY ZP,X               ; a byte with itself
 STA ZP,X
 STY ZP,X

 INX                    ; Increment the loop counter

 BNE SWPZL              ; Loop back for the next byte

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: DOEXP
;       Type: Subroutine
;   Category: Drawing ships
;    Summary: Draw an exploding ship
;  Deep dive: Drawing explosion clouds
;             Generating random numbers
;
; ******************************************************************************

.EX2

 LDA INWK+31            ; Set bits 5 and 7 of the ship's byte #31 to denote that
 ORA #%10100000         ; the ship is exploding and has been killed
 STA INWK+31

 RTS                    ; Return from the subroutine

.DOEXP

 LDA INWK+31            ; If bit 6 of the ship's byte #31 is clear, then the
 AND #%01000000         ; ship is not already exploding so there is no existing
 BEQ P%+5               ; explosion cloud to remove, so skip the following
                        ; instruction

 JSR PTCLS              ; Call PTCLS to remove the existing cloud by drawing it
                        ; again

 LDA INWK+6             ; Set T = z_lo
 STA T

 LDA INWK+7             ; Set A = z_hi, so (A T) = z

 CMP #32                ; If z_hi < 32, skip the next two instructions
 BCC P%+6

 LDA #$FE               ; Set A = 254 and jump to yy (this BNE is effectively a
 BNE yy                 ; JMP, as A is never zero)

 ASL T                  ; Shift (A T) left twice
 ROL A
 ASL T
 ROL A

 SEC                    ; And then shift A left once more, inserting a 1 into
 ROL A                  ; bit 0

                        ; Overall, the above multiplies A by 8 and makes sure it
                        ; is at least 1, to leave a one-byte distance in A. We
                        ; can use this as the distance for our cloud, to ensure
                        ; that the explosion cloud is visible even for ships
                        ; that blow up a long way away

.yy

 STA Q                  ; Store the distance to the explosion in Q

 LDY #1                 ; Fetch byte #1 of the ship line heap, which contains
 LDA (XX19),Y           ; the cloud counter

 STA frump              ; Store the cloud counter in frump (though this value is
                        ; never read, so this has no effect)

 ADC #4                 ; Add 4 to the cloud counter, so it ticks onwards every
                        ; we redraw it

 BCS EX2                ; If the addition overflowed, jump up to EX2 to update
                        ; the explosion flags and return from the subroutine

 STA (XX19),Y           ; Store the updated cloud counter in byte #1 of the ship
                        ; line heap

 JSR DVID4              ; Calculate the following:
                        ;
                        ;   (P R) = 256 * A / Q
                        ;         = 256 * cloud counter / distance
                        ;
                        ; We are going to use this as our cloud size, so the
                        ; further away the cloud, the smaller it is, and as the
                        ; cloud counter ticks onward, the cloud expands

 LDA P                  ; Set A = P, so we now have:
                        ;
                        ;   (A R) = 256 * cloud counter / distance

 CMP #$1C               ; If A < 28, skip the next two instructions
 BCC P%+6

 LDA #$FE               ; Set A = 254 and skip the following (this BNE is
 BNE LABEL_1            ; effectively a JMP as A is never zero)

 ASL R                  ; Shift (A R) left three times to multiply by 8
 ROL A
 ASL R
 ROL A
 ASL R
 ROL A

                        ; Overall, the above multiplies (A R) by 8 to leave a
                        ; one-byte cloud size in A, given by the following:
                        ;
                        ;   A = 8 * cloud counter / distance

.LABEL_1

 DEY                    ; Decrement Y to 0

 STA (XX19),Y           ; Store the cloud size in byte #0 of the ship line heap

 LDA INWK+31            ; Clear bit 6 of the ship's byte #31 to denote that the
 AND #%10111111         ; explosion has not yet been drawn
 STA INWK+31

 AND #%00001000         ; If bit 3 of the ship's byte #31 is clear, then nothing
 BEQ TT48               ; is being drawn on-screen for this ship anyway, so
                        ; return from the subroutine (as TT48 contains an RTS)

 LDY #2                 ; Otherwise it's time to draw an explosion cloud, so
 LDA (XX19),Y           ; fetch byte #2 of the ship line heap into Y, which we
 TAY                    ; set to the explosion count for this ship (i.e. the
                        ; number of vertices used as origins for explosion
                        ; clouds)
                        ;
                        ; The explosion count is stored as 4 * n + 6, where n is
                        ; the number of vertices, so the following loop copies
                        ; the coordinates of the first n vertices from the heap
                        ; at XX3, which is where we stored all the visible
                        ; vertex coordinates in part 8 of the LL9 routine, and
                        ; sticks them in the ship line heap pointed to by XX19,
                        ; starting at byte #7 (so it leaves the first 6 bytes of
                        ; the ship line heap alone)

.EXL1

 LDA XX3-7,Y            ; Copy byte Y-7 from the XX3 heap, into the Y-th byte of
 STA (XX19),Y           ; the ship line heap

 DEY                    ; Decrement the loop counter

 CPY #6                 ; Keep copying vertex coordinates into the ship line
 BNE EXL1               ; heap until Y = 6 (which will copy n vertices, where n
                        ; is the number of vertices we should be exploding)

 LDA INWK+31            ; Set bit 6 of the ship's byte #31 to denote that the
 ORA #%01000000         ; explosion has been drawn (as it's about to be)
 STA INWK+31

.PTCLS

                        ; This part of the routine actually draws the explosion
                        ; cloud

 LDY #0                 ; Fetch byte #0 of the ship line heap, which contains
 LDA (XX19),Y           ; the cloud size we stored above, and store it in Q
 STA Q

 INY                    ; Increment the index in Y to point to byte #1

 LDA (XX19),Y           ; Fetch byte #1 of the ship line heap, which contains
                        ; the cloud counter. We are now going to process this
                        ; into the number of particles in each vertex's cloud

 BPL P%+4               ; If the cloud counter < 128, then we are in the first
                        ; half of the cloud's existence, so skip the next
                        ; instruction

 EOR #$FF               ; Flip the value of A so that in the second half of the
                        ; cloud's existence, A counts down instead of up

 LSR A                  ; Divide A by 16 so that is has a maximum value of 7
 LSR A
 LSR A
 LSR A

 ORA #1                 ; Make sure A is at least 1 and store it in U, to
 STA U                  ; give us the number of particles in the explosion for
                        ; each vertex

 INY                    ; Increment the index in Y to point to byte #2

 LDA (XX19),Y           ; Fetch byte #2 of the ship line heap, which contains
 STA TGT                ; the explosion count for this ship (i.e. the number of
                        ; vertices used as origins for explosion clouds) and
                        ; store it in TGT

 LDA RAND+1             ; Fetch the current random number seed in RAND+1 and
 PHA                    ; store it on the stack, so we can re-randomise the
                        ; seeds when we are done

 LDY #6                 ; Set Y = 6 to point to the byte before the first vertex
                        ; coordinate we stored on the ship line heap above (we
                        ; increment it below so it points to the first vertex)

.EXL5

 LDX #3                 ; We are about to fetch a pair of coordinates from the
                        ; ship line heap, so set a counter in X for 4 bytes

.EXL3

 INY                    ; Increment the index in Y so it points to the next byte
                        ; from the coordinate we are copying

 LDA (XX19),Y           ; Copy the Y-th byte from the ship line heap to the X-th
 STA K3,X               ; byte of K3

 DEX                    ; Decrement the X index

 BPL EXL3               ; Loop back to EXL3 until we have copied all four bytes

                        ; The above loop copies the vertex coordinates from the
                        ; ship line heap to K3, reversing them as we go, so it
                        ; sets the following:
                        ;
                        ;   K3+3 = x_lo
                        ;   K3+2 = x_hi
                        ;   K3+1 = y_lo
                        ;   K3+0 = y_hi

 STY CNT                ; Set CNT to the index that points to the next vertex on
                        ; the ship line heap

 LDY #2                 ; Set Y = 2, which we will use to point to bytes #3 to
                        ; #6, after incrementing it

                        ; This next loop copies bytes #3 to #6 from the ship
                        ; line heap into the four random number seeds in RAND to
                        ; RAND+3, EOR'ing them with the vertex index so they are
                        ; different for every vertex. This enables us to
                        ; generate random numbers for drawing each vertex that
                        ; are random but repeatable, which we need when we
                        ; redraw the cloud to remove it
                        ;
                        ; Note that we haven't actually set the values of bytes
                        ; #3 to #6 in the ship line heap, so we have no idea
                        ; what they are, we just use what's already there. But
                        ; the fact that those bytes are stored for this ship
                        ; means we can repeat the random generation of the
                        ; cloud, which is the important bit

.EXL2

 INY                    ; Increment the index in Y so it points to the next
                        ; random number seed to copy

 LDA (XX19),Y           ; Fetch the Y-th byte from the ship line heap

 EOR CNT                ; EOR with the vertex index, so the seeds are different
                        ; for each vertex

 STA $FFFF,Y            ; Y is going from 3 to 6, so this stores the four bytes
                        ; in memory locations $02, $03, $04 and $05, which are
                        ; the memory locations of RAND through RAND+3

 CPY #6                 ; Loop back to EXL2 until Y = 6, which means we have
 BNE EXL2               ; copied four bytes

 LDY U                  ; Set Y to the number of particles in the explosion for
                        ; each vertex, which we stored in U above. We will now
                        ; use this as a loop counter to iterate through all the
                        ; particles in the explosion

 STY CNT2               ; Store the number of explosion particles in CNT2, to
                        ; use this as a loop counter to iterate through all the
                        ; particles in the explosion

.EXL4

 CLC                    ; This contains the code from the DORND2 routine, so
 LDA RAND               ; this section is exactly equivalent to a JSR DORND2
 ROL A                  ; call, but is slightly faster as it's been inlined
 TAX                    ; (so it sets A and X to random values, making sure
 ADC RAND+2             ; the C flag doesn't affect the outcome)
 STA RAND
 STX RAND+2
 LDA RAND+1
 TAX
 ADC RAND+3
 STA RAND+1
 STX RAND+3

 AND #$0C               ; ???
 ORA #$10
 STA COL

 LDA K3+1               ; Set (A R) = (y_hi y_lo)
 STA R                  ;           = y
 LDA K3

 JSR EXS1               ; Set (A X) = (A R) +/- random * cloud size
                        ;           = y +/- random * cloud size

 BNE EX11               ; If A is non-zero, the particle is off-screen as the
                        ; coordinate is bigger than 255), so jump to EX11 to do
                        ; the next particle

 CPX #2*Y-1             ; If X > the y-coordinate of the bottom of the screen,
 BCS EX11               ; the particle is off the bottom of the screen, so jump
                        ; to EX11 to do the next particle

                        ; Otherwise X contains a random y-coordinate within the
                        ; cloud

 STX Y1                 ; Set Y1 = our random y-coordinate within the cloud

 LDA K3+3               ; Set (A R) = (x_hi x_lo)
 STA R
 LDA K3+2

 JSR EXS1               ; Set (A X) = (A R) +/- random * cloud size
                        ;           = x +/- random * cloud size

 BNE EX4                ; If A is non-zero, the particle is off-screen as the
                        ; coordinate is bigger than 255), so jump to EX11 to do
                        ; the next particle

                        ; Otherwise X contains a random x-coordinate within the
                        ; cloud

 LDA Y1                 ; Set A = our random y-coordinate within the cloud

 JSR CPIX               ; Draw a point at screen coordinate (X, A) ???

.EX4

 DEC CNT2               ; Decrement the loop counter in CNT2 for the next
                        ; particle

 BPL EXL4               ; Loop back to EXL4 until we have done all the particles
                        ; in the cloud

 LDY CNT                ; Set Y to the index that points to the next vertex on
                        ; the ship line heap

 CPY TGT                ; If Y < TGT, which we set to the explosion count for
 BCC EXL5               ; this ship (i.e. the number of vertices used as origins
                        ; for explosion clouds), loop back to EXL5 to do a cloud
                        ; for the next vertex

 PLA                    ; Restore the current random number seed to RAND+1 that
 STA RAND+1             ; we stored at the start of the routine

 LDA K%+6               ; Store the z_lo coordinate for the planet (which will
 STA RAND+3             ; be pretty random) in the RAND+3 seed

 RTS                    ; Return from the subroutine

.EX11

 CLC                    ; This contains the code from the DORND2 routine, so
 LDA RAND               ; this section is exactly equivalent to a JSR DORND2
 ROL A                  ; call, but is slightly faster as it's been inlined
 TAX                    ; (so it sets A and X to random values, making sure
 ADC RAND+2             ; the C flag doesn't affect the outcome)
 STA RAND
 STX RAND+2
 LDA RAND+1
 TAX
 ADC RAND+3
 STA RAND+1
 STX RAND+3

 JMP EX4                ; We just skipped a particle, so jump up to EX4 to do
                        ; the next one

.EXS1

                        ; This routine calculates the following:
                        ;
                        ;   (A X) = (A R) +/- random * cloud size
                        ;
                        ; returning with the flags set for the high byte in A

 STA S                  ; Store A in S so we can use it later

 CLC                    ; This contains the code from the DORND2 routine, so
 LDA RAND               ; this section is exactly equivalent to a JSR DORND2
 ROL A                  ; call, but is slightly faster as it's been inlined
 TAX                    ; (so it sets A and X to random values, making sure
 ADC RAND+2             ; the C flag doesn't affect the outcome)
 STA RAND
 STX RAND+2
 LDA RAND+1
 TAX
 ADC RAND+3
 STA RAND+1
 STX RAND+3

 ROL A                  ; Set A = A * 2

 BCS EX5                ; If bit 7 of A was set (50% chance), jump to EX5

 JSR FMLTU              ; Set A = A * Q / 256
                        ;       = random << 1 * projected cloud size / 256

 ADC R                  ; Set (A X) = (S R) + A
 TAX                    ;           = (S R) + random * projected cloud size
                        ;
                        ; where S contains the argument A, starting with the low
                        ; bytes

 LDA S                  ; And then the high bytes
 ADC #0

 RTS                    ; Return from the subroutine

.EX5

 JSR FMLTU              ; Set T = A * Q / 256
 STA T                  ;       = random << 1 * projected cloud size / 256

 LDA R                  ; Set (A X) = (S R) - T
 SBC T                  ;
 TAX                    ; where S contains the argument A, starting with the low
                        ; bytes

 LDA S                  ; And then the high bytes
 SBC #0

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: exlook
;       Type: Variable
;   Category: Drawing ships
;    Summary: An unused block of explosion data
;
; ******************************************************************************

.exlook

 EQUB 0                 ; These bytes appear to be unused, and are left over
 EQUB 2                 ; from the Commodore 64 version of Elite

; ******************************************************************************
;
;       Name: SOS1
;       Type: Subroutine
;   Category: Universe
;    Summary: Update the missile indicators, set up the planet data block
;
; ------------------------------------------------------------------------------
;
; Update the missile indicators, and set up a data block for the planet, but
; only setting the pitch and roll counters to 127 (no damping).
;
; ******************************************************************************

.SOS1

 JSR msblob             ; Reset the dashboard's missile indicators so none of
                        ; them are targeted

 LDA #127               ; Set the pitch and roll counters to 127, so that's a
 STA INWK+29            ; clockwise roll and a diving pitch with no damping, so
 STA INWK+30            ; the planet's rotation doesn't slow down

 LDA tek                ; Set A = 128 or 130 depending on bit 1 of the system's
 AND #%00000010         ; tech level in tek
 ORA #%10000000

 JMP NWSHP              ; Add a new planet to our local bubble of universe,
                        ; with the planet type defined by A (128 is a planet
                        ; with an equator and meridian, 130 is a planet with
                        ; a crater)

; ******************************************************************************
;
;       Name: SOLAR
;       Type: Subroutine
;   Category: Universe
;    Summary: Set up various aspects of arriving in a new system
;
; ------------------------------------------------------------------------------
;
; Halve our legal status, update the missile indicators, and set up data blocks
; and slots for the planet and sun.
;
; ******************************************************************************

.SOLAR

 LDA TRIBBLE            ; If we have no Trumbles in the hold, skip to nobirths
 BEQ nobirths

                        ; If we get here then we have Trumbles in the hold, so
                        ; this is where they breed (though we never get here in
                        ; the Master version as the number of Trumbles is always
                        ; zero)

 LDA #0                 ; Trumbles eat food and narcotics during the hyperspace
 STA QQ20               ; journey, so zero the amount of food and narcotics in
 STA QQ20+6             ; the hold

 JSR DORND              ; Take the number of Trumbles from TRIBBLE(1 0), add a
 AND #15                ; random number between 4 and 15, and double the result,
 ADC TRIBBLE            ; storing the resulting number in TRIBBLE(1 0)
 ORA #4                 ;
 ROL A                  ; We start with the low byte
 STA TRIBBLE

 ROL TRIBBLE+1          ; And then do the high byte

 BPL P%+5               ; If bit 7 of the high byte is set, then rotate the high
 ROR TRIBBLE+1          ; byte back to the right, so the number of Trumbles is
                        ; always positive

.nobirths

 LSR FIST               ; Halve our legal status in FIST, making us less bad,
                        ; and moving bit 0 into the C flag (so every time we
                        ; arrive in a new system, our legal status improves a
                        ; bit)

 JSR ZINF               ; Call ZINF to reset the INWK ship workspace, which
                        ; doesn't affect the C flag

 LDA QQ15+1             ; Fetch s0_hi

 AND #%00000011         ; Extract bits 0-1 (which also help to determine the
                        ; economy), which will be between 0 and 3

 ADC #3                 ; Add 3 + C, to get a result between 3 and 7, clearing
                        ; the C flag in the process

 STA INWK+8             ; Store the result in z_sign in byte #6

 ROR A                  ; Halve A, rotating in the C flag (which is clear) and
 STA INWK+2             ; store in both x_sign and y_sign, moving the planet to
 STA INWK+5             ; the upper right

 JSR SOS1               ; Call SOS1 to set up the planet's data block and add it
                        ; to FRIN, where it will get put in the first slot as
                        ; it's the first one to be added to our local bubble of
                        ; this new system's universe

 LDA QQ15+3             ; Fetch s1_hi, extract bits 0-2, set bits 0 and 7 and
 AND #%00000111         ; store in z_sign, so the sun is behind us at a distance
 ORA #%10000001         ; of 1 to 7
 STA INWK+8

 LDA QQ15+5             ; Fetch s2_hi, extract bits 0-1 and store in x_sign and
 AND #%00000011         ; y_sign, so the sun is either dead centre in our rear
 STA INWK+2             ; laser crosshairs, or off to the top left by a distance
 STA INWK+1             ; of 1 or 2 when we look out the back

 LDA #0                 ; Set the pitch and roll counters to 0 (no rotation)
 STA INWK+29
 STA INWK+30

 LDA #129               ; Set A = 129, the ship type for the sun

 JSR NWSHP              ; Call NWSHP to set up the sun's data block and add it
                        ; to FRIN, where it will get put in the second slot as
                        ; it's the second one to be added to our local bubble
                        ; of this new system's universe

; ******************************************************************************
;
;       Name: NWSTARS
;       Type: Subroutine
;   Category: Stardust
;    Summary: Initialise the stardust field
;
; ------------------------------------------------------------------------------
;
; This routine is called when the space view is initialised in routine LOOK1.
;
; ******************************************************************************

.NWSTARS

 LDA QQ11               ; If this is not a space view, jump to WPSHPS to skip
;ORA MJ                 ; the initialisation of the SX, SY and SZ tables. The OR
 BNE WPSHPS             ; instruction is commented out in the original source,
                        ; but it would have the effect of also skipping the
                        ; initialisation if we had mis-jumped into witchspace

; ******************************************************************************
;
;       Name: nWq
;       Type: Subroutine
;   Category: Stardust
;    Summary: Create a random cloud of stardust
;
; ------------------------------------------------------------------------------
;
; Create a random cloud of stardust containing the correct number of dust
; particles, i.e. NOSTM of them, which is 3 in witchspace and 18 (#NOST) in
; normal space. Also clears the scanner and initialises the LSO block.
;
; This is called by the DEATH routine when it displays our untimely demise.
;
; ******************************************************************************

.nWq

 LDY NOSTM              ; Set Y to the current number of stardust particles, so
                        ; we can use it as a counter through all the stardust

.SAL4

 JSR DORND              ; Set A and X to random numbers

 ORA #8                 ; Set A so that it's at least 8

 STA SZ,Y               ; Store A in the Y-th particle's z_hi coordinate at
                        ; SZ+Y, so the particle appears in front of us

 STA ZZ                 ; Set ZZ to the particle's z_hi coordinate

 JSR DORND              ; Set A and X to random numbers

 STA SX,Y               ; Store A in the Y-th particle's x_hi coordinate at
                        ; SX+Y, so the particle appears in front of us

 STA X1                 ; Set X1 to the particle's x_hi coordinate

 JSR DORND              ; Set A and X to random numbers

 STA SY,Y               ; Store A in the Y-th particle's y_hi coordinate at
                        ; SY+Y, so the particle appears in front of us

 STA Y1                 ; Set Y1 to the particle's y_hi coordinate

 JSR PIXEL2             ; Draw a stardust particle at (X1,Y1) with distance ZZ

 DEY                    ; Decrement the counter to point to the next particle of
                        ; stardust

 BNE SAL4               ; Loop back to SAL4 until we have randomised all the
                        ; stardust particles

;JSR PBFL               ; This instruction is commented out in the original
                        ; source

                        ; Fall through into WPSHPS to clear the scanner and
                        ; reset the LSO block

; ******************************************************************************
;
;       Name: WPSHPS
;       Type: Subroutine
;   Category: Dashboard
;    Summary: Clear the scanner, reset the ball line and sun line heaps
;
; ------------------------------------------------------------------------------
;
; Remove all ships from the scanner, reset the sun line heap at LSO, and reset
; the ball line heap at LSX2 and LSY2.
;
; ******************************************************************************

.WPSHPS

 LDX #0                 ; Set up a counter in X to work our way through all the
                        ; ship slots in FRIN

.WSL1

 LDA FRIN,X             ; Fetch the ship type in slot X

 BEQ WS2                ; If the slot contains 0 then it is empty and we have
                        ; checked all the slots (as they are always shuffled
                        ; down in the main loop to close up and gaps), so jump
                        ; to WS2 as we are done

 BMI WS1                ; If the slot contains a ship type with bit 7 set, then
                        ; it contains the planet or the sun, so jump down to WS1
                        ; to skip this slot, as the planet and sun don't appear
                        ; on the scanner

 STA TYPE               ; Store the ship type in TYPE

 JSR GINF               ; Call GINF to get the address of the data block for
                        ; ship slot X and store it in INF

 LDY #31                ; We now want to copy the first 32 bytes from the ship's
                        ; data block into INWK, so set a counter in Y

.WSL2

 LDA (INF),Y            ; Copy the Y-th byte from the data block pointed to by
 STA INWK,Y             ; INF into the Y-th byte of INWK workspace

 DEY                    ; Decrement the counter to point at the next byte

 BPL WSL2               ; Loop back to WSL2 until we have copied all 32 bytes

 STX XSAV               ; Store the ship slot number in XSAV while we call SCAN

 JSR SCAN               ; Call SCAN to plot this ship on the scanner, which will
                        ; remove it as it's plotted with EOR logic

 LDX XSAV               ; Restore the ship slot number from XSAV into X

 LDY #31                ; Clear bits 3, 4 and 6 in the ship's byte #31, which
 LDA (INF),Y            ; stops drawing the ship on-screen (bit 3), hides it
 AND #%10100111         ; from the scanner (bit 4) and stops any lasers firing
 STA (INF),Y            ; (bit 6)

.WS1

 INX                    ; Increment X to point to the next ship slot

 BNE WSL1               ; Loop back up to process the next slot (this BNE is
                        ; effectively a JMP as X will never be zero)

.WS2

 LDX #0                 ; Reset the ball line heap by setting the ball line heap
 STX LSP                ; pointer to 0

 DEX                    ; Set X = $FF

 STX LSX2               ; Set LSX2 = LSY2 = $FF to clear the ball line heap
 STX LSY2

                        ; Fall through into FLFLLS to reset the LSO block

; ******************************************************************************
;
;       Name: FLFLLS
;       Type: Subroutine
;   Category: Drawing suns
;    Summary: Reset the sun line heap
;
; ------------------------------------------------------------------------------
;
; Reset the sun line heap at LSO by zero-filling it and setting the first byte
; to $FF.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   A                   A is set to 0
;
; ******************************************************************************

.FLFLLS

 LDY #199               ; ???

 LDA #0                 ; Set A to 0 so we can zero-fill the LSO block

.SAL6

 STA LSO,Y              ; Set the Y-th byte of the LSO block to 0

 DEY                    ; Decrement the counter

 BNE SAL6               ; Loop back until we have filled all the way to LSO+1

 DEY                    ; Decrement Y to value of $FF (as we exit the above loop
                        ; with Y = 0)

 STY LSX                ; Set the first byte of the LSO block, which has its own
                        ; label LSX, to $FF, to indicate that the sun line heap
                        ; is empty

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: DET1
;       Type: Subroutine
;   Category: Drawing the screen
;    Summary: Show or hide the dashboard (for when we die)
;
; ------------------------------------------------------------------------------
;
; This subroutine does nothing in the Commodore 64 and Apple II versions of
; Elite, as the dashboard is not hidden when we die.
;
; ******************************************************************************

.DET1

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: SHD
;       Type: Subroutine
;   Category: Flight
;    Summary: Charge a shield and drain some energy from the energy banks
;
; ------------------------------------------------------------------------------
;
; Charge up a shield, and if it needs charging, drain some energy from the
; energy banks.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The value of the shield to recharge
;
; ******************************************************************************

 DEX                    ; Increment the shield value so that it doesn't go past
                        ; a maximum of 255

 RTS                    ; Return from the subroutine

.SHD

 INX                    ; Increment the shield value

 BEQ SHD-2              ; If the shield value is 0 then this means it was 255
                        ; before, which is the maximum value, so jump to SHD-2
                        ; to bring it back down to 258 and return

                        ; Otherwise fall through into DENGY to drain our energy
                        ; to pay for all this shield charging

; ******************************************************************************
;
;       Name: DENGY
;       Type: Subroutine
;   Category: Flight
;    Summary: Drain some energy from the energy banks
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   Z flag              Set if we have no energy left, clear otherwise
;
; ******************************************************************************

.DENGY

 DEC ENERGY             ; Decrement the energy banks in ENERGY

 PHP                    ; Save the flags on the stack

 BNE paen2              ; If the energy levels are not yet zero, skip the
                        ; following instruction

 INC ENERGY             ; The minimum allowed energy level is 1, and we just
                        ; reached 0, so increment ENERGY back to 1

.paen2

 PLP                    ; Restore the flags from the stack, so we return with
                        ; the Z flag from the DEC instruction above

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: COMPAS
;       Type: Subroutine
;   Category: Dashboard
;    Summary: Update the compass
;
; ******************************************************************************

.COMPAS

 JSR DOT                ; Call DOT to redraw (i.e. remove) the current compass
                        ; dot

 LDA SSPR               ; If we are inside the space station safe zone, jump to
 BNE SP1                ; SP1 to draw the space station on the compass

 JSR SPS1               ; Otherwise we need to draw the planet on the compass,
                        ; so first call SPS1 to calculate the vector to the
                        ; planet and store it in XX15

 JMP SP2                ; Jump to SP2 to draw XX15 on the compass, returning
                        ; from the subroutine using a tail call

; ******************************************************************************
;
;       Name: SPS2
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (Y X) = A / 10
;
; ------------------------------------------------------------------------------
;
; Calculate the following, where A is a sign-magnitude 8-bit integer and the
; result is a signed 16-bit integer:
;
;   (Y X) = A / 10
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              The C flag is cleared
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   COR1                Contains an RTS
;
; ******************************************************************************

.SPS2

 ASL A                  ; Set X = |A| * 2, and set the C flag to the sign bit of
 TAX                    ; A

 LDA #0                 ; Set Y to have the sign bit from A in bit 7, with the
 ROR A                  ; rest of its bits zeroed, so Y now contains the sign of
 TAY                    ; the original argument

 LDA #20                ; Set Q = 20
 STA Q

 TXA                    ; Copy X into A, so A now contains the argument A * 2

 JSR DVID4              ; Calculate the following:
                        ;
                        ;   P = A / Q
                        ;     = |argument A| * 2 / 20
                        ;     = |argument A| / 10

 LDX P                  ; Set X to the result

 TYA                    ; If the sign of the original argument A is negative,
 BMI LL163              ; jump to LL163 to flip the sign of the result

 LDY #0                 ; Set the high byte of the result to 0, as the result is
                        ; positive

 RTS                    ; Return from the subroutine

.LL163

 LDY #$FF               ; The result is negative, so set the high byte to $FF

 TXA                    ; Flip the low byte and add 1 to get the negated low
 EOR #$FF               ; byte, using two's complement
 TAX
 INX

.COR1

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: SPS4
;       Type: Subroutine
;   Category: Maths (Geometry)
;    Summary: Calculate the vector to the space station
;
; ------------------------------------------------------------------------------
;
; Calculate the vector between our ship and the space station and store it in
; XX15.
;
; ******************************************************************************

.SPS4

 LDX #8                 ; First we need to copy the space station's coordinates
                        ; into K3, so set a counter to copy the first 9 bytes
                        ; (the 3-byte x, y and z coordinates) from the station's
                        ; data block at K% + NI% into K3

.SPL1

 LDA K%+NI%,X           ; Copy the X-th byte from the station's data block at
 STA K3,X               ; K% + NI% to the X-th byte of K3

 DEX                    ; Decrement the loop counter

 BPL SPL1               ; Loop back to SPL1 until we have copied all 9 bytes

 JMP TAS2               ; Call TAS2 to build XX15 from K3, returning from the
                        ; subroutine using a tail call

; ******************************************************************************
;
;       Name: SP1
;       Type: Subroutine
;   Category: Dashboard
;    Summary: Draw the space station on the compass
;
; ******************************************************************************

.SP1

 JSR SPS4               ; Call SPS4 to calculate the vector to the space station
                        ; and store it in XX15

                        ; Fall through into SP2 to draw XX15 on the compass

; ******************************************************************************
;
;       Name: SP2
;       Type: Subroutine
;   Category: Dashboard
;    Summary: Draw a dot on the compass, given the planet/station vector
;
; ------------------------------------------------------------------------------
;
; Draw a dot on the compass to represent the planet or station, whose normalised
; vector is in XX15.
;
;   XX15 to XX15+2      The normalised vector to the planet or space station,
;                       stored as x in XX15, y in XX15+1 and z in XX15+2
;
; ******************************************************************************

.SP2

 LDA XX15               ; Set A to the x-coordinate of the planet or station to
                        ; show on the compass, which will be in the range -96 to
                        ; +96 as the vector has been normalised

 JSR SPS2               ; Set (Y X) = A / 10, so X will be from -9 to +9, which
                        ; is the x-offset from the centre of the compass of the
                        ; dot we want to draw. Returns with the C flag clear

 TXA                    ; Set COMX = 195 + X, as 186 is the pixel x-coordinate
 ADC #195               ; of the leftmost dot possible on the compass, and X can
 STA COMX               ; be -9, which would be 195 - 9 = 186. This also means
                        ; that the highest value for COMX is 195 + 9 = 204,
                        ; which is the pixel x-coordinate of the rightmost dot
                        ; in the compass... but the compass dot is actually two
                        ; pixels wide, so the compass dot can overlap the right
                        ; edge of the compass, but not the left edge

 LDA XX15+1             ; Set A to the y-coordinate of the planet or station to
                        ; show on the compass, which will be in the range -96 to
                        ; +96 as the vector has been normalised

 JSR SPS2               ; Set (Y X) = A / 10, so X will be from -9 to +9, which
                        ; is the x-offset from the centre of the compass of the
                        ; dot we want to draw. Returns with the C flag clear

 STX T                  ; Set COMY = 148 - X, as 147 is the pixel y-coordinate
 LDA #148               ; of the centre of the compass, the C flag is clear,
 SBC T                  ; and the y-axis needs to be flipped around (because
 STA COMY               ; when the planet or station is above us, and the
                        ; vector is therefore positive, we want to show the dot
                        ; higher up on the compass, which has a smaller pixel
                        ; y-coordinate). So this calculation does this:
                        ;
                        ;   COMY = 148 - X - (1 - 0) = 147 - X

 LDA #$60               ; Set A to yellow, the colour for when the planet or
                        ; station in the compass is in front of us ???

 LDX XX15+2             ; If the z-coordinate of the XX15 vector is positive,
 BPL P%+3               ; skip the following instruction

 LSR A                  ; The z-coordinate of XX15 is negative, so the planet or
                        ; station is behind us and the compass dot should be in
                        ; green, so set A accordingly ???

 STA COMC               ; Store the compass colour in COMC

                        ; Fall through into DOT to draw the dot on the compass

; ******************************************************************************
;
;       Name: DOT
;       Type: Subroutine
;   Category: Dashboard
;    Summary: Draw a dash on the compass
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   COMX                The screen pixel x-coordinate of the dash
;
;   COMY                The screen pixel y-coordinate of the dash
;
;   COMC                The colour and thickness of the dash: ???
;
;                         * $F0 = a double-height dash in yellow/white, for when
;                           the object in the compass is in front of us
;
;                         * $FF = a single-height dash in green/cyan, for when
;                           the object in the compass is behind us
;
; ******************************************************************************

.DOT

 LDA COMC               ; ???
 BEQ COR1
 STA ZZ

 LDA COMY               ; Set A = COMY, the y-coordinate of the dash

 LDX COMX               ; Set X = COMX, the x-coordinate of the dash

 JMP PIXEL              ; ???

; ******************************************************************************
;
;       Name: OOPS
;       Type: Subroutine
;   Category: Flight
;    Summary: Take some damage
;
; ------------------------------------------------------------------------------
;
; We just took some damage, so reduce the shields if we have any, or reduce the
; energy levels and potentially take some damage to the cargo if we don't.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The amount of damage to take
;
;   INF                 The address of the ship block for the ship that attacked
;                       us, or the ship that we just ran into
;
; ******************************************************************************

.OOPS

 STA T                  ; Store the amount of damage in T

 LDX #0                 ; Fetch byte #8 (z_sign) for the ship attacking us, and
 LDY #8                 ; set X = 0
 LDA (INF),Y

 BMI OO1                ; If A is negative, then we got hit in the rear, so jump
                        ; to OO1 to process damage to the aft shield

 LDA FSH                ; Otherwise the forward shield was damaged, so fetch the
 SBC T                  ; shield strength from FSH and subtract the damage in T

 BCC OO2                ; If the C flag is clear then this amount of damage was
                        ; too much for the shields, so jump to OO2 to set the
                        ; shield level to 0 and start taking damage directly
                        ; from the energy banks

 STA FSH                ; Store the new value of the forward shield in FSH

 RTS                    ; Return from the subroutine

.OO2

 LDX #0                 ; Set the forward shield to 0
 STX FSH

 BCC OO3                ; Jump to OO3 to start taking damage directly from the
                        ; energy banks (this BCC is effectively a JMP as the C
                        ; flag is clear, as we jumped to OO2 with a BCC)

.OO1

 LDA ASH                ; The aft shield was damaged, so fetch the shield
 SBC T                  ; strength from ASH and subtract the damage in T

 BCC OO5                ; If the C flag is clear then this amount of damage was
                        ; too much for the shields, so jump to OO5 to set the
                        ; shield level to 0 and start taking damage directly
                        ; from the energy banks

 STA ASH                ; Store the new value of the aft shield in ASH

 RTS                    ; Return from the subroutine

.OO5

 LDX #0                 ; Set the forward shield to 0
 STX ASH

.OO3

 ADC ENERGY             ; A is negative and contains the amount by which the
 STA ENERGY             ; damage overwhelmed the shields, so this drains the
                        ; energy banks by that amount (and because the energy
                        ; banks are shown over four indicators rather than one,
                        ; but with the same value range of 0-255, energy will
                        ; appear to drain away four times faster than the
                        ; shields did)

 BEQ P%+4               ; If we have just run out of energy, skip the next
                        ; instruction to jump straight to our death

 BCS P%+5               ; If the C flag is set, then subtracting the damage from
                        ; the energy banks didn't underflow, so we had enough
                        ; energy to survive, and we can skip the next
                        ; instruction to make a sound and take some damage

 JMP DEATH              ; Otherwise our energy levels are either 0 or negative,
                        ; and in either case that means we jump to our DEATH,
                        ; returning from the subroutine using a tail call

 JSR EXNO3              ; We didn't die, so call EXNO3 to make the sound of a
                        ; collision

 JMP OUCH               ; And jump to OUCH to take damage and return from the
                        ; subroutine using a tail call

; ******************************************************************************
;
;       Name: SPS3
;       Type: Subroutine
;   Category: Maths (Geometry)
;    Summary: Copy a space coordinate from the K% block into K3
;
; ------------------------------------------------------------------------------
;
; Copy one of the planet's coordinates into the corresponding location in the
; temporary variable K3. The high byte and absolute value of the sign byte are
; copied into the first two K3 bytes, and the sign of the sign byte is copied
; into the highest K3 byte.
;
; The comments below are written for copying the planet's x-coordinate into
; K3(2 1 0).
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   Determines which coordinate to copy, and to where:
;
;                         * X = 0 copies (x_sign, x_hi) into K3(2 1 0)
;
;                         * X = 3 copies (y_sign, y_hi) into K3(5 4 3)
;
;                         * X = 6 copies (z_sign, z_hi) into K3(8 7 6)
;
; ******************************************************************************

.SPS3

 LDA K%+1,X             ; Copy x_hi into K3+X
 STA K3,X

 LDA K%+2,X             ; Set A = Y = x_sign
 TAY

 AND #%01111111         ; Set K3+1 = |x_sign|
 STA K3+1,X

 TYA                    ; Set K3+2 = the sign of x_sign
 AND #%10000000
 STA K3+2,X

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: NWSPS
;       Type: Subroutine
;   Category: Universe
;    Summary: Add a new space station to our local bubble of universe
;
; ******************************************************************************

.NWSPS

 JSR SPBLB              ; Light up the space station bulb on the dashboard

 LDX #%10000001         ; Set the AI flag in byte #32 to %10000001 (hostile,
 STX INWK+32            ; no AI, has an E.C.M.)

 LDX #0                 ; Set pitch counter to 0 (no pitch, roll only)
 STX INWK+30

 STX NEWB               ; Set NEWB to %00000000, though this gets overridden by
                        ; the default flags from E% in NWSHP below

;STX INWK+31            ; This instruction is commented out in the original
                        ; source. It would set the exploding state and missile
                        ; count to 0

 STX FRIN+1             ; Set the second slot in the FRIN table to 0, so when we
                        ; fall through into NWSHP below, the new station that
                        ; gets created will go into slot FRIN+1, as this will be
                        ; the first empty slot that the routine finds

 DEX                    ; Set the roll counter to 255 (maximum anti-clockwise
 STX INWK+29            ; roll with no damping)

 LDX #10                ; Call NwS1 to flip the sign of nosev_x_hi (byte #10)
 JSR NwS1

 JSR NwS1               ; And again to flip the sign of nosev_y_hi (byte #12)

 JSR NwS1               ; And again to flip the sign of nosev_z_hi (byte #14)

 LDA spasto             ; Copy the address of the Coriolis space station's ship
 STA XX21+2*SST-2       ; blueprint from spasto to the #SST entry in the
 LDA spasto+1           ; blueprint lookup table at XX21, so when we spawn a
 STA XX21+2*SST-1       ; ship of type #SST, it will be a Coriolis station

 LDA tek                ; If the system's tech level in tek is less than 10,
 CMP #10                ; jump to notadodo, so tech levels 0 to 9 have Coriolis
 BCC notadodo           ; stations, while 10 and above will have Dodo stations

 LDA XX21+2*DOD-2       ; Copy the address of the Dodo space station's ship
 STA XX21+2*SST-2       ; blueprint from spasto to the #SST entry in the
 LDA XX21+2*DOD-1       ; blueprint lookup table at XX21, so when we spawn a
 STA XX21+2*SST-1       ; ship of type #SST, it will be a Dodo station

.notadodo

 LDA #LO(LSO)           ; Set bytes #33 and #34 to point to LSO for the ship
 STA INWK+33            ; line heap for the space station
 LDA #HI(LSO)
 STA INWK+34

 LDA #SST               ; Set A to the space station type, and fall through
                        ; into NWSHP to finish adding the space station to the
                        ; universe

; ******************************************************************************
;
;       Name: NWSHP
;       Type: Subroutine
;   Category: Universe
;    Summary: Add a new ship to our local bubble of universe
;
; ------------------------------------------------------------------------------
;
; This creates a new block of ship data in the K% workspace, allocates a new
; block in the ship line heap at WP, adds the new ship's type into the first
; empty slot in FRIN, and adds a pointer to the ship data into UNIV. If there
; isn't enough free memory for the new ship, it isn't added.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The type of the ship to add (see variable XX21 for a
;                       list of ship types)
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              Set if the ship was successfully added, clear if it
;                       wasn't (as there wasn't enough free memory)
;
;   INF                 Points to the new ship's data block in K%
;
; ******************************************************************************

.NWSHP

 STA T                  ; Store the ship type in location T

 LDX #0                 ; Before we can add a new ship, we need to check
                        ; whether we have an empty slot we can put it in. To do
                        ; this, we need to loop through all the slots to look
                        ; for an empty one, so set a counter in X that starts
                        ; from the first slot at 0. When ships are killed, then
                        ; the slots are shuffled down by the KILLSHP routine, so
                        ; the first empty slot will always come after the last
                        ; filled slot. This allows us to tack the new ship's
                        ; data block and ship line heap onto the end of the
                        ; existing ship data and heap, as shown in the memory
                        ; map below

.NWL1

 LDA FRIN,X             ; Load the ship type for the X-th slot

 BEQ NW1                ; If it is zero, then this slot is empty and we can use
                        ; it for our new ship, so jump down to NW1

 INX                    ; Otherwise increment X to point to the next slot

 CPX #NOSH              ; If we haven't reached the last slot yet, loop back up
 BCC NWL1               ; to NWL1 to check the next slot (note that this means
                        ; only slots from 0 to #NOSH - 1 are populated by this
                        ; routine, but there is one more slot reserved in FRIN,
                        ; which is used to identify the end of the slot list
                        ; when shuffling the slots down in the KILLSHP routine)

.NW3

 CLC                    ; Otherwise we don't have an empty slot, so we can't
 RTS                    ; add a new ship, so clear the C flag to indicate that
                        ; we have not managed to create the new ship, and return
                        ; from the subroutine

.NW1

                        ; If we get here, then we have found an empty slot at
                        ; index X, so we can go ahead and create our new ship.
                        ; We do that by creating a ship data block at INWK and,
                        ; when we are done, copying the block from INWK into
                        ; the K% workspace (specifically, to INF)

 JSR GINF               ; Get the address of the data block for ship slot X
                        ; (which is in workspace K%) and store it in INF

 LDA T                  ; If the type of ship that we want to create is
 BMI NW2                ; negative, then this indicates a planet or sun, so
                        ; jump down to NW2, as the next section sets up a ship
                        ; data block, which doesn't apply to planets and suns,
                        ; as they don't have things like shields, missiles,
                        ; vertices and edges

                        ; This is a ship, so first we need to set up various
                        ; pointers to the ship blueprint we will need. The
                        ; blueprints for each ship type in Elite are stored
                        ; in a table at location XX21, so refer to the comments
                        ; on that variable for more details on the data we're
                        ; about to access

 ASL A                  ; Set Y = ship type * 2
 TAY

 LDA XX21-1,Y           ; The ship blueprints at XX21 start with a lookup
                        ; table that points to the individual ship blueprints,
                        ; so this fetches the high byte of this particular ship
                        ; type's blueprint

 BEQ NW3                ; If the high byte is 0 then this is not a valid ship
                        ; type, so jump to NW3 to clear the C flag and return
                        ; from the subroutine

 STA XX0+1              ; This is a valid ship type, so store the high byte in
                        ; XX0+1

 LDA XX21-2,Y           ; Fetch the low byte of this particular ship type's
 STA XX0                ; blueprint and store it in XX0, so XX0(1 0) now
                        ; contains the address of this ship's blueprint

 CPY #2*SST             ; If the ship type is a space station (SST), then jump
 BEQ NW6                ; to NW6, skipping the heap space steps below, as the
                        ; space station has its own line heap at LSO (which it
                        ; shares with the sun)

                        ; We now want to allocate space for a heap that we can
                        ; use to store the lines we draw for our new ship (so it
                        ; can easily be erased from the screen again). SLSP
                        ; points to the start of the current heap space, and we
                        ; can extend it downwards with the heap for our new ship
                        ; (as the heap space always ends just before the WP
                        ; workspace)

 LDY #5                 ; Fetch ship blueprint byte #5, which contains the
 LDA (XX0),Y            ; maximum heap size required for plotting the new ship,
 STA T1                 ; and store it in T1

 LDA SLSP               ; Take the 16-bit address in SLSP and subtract T1,
 SEC                    ; storing the 16-bit result in INWK(34 33), so this now
 SBC T1                 ; points to the start of the line heap for our new ship
 STA INWK+33
 LDA SLSP+1
 SBC #0
 STA INWK+34

                        ; We now need to check that there is enough free space
                        ; for both this new line heap and the new data block
                        ; for our ship. In memory, this is the layout of the
                        ; ship data blocks and ship line heaps:
                        ;
                        ;   +-----------------------------------+   $1034
                        ;   |                                   |
                        ;   | WP workspace                      |
                        ;   |                                   |
                        ;   +-----------------------------------+   $0800 = WP
                        ;   |                                   |
                        ;   | Current ship line heap            |
                        ;   |                                   |
                        ;   +-----------------------------------+   SLSP
                        ;   |                                   |
                        ;   | Proposed heap for new ship        |
                        ;   |                                   |
                        ;   +-----------------------------------+   INWK(34 33)
                        ;   |                                   |
                        ;   .                                   .
                        ;   .                                   .
                        ;   .                                   .
                        ;   .                                   .
                        ;   .                                   .
                        ;   |                                   |
                        ;   +-----------------------------------+   INF + NI%
                        ;   |                                   |
                        ;   | Proposed data block for new ship  |
                        ;   |                                   |
                        ;   +-----------------------------------+   INF
                        ;   |                                   |
                        ;   | Existing ship data blocks         |
                        ;   |                                   |
                        ;   +-----------------------------------+   $0400 = K%
                        ;
                        ; So, to work out if we have enough space, we have to
                        ; make sure there is room between the end of our new
                        ; ship data block at INF + NI%, and the start of the
                        ; proposed heap for our new ship at the address we
                        ; stored in INWK(34 33). Or, to put it another way, we
                        ; and to make sure that:
                        ;
                        ;   INWK(34 33) > INF + NI%
                        ;
                        ; which is the same as saying:
                        ;
                        ;   INWK+33 - INF > NI%
                        ;
                        ; because INWK is in zero page, so INWK+34 = 0

 LDA INWK+33            ; Calculate INWK+33 - INF, again using 16-bit
;SEC                    ; arithmetic, and put the result in (A Y), so the high
 SBC INF                ; byte is in A and the low byte in Y. The SEC
 TAY                    ; instruction is commented out in the original source;
 LDA INWK+34            ; as the previous subtraction will never underflow, it
 SBC INF+1              ; is superfluous

 BCC NW3+1              ; If we have an underflow from the subtraction, then
                        ; INF > INWK+33 and we definitely don't have enough
                        ; room for this ship, so jump to NW3+1, which returns
                        ; from the subroutine (with the C flag already cleared)

 BNE NW4                ; If the subtraction of the high bytes in A is not
                        ; zero, and we don't have underflow, then we definitely
                        ; have enough space, so jump to NW4 to continue setting
                        ; up the new ship

 CPY #NI%               ; Otherwise the high bytes are the same in our
 BCC NW3+1              ; subtraction, so now we compare the low byte of the
                        ; result (which is in Y) with NI%. This is the same as
                        ; doing INWK+33 - INF > NI% (see above). If this isn't
                        ; true, the C flag will be clear and we don't have
                        ; enough space, so we jump to NW3+1, which returns
                        ; from the subroutine (with the C flag already cleared)

.NW4

 LDA INWK+33            ; If we get here then we do have enough space for our
 STA SLSP               ; new ship, so store the new bottom of the ship line
 LDA INWK+34            ; heap (i.e. INWK+33) in SLSP, doing both the high and
 STA SLSP+1             ; low bytes

.NW6

 LDY #14                ; Fetch ship blueprint byte #14, which contains the
 LDA (XX0),Y            ; ship's energy, and store it in byte #35
 STA INWK+35

 LDY #19                ; Fetch ship blueprint byte #19, which contains the
 LDA (XX0),Y            ; number of missiles and laser power, and AND with %111
 AND #%00000111         ; to extract the number of missiles before storing in
 STA INWK+31            ; byte #31

 LDA T                  ; Restore the ship type we stored above

.NW2

 STA FRIN,X             ; Store the ship type in the X-th byte of FRIN, so the
                        ; this slot is now shown as occupied in the index table

 TAX                    ; Copy the ship type into X

 BMI NW8                ; If the ship type is negative (planet or sun), then
                        ; jump to NW8 to skip the following instructions

 CPX #HER               ; If the ship type is a rock hermit, jump to gangbang
 BEQ gangbang           ; to increase the junk count

 CPX #JL                ; If JL <= X < JH, i.e. the type of ship we killed in X
 BCC NW7                ; is junk (escape pod, alloy plate, cargo canister,
 CPX #JH                ; asteroid, splinter, Shuttle or Transporter), then keep
 BCS NW7                ; going, otherwise jump to NW7

.gangbang

 INC JUNK               ; We're adding junk, so increase the junk counter

.NW7

 INC MANY,X             ; Increment the total number of ships of type X

.NW8

 LDY T                  ; Restore the ship type we stored above

 LDA E%-1,Y             ; Fetch the E% byte for this ship to get the default
                        ; settings for the ship's NEWB flags

 AND #%01101111         ; Zero bits 4 and 7 (so the new ship is not docking, has
                        ; not been scooped, and has not just docked)

 ORA NEWB               ; Apply the result to the ship's NEWB flags, which sets
 STA NEWB               ; bits 0-3 and 5-6 in NEWB if they are set in the E%
                        ; byte

 LDY #NI%-1             ; The final step is to copy the new ship's data block
                        ; from INWK to INF, so set up a counter for NI% bytes
                        ; in Y

.NWL3

 LDA INWK,Y             ; Load the Y-th byte of INWK and store in the Y-th byte
 STA (INF),Y            ; of the workspace pointed to by INF

 DEY                    ; Decrement the loop counter

 BPL NWL3               ; Loop back for the next byte until we have copied them
                        ; all over

 SEC                    ; We have successfully created our new ship, so set the
                        ; C flag to indicate success

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: NwS1
;       Type: Subroutine
;   Category: Universe
;    Summary: Flip the sign and double an INWK byte
;
; ------------------------------------------------------------------------------
;
; Flip the sign of the INWK byte at offset X, and increment X by 2. This is
; used by the space station creation routine at NWSPS.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The offset of the INWK byte to be flipped
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   X                   X is incremented by 2
;
; ******************************************************************************

.NwS1

 LDA INWK,X             ; Load the X-th byte of INWK into A and flip bit 7,
 EOR #%10000000         ; storing the result back in the X-th byte of INWK
 STA INWK,X

 INX                    ; Add 2 to X
 INX

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: ABORT
;       Type: Subroutine
;   Category: Dashboard
;    Summary: Disarm missiles and update the dashboard indicators
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   Y                   The new status of the leftmost missile indicator
;
; ******************************************************************************

.ABORT

 LDX #$FF               ; Set X to $FF, which is the value of MSTG when we have
                        ; no target lock for our missile

                        ; Fall through into ABORT2 to set the missile lock to
                        ; the value in X, which effectively disarms the missile

; ******************************************************************************
;
;       Name: ABORT2
;       Type: Subroutine
;   Category: Dashboard
;    Summary: Set/unset the lock target for a missile and update the dashboard
;
; ------------------------------------------------------------------------------
;
; Set the lock target for the leftmost missile and update the dashboard.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The slot number of the ship to lock our missile onto, or
;                       $FF to remove missile lock
;
;   Y                   The new colour of the missile indicator: ???
;
;                         * $00 = black (no missile)
;
;                         * #RED = red (armed and locked)
;
;                         * #YELLOW = yellow/white (armed)
;
;                         * #GREEN = green (disarmed)
;
; ******************************************************************************

.ABORT2

 STX MSTG               ; Store the target of our missile lock in MSTG

 LDX NOMSL              ; Call MSBAR to update the leftmost indicator in the
 JSR MSBAR              ; dashboard's missile bar, which returns with Y = 0

 STY MSAR               ; Set MSAR = 0 to indicate that the leftmost missile
                        ; is no longer seeking a target lock

 RTS                    ; Return from the subroutine

.msbpars

 EQUB 4, 0, 0, 0, 0     ; These bytes appear to be unused (they are left over
                        ; from the 6502 Second Processor version of Elite)

; ******************************************************************************
;
;       Name: PROJ
;       Type: Subroutine
;   Category: Maths (Geometry)
;    Summary: Project the current ship or planet onto the screen
;  Deep dive: Extended screen coordinates
;
; ------------------------------------------------------------------------------
;
; Project the current ship's location or the planet onto the screen, either
; returning the screen coordinates of the projection (if it's on-screen), or
; returning an error via the C flag.
;
; In this context, "on-screen" means that the point is projected into the
; following range:
;
;   centre of screen - 1024 < x < centre of screen + 1024
;   centre of screen - 1024 < y < centre of screen + 1024
;
; This is to cater for ships (and, more likely, planets and suns) whose centres
; are off-screen but whose edges may still be visible.
;
; The projection calculation is:
;
;   K3(1 0) = #X + x / z
;   K4(1 0) = #Y + y / z
;
; where #X and #Y are the pixel x-coordinate and y-coordinate of the centre of
; the screen.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   INWK                The ship data block for the ship to project on-screen
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   K3(1 0)             The x-coordinate of the ship's projection on-screen
;
;   K4(1 0)             The y-coordinate of the ship's projection on-screen
;
;   C flag              Set if the ship's projection doesn't fit on the screen,
;                       clear if it does project onto the screen
;
;   A                   Contains K4+1, the high byte of the y-coordinate
;
; ******************************************************************************

.PROJ

 LDA INWK               ; Set P(1 0) = (x_hi x_lo)
 STA P                  ;            = x
 LDA INWK+1
 STA P+1

 LDA INWK+2             ; Set A = x_sign

 JSR PLS6               ; Call PLS6 to calculate:
                        ;
                        ;   (X K) = (A P+1 P) / (z_sign z_hi z_lo)
                        ;         = (x_sign x_hi x_lo) / (z_sign z_hi z_lo)
                        ;         = x / z

 BCS PL2-1              ; If the C flag is set then the result overflowed and
                        ; the coordinate doesn't fit on the screen, so return
                        ; from the subroutine with the C flag set (as PL2-1
                        ; contains an RTS)

 LDA K                  ; Set K3(1 0) = (X K) + #X
 ADC #X                 ;             = #X + x / z
 STA K3                 ;
                        ; first doing the low bytes

 TXA                    ; And then the high bytes. #X is the x-coordinate of
 ADC #0                 ; the centre of the space view, so this converts the
 STA K3+1               ; space x-coordinate into a screen x-coordinate

 LDA INWK+3             ; Set P(1 0) = (y_hi y_lo)
 STA P
 LDA INWK+4
 STA P+1

 LDA INWK+5             ; Set A = -y_sign
 EOR #%10000000

 JSR PLS6               ; Call PLS6 to calculate:
                        ;
                        ;   (X K) = (A P+1 P) / (z_sign z_hi z_lo)
                        ;         = -(y_sign y_hi y_lo) / (z_sign z_hi z_lo)
                        ;         = -y / z

 BCS PL2-1              ; If the C flag is set then the result overflowed and
                        ; the coordinate doesn't fit on the screen, so return
                        ; from the subroutine with the C flag set (as PL2-1
                        ; contains an RTS)

 LDA K                  ; Set K4(1 0) = (X K) + #Y
 ADC #Y                 ;             = #Y - y / z
 STA K4                 ;
                        ; first doing the low bytes

 TXA                    ; And then the high bytes. #Y is the y-coordinate of
 ADC #0                 ; the centre of the space view, so this converts the
 STA K4+1               ; space x-coordinate into a screen y-coordinate

 CLC                    ; Clear the C flag to indicate success

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: PL2
;       Type: Subroutine
;   Category: Drawing planets
;    Summary: Remove the planet or sun from the screen
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   PL2-1               Contains an RTS
;
; ******************************************************************************

.PL2

 LDA TYPE               ; Shift bit 0 of the planet/sun's type into the C flag
 LSR A

 BCS P%+5               ; If the planet/sun's type has bit 0 clear, then it's
                        ; either 128 or 130, which is a planet; meanwhile, the
                        ; sun has type 129, which has bit 0 set. So if this is
                        ; the sun, skip the following instruction

 JMP WPLS2              ; This is the planet, so jump to WPLS2 to remove it from
                        ; screen, returning from the subroutine using a tail
                        ; call

 JMP WPLS               ; This is the sun, so jump to WPLS to remove it from
                        ; screen, returning from the subroutine using a tail
                        ; call

; ******************************************************************************
;
;       Name: PLANET
;       Type: Subroutine
;   Category: Drawing planets
;    Summary: Draw the planet or sun
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   INWK                The planet or sun's ship data block
;
; ******************************************************************************

.PLANET

 LDA INWK+8             ; Set A = z_sign (the highest byte in the planet/sun's
                        ; coordinates)

;BMI PL2                ; This instruction is commented out in the original
                        ; source. It would remove the planet from the screen
                        ; when it's behind us

 CMP #48                ; If A >= 48 then the planet/sun is too far away to be
 BCS PL2                ; seen, so jump to PL2 to remove it from the screen,
                        ; returning from the subroutine using a tail call

 ORA INWK+7             ; Set A to 0 if both z_sign and z_hi are 0

 BEQ PL2                ; If both z_sign and z_hi are 0, then the planet/sun is
                        ; too close to be shown, so jump to PL2 to remove it
                        ; from the screen, returning from the subroutine using a
                        ; tail call

 JSR PROJ               ; Project the planet/sun onto the screen, returning the
                        ; centre's coordinates in K3(1 0) and K4(1 0)

 BCS PL2                ; If the C flag is set by PROJ then the planet/sun is
                        ; not visible on-screen, so jump to PL2 to remove it
                        ; from the screen, returning from the subroutine using
                        ; a tail call

 LDA #96                ; Set (A P+1 P) = (0 96 0) = 24576
 STA P+1                ;
 LDA #0                 ; This represents the planet/sun's radius at a distance
 STA P                  ; of z = 1

 JSR DVID3B2            ; Call DVID3B2 to calculate:
                        ;
                        ;   K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)
                        ;              = (0 96 0) / z
                        ;              = 24576 / z
                        ;
                        ; so K now contains the planet/sun's radius, reduced by
                        ; the actual distance to the planet/sun. We know that
                        ; K+3 and K+2 will be 0, as the number we are dividing,
                        ; (0 96 0), fits into the two bottom bytes, so the
                        ; result is actually in K(1 0)

 LDA K+1                ; If the high byte of the reduced radius is zero, jump
 BEQ PL82               ; to PL82, as K contains the radius on its own

 LDA #248               ; Otherwise set K = 248, to round up the radius in
 STA K                  ; K(1 0) to the nearest integer (if we consider the low
                        ; byte to be the fractional part)

.PL82

 LDA TYPE               ; If the planet/sun's type has bit 0 clear, then it's
 LSR A                  ; either 128 or 130, which is a planet (the sun has type
 BCC PL9                ; 129, which has bit 0 set). So jump to PL9 to draw the
                        ; planet with radius K, returning from the subroutine
                        ; using a tail call

 JMP SUN                ; Otherwise jump to SUN to draw the sun with radius K,
                        ; returning from the subroutine using a tail call

; ******************************************************************************
;
;       Name: PL9
;       Type: Subroutine
;   Category: Drawing planets
;    Summary: Draw the planet as a plain circle
;
; ------------------------------------------------------------------------------
;
; Draw the planet with radius K at pixel coordinate (K3, K4).
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   K(1 0)              The planet's radius
;
;   K3(1 0)             Pixel x-coordinate of the centre of the planet
;
;   K4(1 0)             Pixel y-coordinate of the centre of the planet
;
;   INWK                The planet's ship data block
;
; ******************************************************************************

.PL9

 JSR WPLS2              ; Call WPLS2 to remove the planet from the screen

 JMP CIRCLE             ; Call CIRCLE to draw the planet's new circle, returning
                        ; from the subroutine using a tail call

;BCS PL20               ; These instructions are commented out in the original
;LDA K+1                ; source, as the Apple II version only has circles for
;BEQ PL25               ; planets, with no meridians or craters
;.PL20
;RTS

; ******************************************************************************
;
;       Name: SUN (Part 1 of 4)
;       Type: Subroutine
;   Category: Drawing suns
;    Summary: Draw the sun: Set up all the variables needed to draw the sun
;  Deep dive: Drawing the sun
;
; ------------------------------------------------------------------------------
;
; Draw a new sun with radius K at pixel coordinate (K3, K4), removing the old
; sun if there is one. This routine is used to draw the sun, as well as the
; star systems on the Short-range Chart.
;
; The first part sets up all the variables needed to draw the new sun.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   K                   The new sun's radius
;
;   K3(1 0)             Pixel x-coordinate of the centre of the new sun
;
;   K4(1 0)             Pixel y-coordinate of the centre of the new sun
;
;   SUNX(1 0)           The x-coordinate of the vertical centre axis of the old
;                       sun (the one currently on-screen)
;
; ******************************************************************************

.PLF3M3

 JMP WPLS               ; Jump to WPLS to remove the old sun from the screen. We
                        ; only get here via the BCS just after the SUN entry
                        ; point below, when there is no new sun to draw

.PLF3

                        ; This is called from below to negate X and set A to
                        ; $FF, for when the new sun's centre is off the bottom
                        ; of the screen (so we don't need to draw its bottom
                        ; half)
                        ;
                        ; This happens when the y-coordinate of the centre of
                        ; the sun is bigger than the y-coordinate of the bottom
                        ; of the space view

 TXA                    ; Negate X using two's complement, so X = ~X + 1
 EOR #%11111111
 CLC
 ADC #1
 TAX

.PLF17

                        ; This is called from below to set A to $FF, for when
                        ; the new sun's centre is right on the bottom of the
                        ; screen (so we don't need to draw its bottom half)

 LDA #$FF               ; Set A = $FF

 JMP PLF5               ; Jump to PLF5

.SUN

 LDA #RED               ; Switch to colour 2, which is red in the space view
 STA COL

 LDA #1                 ; Set LSX = 1 to indicate the sun line heap is about to
 STA LSX                ; be filled up

 JSR CHKON              ; Call CHKON to check whether any part of the new sun's
                        ; circle appears on-screen, and if it does, set P(2 1)
                        ; to the maximum y-coordinate of the new sun on-screen

 BCS PLF3M3             ; If CHKON set the C flag then the new sun's circle does
                        ; not appear on-screen, so jump to WPLS (via the JMP at
                        ; the top of this routine) to remove the sun from the
                        ; screen, returning from the subroutine using a tail
                        ; call

 LDA #0                 ; Set A = 0

 LDX K                  ; Set X = K = radius of the new sun

 CPX #96                ; If X >= 96, set the C flag and rotate it into bit 0
 ROL A                  ; of A, otherwise rotate a 0 into bit 0

 CPX #40                ; If X >= 40, set the C flag and rotate it into bit 0
 ROL A                  ; of A, otherwise rotate a 0 into bit 0

 CPX #16                ; If X >= 16, set the C flag and rotate it into bit 0
 ROL A                  ; of A, otherwise rotate a 0 into bit 0

                        ; By now, A contains the following:
                        ;
                        ;   * If radius is 96-255 then A = %111 = 7
                        ;
                        ;   * If radius is 40-95  then A = %11  = 3
                        ;
                        ;   * If radius is 16-39  then A = %1   = 1
                        ;
                        ;   * If radius is 0-15   then A = %0   = 0
                        ;
                        ; The value of A determines the size of the new sun's
                        ; ragged fringes - the bigger the sun, the bigger the
                        ; fringes

.PLF18

 STA CNT                ; Store the fringe size in CNT

                        ; We now calculate the highest pixel y-coordinate of the
                        ; new sun, given that P(2 1) contains the 16-bit maximum
                        ; y-coordinate of the new sun on-screen

 LDA Yx2M1              ; Set Y to the y-coordinate of the bottom of the space
                        ; view

 LDX P+2                ; If P+2 is non-zero, the maximum y-coordinate is off
 BNE PLF2               ; the bottom of the screen, so skip to PLF2 with A set
                        ; to the y-coordinate of the bottom of the space view

 CMP P+1                ; If A < P+1, the maximum y-coordinate is underneath the
 BCC PLF2               ; dashboard, so skip to PLF2 with A set to the
                        ; y-coordinate of the bottom of the space view

 LDA P+1                ; Set A = P+1, the low byte of the maximum y-coordinate
                        ; of the sun on-screen

 BNE PLF2               ; If A is non-zero, skip to PLF2 as it contains the
                        ; value we are after

 LDA #1                 ; Otherwise set A = 1, the top line of the screen

.PLF2

 STA TGT                ; Set TGT to A, the maximum y-coordinate of the sun on
                        ; screen

                        ; We now calculate the number of lines we need to draw
                        ; and the direction in which we need to draw them, both
                        ; from the centre of the new sun

 LDA Yx2M1              ; Set (A X) = y-coordinate of bottom of screen - K4(1 0)
 SEC                    ;
 SBC K4                 ; Starting with the low bytes
 TAX

 LDA #0                 ; And then doing the high bytes, so (A X) now contains
 SBC K4+1               ; the number of lines between the centre of the sun and
                        ; the bottom of the screen. If it is positive then the
                        ; centre of the sun is above the bottom of the screen,
                        ; if it is negative then the centre of the sun is below
                        ; the bottom of the screen

 BMI PLF3               ; If A < 0, then this means the new sun's centre is off
                        ; the bottom of the screen, so jump up to PLF3 to negate
                        ; the height in X (so it becomes positive), set A to $FF
                        ; and jump down to PLF5

 BNE PLF4               ; If A > 0, then the new sun's centre is at least a full
                        ; screen above the bottom of the space view, so jump
                        ; down to PLF4 to set X = radius and A = 0

 INX                    ; Set the flags depending on the value of X
 DEX

 BEQ PLF17              ; If X = 0 (we already know A = 0 by this point) then
                        ; jump up to PLF17 to set A to $FF before jumping down
                        ; to PLF5

 CPX K                  ; If X < the radius in K, jump down to PLF5, so if
 BCC PLF5               ; X >= the radius in K, we set X = radius and A = 0

.PLF4

 LDX K                  ; Set X to the radius

 LDA #0                 ; Set A = 0

.PLF5

 STX V                  ; Store the height in V

 STA V+1                ; Store the direction in V+1

 LDA K                  ; Set (A P) = K * K
 JSR SQUA2

 STA K2+1               ; Set K2(1 0) = (A P) = K * K
 LDA P
 STA K2

                        ; By the time we get here, the variables should be set
                        ; up as shown in the header for part 3 below

; ******************************************************************************
;
;       Name: SUN (Part 2 of 4)
;       Type: Subroutine
;   Category: Drawing suns
;    Summary: Draw the sun: Start from the bottom of the screen and erase the
;             old sun line by line
;  Deep dive: Drawing the sun
;
; ------------------------------------------------------------------------------
;
; This part erases the old sun, starting at the bottom of the screen and working
; upwards until we reach the bottom of the new sun.
;
; ******************************************************************************

 LDY Yx2M1              ; Set Y = y-coordinate of the bottom of the screen,
                        ; which we use as a counter in the following routine to
                        ; redraw the old sun

 LDA SUNX               ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
 STA YY                 ; vertical centre axis of the old sun that's currently
 LDA SUNX+1             ; on-screen
 STA YY+1

.PLFL2

 CPY TGT                ; If Y = TGT, we have reached the line where we will
 BEQ PLFL               ; start drawing the new sun, so there is no need to
                        ; keep erasing the old one, so jump down to PLFL

 LDA LSO,Y              ; Fetch the Y-th point from the sun line heap, which
                        ; gives us the half-width of the old sun's line on this
                        ; line of the screen

 BEQ PLF13              ; If A = 0, skip the following call to HLOIN2 as there
                        ; is no sun line on this line of the screen

 JSR HLOIN2             ; Call HLOIN2 to draw a horizontal line on pixel line Y,
                        ; with centre point YY(1 0) and half-width A, and remove
                        ; the line from the sun line heap once done

.PLF13

 DEY                    ; Decrement the loop counter

 BNE PLFL2              ; Loop back for the next line in the line heap until
                        ; we have either gone through the entire heap, or
                        ; reached the bottom row of the new sun

; ******************************************************************************
;
;       Name: SUN (Part 3 of 4)
;       Type: Subroutine
;   Category: Drawing suns
;    Summary: Draw the sun: Continue to move up the screen, drawing the new sun
;             line by line
;  Deep dive: Drawing the sun
;
; ------------------------------------------------------------------------------
;
; This part draws the new sun. By the time we get to this point, the following
; variables should have been set up by parts 1 and 2:
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   V                   As we draw lines for the new sun, V contains the
;                       vertical distance between the line we're drawing and the
;                       centre of the new sun. As we draw lines and move up the
;                       screen, we either decrement (bottom half) or increment
;                       (top half) this value. See the deep dive on "Drawing the
;                       sun" to see a diagram that shows V in action
;
;   V+1                 This determines which half of the new sun we are drawing
;                       as we work our way up the screen, line by line:
;
;                         * 0 means we are drawing the bottom half, so the lines
;                           get wider as we work our way up towards the centre,
;                           at which point we will move into the top half, and
;                           V+1 will switch to $FF
;
;                         * $FF means we are drawing the top half, so the lines
;                           get smaller as we work our way up, away from the
;                           centre
;
;   TGT                 The maximum y-coordinate of the new sun on-screen (i.e.
;                       the screen y-coordinate of the bottom row of the new
;                       sun)
;
;   CNT                 The fringe size of the new sun
;
;   K2(1 0)             The new sun's radius squared, i.e. K^2
;
;   Y                   The y-coordinate of the bottom row of the new sun
;
; ******************************************************************************

.PLFL

 LDA V                  ; Set (T P) = V * V
 JSR SQUA2              ;           = V^2
 STA T

 LDA K2                 ; Set (R Q) = K^2 - V^2
 SEC                    ;
 SBC P                  ; First calculating the low bytes
 STA Q

 LDA K2+1               ; And then doing the high bytes
 SBC T
 STA R

 STY Y1                 ; Store Y in Y1, so we can restore it after the call to
                        ; LL5

 JSR LL5                ; Set Q = SQRT(R Q)
                        ;       = SQRT(K^2 - V^2)
                        ;
                        ; So Q contains the half-width of the new sun's line at
                        ; height V from the sun's centre - in other words, it
                        ; contains the half-width of the sun's line on the
                        ; current pixel row Y

 LDY Y1                 ; Restore Y from Y1

 JSR DORND              ; Set A and X to random numbers

 AND CNT                ; Reduce A to a random number in the range 0 to CNT,
                        ; where CNT is the fringe size of the new sun

 CLC                    ; Set A = A + Q
 ADC Q                  ;
                        ; So A now contains the half-width of the sun on row
                        ; V, plus a random variation based on the fringe size

 BCC PLF44              ; If the above addition did not overflow, skip the
                        ; following instruction

 LDA #255               ; The above overflowed, so set the value of A to 255

                        ; So A contains the half-width of the new sun on pixel
                        ; line Y, changed by a random amount within the size of
                        ; the sun's fringe

.PLF44

 LDX LSO,Y              ; Set X to the line heap value for the old sun's line
                        ; at row Y

 STA LSO,Y              ; Store the half-width of the new row Y line in the line
                        ; heap

 BEQ PLF11              ; If X = 0 then there was no sun line on pixel row Y, so
                        ; jump to PLF11

 LDA SUNX               ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
 STA YY                 ; vertical centre axis of the old sun that's currently
 LDA SUNX+1             ; on-screen
 STA YY+1

 TXA                    ; Transfer the line heap value for the old sun's line
                        ; from X into A

 JSR EDGES              ; Call EDGES to calculate X1 and X2 for the horizontal
                        ; line centred on YY(1 0) and with half-width A, i.e.
                        ; the line for the old sun

 LDA X1                 ; Store X1 and X2, the ends of the line for the old sun,
 STA XX                 ; in XX and XX+1
 LDA X2
 STA XX+1

 LDA K3                 ; Set YY(1 0) = K3(1 0), the x-coordinate of the centre
 STA YY                 ; of the new sun
 LDA K3+1
 STA YY+1

 LDA LSO,Y              ; Fetch the half-width of the new row Y line from the
                        ; line heap (which we stored above)

 JSR EDGES              ; Call EDGES to calculate X1 and X2 for the horizontal
                        ; line centred on YY(1 0) and with half-width A, i.e.
                        ; the line for the new sun

 BCS PLF23              ; If the C flag is set, the new line doesn't fit on the
                        ; screen, so jump to PLF23 to just draw the old line
                        ; without drawing the new one

                        ; At this point the old line is from XX to XX+1 and the
                        ; new line is from X1 to X2, and both fit on-screen. We
                        ; now want to remove the old line and draw the new one.
                        ; We could do this by simply drawing the old one then
                        ; drawing the new one, but instead Elite does this by
                        ; drawing first from X1 to XX and then from X2 to XX+1,
                        ; which you can see in action by looking at all the
                        ; permutations below of the four points on the line and
                        ; imagining what happens if you draw from X1 to XX and
                        ; X2 to XX+1 using EOR logic. The six possible
                        ; permutations are as follows, along with the result of
                        ; drawing X1 to XX and then X2 to XX+1:
                        ;
                        ;   X1    X2    XX____XX+1      ->      +__+  +  +
                        ;
                        ;   X1    XX____X2____XX+1      ->      +__+__+  +
                        ;
                        ;   X1    XX____XX+1  X2        ->      +__+__+__+
                        ;
                        ;   XX____X1____XX+1  X2        ->      +  +__+__+
                        ;
                        ;   XX____XX+1  X1    X2        ->      +  +  +__+
                        ;
                        ;   XX____X1____X2____XX+1      ->      +  +__+  +
                        ;
                        ; They all end up with a line between X1 and X2, which
                        ; is what we want. There's probably a mathematical proof
                        ; of why this works somewhere, but the above is probably
                        ; easier to follow.
                        ;
                        ; We can draw from X1 to XX and X2 to XX+1 by swapping
                        ; XX and X2 and drawing from X1 to X2, and then drawing
                        ; from XX to XX+1, so let's do this now

 LDA X2                 ; Swap XX and X2
 LDX XX
 STX X2
 STA XX

 JSR HLOIN              ; Draw a horizontal line from (X1, Y1) to (X2, Y1)

.PLF23

                        ; If we jump here from the BCS above when there is no
                        ; new line this will just draw the old line

 LDA XX                 ; Set X1 = XX
 STA X1

 LDA XX+1               ; Set X2 = XX+1
 STA X2

.PLF16

 JSR HLOIN              ; Draw a horizontal line from (X1, Y1) to (X2, Y1)

.PLF6

 DEY                    ; Decrement the line number in Y to move to the line
                        ; above

 BEQ PLF8               ; If we have reached the top of the screen, jump to PLF8
                        ; as we are done drawing (the top line of the screen is
                        ; the border, so we don't draw there)

 LDA V+1                ; If V+1 is non-zero then we are doing the top half of
 BNE PLF10              ; the new sun, so jump down to PLF10 to increment V and
                        ; decrease the width of the line we draw

 DEC V                  ; Decrement V, the height of the sun that we use to work
                        ; out the width, so this makes the line get wider, as we
                        ; move up towards the sun's centre

 BNE PLFL               ; If V is non-zero, jump back up to PLFL to do the next
                        ; screen line up

 DEC V+1                ; Otherwise V is 0 and we have reached the centre of the
                        ; sun, so decrement V+1 to -1 so we start incrementing V
                        ; each time, thus doing the top half of the new sun

.PLFLS

 JMP PLFL               ; Jump back up to PLFL to do the next screen line up

.PLF11

                        ; If we get here then there is no old sun line on this
                        ; line, so we can just draw the new sun's line

 LDX K3                 ; Set YY(1 0) = K3(1 0), the x-coordinate of the centre
 STX YY                 ; of the new sun's line
 LDX K3+1
 STX YY+1

 JSR EDGES              ; Call EDGES to calculate X1 and X2 for the horizontal
                        ; line centred on YY(1 0) and with half-width A, i.e.
                        ; the line for the new sun

 BCC PLF16              ; If the line is on-screen, jump up to PLF16 to draw the
                        ; line and loop round for the next line up

 LDA #0                 ; The line is not on-screen, so set the line heap for
 STA LSO,Y              ; line Y to 0, which means there is no sun line here

 BEQ PLF6               ; Jump up to PLF6 to loop round for the next line up
                        ; (this BEQ is effectively a JMP as A is always zero)

.PLF10

 LDX V                  ; Increment V, the height of the sun that we use to work
 INX                    ; out the width, so this makes the line get narrower, as
 STX V                  ; we move up and away from the sun's centre

 CPX K                  ; If V <= the radius of the sun, we still have lines to
 BCC PLFLS              ; draw, so jump up to PLFL (via PLFLS) to do the next
 BEQ PLFLS              ; screen line up

; ******************************************************************************
;
;       Name: SUN (Part 4 of 4)
;       Type: Subroutine
;   Category: Drawing suns
;    Summary: Draw the sun: Continue to the top of the screen, erasing the old
;             sun line by line
;  Deep dive: Drawing the sun
;
; ------------------------------------------------------------------------------
;
; This part erases any remaining traces of the old sun, now that we have drawn
; all the way to the top of the new sun.
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   RTS2                Contains an RTS
;
; ******************************************************************************

 LDA SUNX               ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
 STA YY                 ; vertical centre axis of the old sun that's currently
 LDA SUNX+1             ; on-screen
 STA YY+1

.PLFL3

 LDA LSO,Y              ; Fetch the Y-th point from the sun line heap, which
                        ; gives us the half-width of the old sun's line on this
                        ; line of the screen

 BEQ PLF9               ; If A = 0, skip the following call to HLOIN2 as there
                        ; is no sun line on this line of the screen

 JSR HLOIN2             ; Call HLOIN2 to draw a horizontal line on pixel line Y,
                        ; with centre point YY(1 0) and half-width A, and remove
                        ; the line from the sun line heap once done

.PLF9

 DEY                    ; Decrement the line number in Y to move to the line
                        ; above

 BNE PLFL3              ; Jump up to PLFL3 to redraw the next line up, until we
                        ; have reached the top of the screen

.PLF8

                        ; If we get here, we have successfully made it from the
                        ; bottom line of the screen to the top, and the old sun
                        ; has been replaced by the new one

 CLC                    ; Clear the C flag to indicate success in drawing the
                        ; sun

 LDA K3                 ; Set SUNX(1 0) = K3(1 0)
 STA SUNX
 LDA K3+1
 STA SUNX+1

.RTS2

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: CIRCLE
;       Type: Subroutine
;   Category: Drawing circles
;    Summary: Draw a circle for the planet
;  Deep dive: Drawing circles
;
; ------------------------------------------------------------------------------
;
; Draw a circle with the centre at (K3, K4) and radius K. Used to draw the
; planet's main outline.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   K                   The planet's radius
;
;   K3(1 0)             Pixel x-coordinate of the centre of the planet
;
;   K4(1 0)             Pixel y-coordinate of the centre of the planet
;
; ******************************************************************************

.CIRCLE

 JSR CHKON              ; Call CHKON to check whether the circle fits on-screen

 BCS RTS2               ; If CHKON set the C flag then the circle does not fit
                        ; on-screen, so return from the subroutine (as RTS2
                        ; contains an RTS)

 LDA #0                 ; Set LSX2 = 0 to indicate that the ball line heap is
 STA LSX2               ; not empty, as we are about to fill it

 LDX K                  ; Set X = K = radius

 LDA #8                 ; Set A = 8

 CPX #8                 ; If the radius < 8, skip to PL89
 BCC PL89

 LSR A                  ; Halve A so A = 4

 CPX #60                ; If the radius < 60, skip to PL89
 BCC PL89

 LSR A                  ; Halve A so A = 2

.PL89

 STA STP                ; Set STP = A. STP is the step size for the circle, so
                        ; the above sets a smaller step size for bigger circles

; ******************************************************************************
;
;       Name: CIRCLE2
;       Type: Subroutine
;   Category: Drawing circles
;    Summary: Draw a circle (for the planet or chart)
;  Deep dive: Drawing circles
;
; ------------------------------------------------------------------------------
;
; Draw a circle with the centre at (K3, K4) and radius K. Used to draw the
; planet and the chart circles.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   STP                 The step size for the circle
;
;   K                   The circle's radius
;
;   K3(1 0)             Pixel x-coordinate of the centre of the circle
;
;   K4(1 0)             Pixel y-coordinate of the centre of the circle
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              The C flag is cleared
;
; ******************************************************************************

.CIRCLE2

 LDX #$FF               ; Set FLAG = $FF to reset the ball line heap in the call
 STX FLAG               ; to the BLINE routine below

 INX                    ; Set CNT = 0, our counter that goes up to 64, counting
 STX CNT                ; segments in our circle

.PLL3

 LDA CNT                ; Set A = CNT

 JSR FMLTU2             ; Call FMLTU2 to calculate:
                        ;
                        ;   A = K * sin(A)
                        ;     = K * sin(CNT)

 LDX #0                 ; Set T = 0, so we have the following:
 STX T                  ;
                        ;   (T A) = K * sin(CNT)
                        ;
                        ; which is the x-coordinate of the circle for this count

 LDX CNT                ; If CNT < 33 then jump to PL37, as this is the right
 CPX #33                ; half of the circle and the sign of the x-coordinate is
 BCC PL37               ; correct

 EOR #%11111111         ; This is the left half of the circle, so we want to
 ADC #0                 ; flip the sign of the x-coordinate in (T A) using two's
 TAX                    ; complement, so we start with the low byte and store it
                        ; in X (the ADC adds 1 as we know the C flag is set)

 LDA #$FF               ; And then we flip the high byte in T
 ADC #0
 STA T

 TXA                    ; Finally, we restore the low byte from X, so we have
                        ; now negated the x-coordinate in (T A)

 CLC                    ; Clear the C flag so we can do some more addition below

.PL37

 ADC K3                 ; We now calculate the following:
 STA K6                 ;
                        ;   K6(1 0) = (T A) + K3(1 0)
                        ;
                        ; to add the coordinates of the centre to our circle
                        ; point, starting with the low bytes

 LDA K3+1               ; And then doing the high bytes, so we now have:
 ADC T                  ;
 STA K6+1               ;   K6(1 0) = K * sin(CNT) + K3(1 0)
                        ;
                        ; which is the result we want for the x-coordinate

 LDA CNT                ; Set A = CNT + 16
 CLC
 ADC #16

 JSR FMLTU2             ; Call FMLTU2 to calculate:
                        ;
                        ;   A = K * sin(A)
                        ;     = K * sin(CNT + 16)
                        ;     = K * cos(CNT)

 TAX                    ; Set X = A
                        ;       = K * cos(CNT)

 LDA #0                 ; Set T = 0, so we have the following:
 STA T                  ;
                        ;   (T X) = K * cos(CNT)
                        ;
                        ; which is the y-coordinate of the circle for this count

 LDA CNT                ; Set A = (CNT + 15) mod 64
 ADC #15
 AND #63

 CMP #33                ; If A < 33 (i.e. CNT is 0-16 or 48-64) then jump to
 BCC PL38               ; PL38, as this is the bottom half of the circle and the
                        ; sign of the y-coordinate is correct

 TXA                    ; This is the top half of the circle, so we want to
 EOR #%11111111         ; flip the sign of the y-coordinate in (T X) using two's
 ADC #0                 ; complement, so we start with the low byte in X (the
 TAX                    ; ADC adds 1 as we know the C flag is set)

 LDA #$FF               ; And then we flip the high byte in T, so we have
 ADC #0                 ; now negated the y-coordinate in (T X)
 STA T

 CLC                    ; Clear the C flag so the addition at the start of BLINE
                        ; will work

.PL38

 JSR BLINE              ; Call BLINE to draw this segment, which also increases
                        ; CNT by STP, the step size

 CMP #65                ; If CNT >= 65 then skip the next instruction
 BCS P%+5

 JMP PLL3               ; Jump back for the next segment

 CLC                    ; Clear the C flag to indicate success

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: WPLS2
;       Type: Subroutine
;   Category: Drawing planets
;    Summary: Remove the planet from the screen
;  Deep dive: The ball line heap
;
; ------------------------------------------------------------------------------
;
; We do this by redrawing it using the lines stored in the ball line heap when
; the planet was originally drawn by the BLINE routine.
;
; ******************************************************************************

.WPLS2

 LDY LSX2               ; If LSX2 is non-zero (which indicates the ball line
 BNE WP1                ; heap is empty), jump to WP1 to reset the line heap
                        ; without redrawing the planet

                        ; Otherwise Y is now 0, so we can use it as a counter to
                        ; loop through the lines in the line heap, redrawing
                        ; each one to remove the planet from the screen, before
                        ; resetting the line heap once we are done

.WPL1

 CPY LSP                ; If Y >= LSP then we have reached the end of the line
 BCS WP1                ; heap and have finished redrawing the planet (as LSP
                        ; points to the end of the heap), so jump to WP1 to
                        ; reset the line heap, returning from the subroutine
                        ; using a tail call

 LDA LSY2,Y             ; Set A to the y-coordinate of the current heap entry

 CMP #$FF               ; If the y-coordinate is $FF, this indicates that the
 BEQ WP2                ; next point in the heap denotes the start of a line
                        ; segment, so jump to WP2 to put it into (X1, Y1)

 STA Y2                 ; Set (X2, Y2) to the x- and y-coordinates from the
 LDA LSX2,Y             ; heap
 STA X2

 JSR LOIN               ; Draw a line from (X1, Y1) to (X2, Y2)

 INY                    ; Increment the loop counter to point to the next point

 LDA SWAP               ; If SWAP is non-zero then we swapped the coordinates
 BNE WPL1               ; when filling the heap in BLINE, so loop back WPL1
                        ; for the next point in the heap

 LDA X2                 ; Swap (X1, Y1) and (X2, Y2), so the next segment will
 STA X1                 ; be drawn from the current (X2, Y2) to the next point
 LDA Y2                 ; in the heap
 STA Y1

 JMP WPL1               ; Loop back to WPL1 for the next point in the heap

.WP2

 INY                    ; Increment the loop counter to point to the next point

 LDA LSX2,Y             ; Set (X1, Y1) to the x- and y-coordinates from the
 STA X1                 ; heap
 LDA LSY2,Y
 STA Y1

 INY                    ; Increment the loop counter to point to the next point

 JMP WPL1               ; Loop back to WPL1 for the next point in the heap

; ******************************************************************************
;
;       Name: WP1
;       Type: Subroutine
;   Category: Drawing planets
;    Summary: Reset the ball line heap
;
; ******************************************************************************

.WP1

 LDA #1                 ; Set LSP = 1 to reset the ball line heap pointer
 STA LSP

 LDA #$FF               ; Set LSX2 = $FF to indicate the ball line heap is empty
 STA LSX2

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: WPLS
;       Type: Subroutine
;   Category: Drawing suns
;    Summary: Remove the sun from the screen
;  Deep dive: Drawing the sun
;
; ------------------------------------------------------------------------------
;
; We do this by redrawing it using the lines stored in the sun line heap when
; the sun was originally drawn by the SUN routine.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   SUNX(1 0)           The x-coordinate of the vertical centre axis of the sun
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   WPLS-1              Contains an RTS
;
; ******************************************************************************

.WPLS

 LDA LSX                ; If LSX < 0, the sun line heap is empty, so return from
 BMI WPLS-1             ; the subroutine (as WPLS-1 contains an RTS)

 LDA SUNX               ; Set YY(1 0) = SUNX(1 0), the x-coordinate of the
 STA YY                 ; vertical centre axis of the sun that's currently on
 LDA SUNX+1             ; screen
 STA YY+1

 LDY #2*Y-1             ; #Y is the y-coordinate of the centre of the space
                        ; view, so this sets Y as a counter for the number of
                        ; lines in the space view (i.e. 191), which is also the
                        ; number of lines in the LSO block

.WPL2

 LDA LSO,Y              ; Fetch the Y-th point from the sun line heap, which
                        ; gives us the half-width of the sun's line on this line
                        ; of the screen

 BEQ P%+5               ; If A = 0, skip the following call to HLOIN2 as there
                        ; is no sun line on this line of the screen

 JSR HLOIN2             ; Call HLOIN2 to draw a horizontal line on pixel line Y,
                        ; with centre point YY(1 0) and half-width A, and remove
                        ; the line from the sun line heap once done

 DEY                    ; Decrement the loop counter

 BNE WPL2               ; Loop back for the next line in the line heap until
                        ; we have gone through the entire heap

 DEY                    ; This sets Y to $FF, as we end the loop with Y = 0

 STY LSX                ; Set LSX to $FF to indicate the sun line heap is empty

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: EDGES
;       Type: Subroutine
;   Category: Drawing lines
;    Summary: Draw a horizontal line given a centre and a half-width
;
; ------------------------------------------------------------------------------
;
; Set X1 and X2 to the x-coordinates of the ends of the horizontal line with
; centre x-coordinate YY(1 0), and length A in either direction from the centre
; (so a total line length of 2 * A). In other words, this line:
;
;   X1             YY(1 0)             X2
;   +-----------------+-----------------+
;         <- A ->           <- A ->
;
; The resulting line gets clipped to the edges of the screen, if needed. If the
; calculation doesn't overflow, we return with the C flag clear, otherwise the C
; flag gets set to indicate failure and the Y-th LSO entry gets set to 0.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The half-length of the line
;
;   YY(1 0)             The centre x-coordinate
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              Clear if the line fits on-screen, set if it doesn't
;
;   X1, X2              The x-coordinates of the clipped line
;
;   LSO+Y               If the line doesn't fit, LSO+Y is set to 0
;
;   Y                   Y is preserved
;
; ******************************************************************************

.EDGES

 STA T                  ; Set T to the line's half-length in argument A

 CLC                    ; We now calculate:
 ADC YY                 ;
 STA X2                 ;  (A X2) = YY(1 0) + A
                        ;
                        ; to set X2 to the x-coordinate of the right end of the
                        ; line, starting with the low bytes

 LDA YY+1               ; And then adding the high bytes
 ADC #0

 BMI ED1                ; If the addition is negative then the calculation has
                        ; overflowed, so jump to ED1 to return a failure

 BEQ P%+6               ; If the high byte A from the result is 0, skip the
                        ; next two instructions, as the result already fits on
                        ; the screen

 LDA #255               ; The high byte is positive and non-zero, so we went
 STA X2                 ; past the right edge of the screen, so clip X2 to the
                        ; x-coordinate of the right edge of the screen

 LDA YY                 ; We now calculate:
 SEC                    ;
 SBC T                  ;   (A X1) = YY(1 0) - argument A
 STA X1                 ;
                        ; to set X1 to the x-coordinate of the left end of the
                        ; line, starting with the low bytes

 LDA YY+1               ; And then subtracting the high bytes
 SBC #0

 BNE ED3                ; If the high byte subtraction is non-zero, then skip
                        ; to ED3

 CLC                    ; Otherwise the high byte of the subtraction was zero,
                        ; so the line fits on-screen and we clear the C flag to
                        ; indicate success

 RTS                    ; Return from the subroutine

.ED3

 BPL ED1                ; If the addition is positive then the calculation has
                        ; underflowed, so jump to ED1 to return a failure

 LDA #0                 ; The high byte is negative and non-zero, so we went
 STA X1                 ; past the left edge of the screen, so clip X1 to the
                        ; x-coordinate of the left edge of the screen

 CLC                    ; The line does fit on-screen, so clear the C flag to
                        ; indicate success

 RTS                    ; Return from the subroutine

.ED1

 LDA #0                 ; Set the Y-th byte of the LSO block to 0
 STA LSO,Y

 SEC                    ; The line does not fit on the screen, so set the C flag
                        ; to indicate this result

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: CHKON
;       Type: Subroutine
;   Category: Drawing circles
;    Summary: Check whether any part of a circle appears on the extended screen
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   K                   The circle's radius
;
;   K3(1 0)             Pixel x-coordinate of the centre of the circle
;
;   K4(1 0)             Pixel y-coordinate of the centre of the circle
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              Clear if any part of the circle appears on-screen, set
;                       if none of the circle appears on-screen
;
;   (A X)               Minimum y-coordinate of the circle on-screen (i.e. the
;                       y-coordinate of the top edge of the circle)
;
;   P(2 1)              Maximum y-coordinate of the circle on-screen (i.e. the
;                       y-coordinate of the bottom edge of the circle)
;
; ******************************************************************************

.CHKON

 LDA K3                 ; Set A = K3 + K
 CLC
 ADC K

 LDA K3+1               ; Set A = K3+1 + 0 + any carry from above, so this
 ADC #0                 ; effectively sets A to the high byte of K3(1 0) + K:
                        ;
                        ;   (A ?) = K3(1 0) + K
                        ;
                        ; so A is the high byte of the x-coordinate of the right
                        ; edge of the circle

 BMI PL21               ; If A is negative then the right edge of the circle is
                        ; to the left of the screen, so jump to PL21 to set the
                        ; C flag and return from the subroutine, as the whole
                        ; circle is off-screen to the left

 LDA K3                 ; Set A = K3 - K
 SEC
 SBC K

 LDA K3+1               ; Set A = K3+1 - 0 - any carry from above, so this
 SBC #0                 ; effectively sets A to the high byte of K3(1 0) - K:
                        ;
                        ;   (A ?) = K3(1 0) - K
                        ;
                        ; so A is the high byte of the x-coordinate of the left
                        ; edge of the circle

 BMI PL31               ; If A is negative then the left edge of the circle is
                        ; to the left of the screen, and we already know the
                        ; right edge is either on-screen or off-screen to the
                        ; right, so skip to PL31 to move on to the y-coordinate
                        ; checks, as at least part of the circle is on-screen in
                        ; terms of the x-axis

 BNE PL21               ; If A is non-zero, then the left edge of the circle is
                        ; to the right of the screen, so jump to PL21 to set the
                        ; C flag and return from the subroutine, as the whole
                        ; circle is off-screen to the right

.PL31

 LDA K4                 ; Set P+1 = K4 + K
 CLC
 ADC K
 STA P+1

 LDA K4+1               ; Set A = K4+1 + 0 + any carry from above, so this
 ADC #0                 ; does the following:
                        ;
                        ;   (A P+1) = K4(1 0) + K
                        ;
                        ; so A is the high byte of the y-coordinate of the
                        ; bottom edge of the circle

 BMI PL21               ; If A is negative then the bottom edge of the circle is
                        ; above the top of the screen, so jump to PL21 to set
                        ; the C flag and return from the subroutine, as the
                        ; whole circle is off-screen to the top

 STA P+2                ; Store the high byte in P+2, so now we have:
                        ;
                        ;   P(2 1) = K4(1 0) + K
                        ;
                        ; i.e. the maximum y-coordinate of the circle on-screen
                        ; (which we return)

 LDA K4                 ; Set X = K4 - K
 SEC
 SBC K
 TAX

 LDA K4+1               ; Set A = K4+1 - 0 - any carry from above, so this
 SBC #0                 ; does the following:
                        ;
                        ;   (A X) = K4(1 0) - K
                        ;
                        ; so A is the high byte of the y-coordinate of the top
                        ; edge of the circle

 BMI PL44               ; If A is negative then the top edge of the circle is
                        ; above the top of the screen, and we already know the
                        ; bottom edge is either on-screen or below the bottom
                        ; of the screen, so skip to PL44 to clear the C flag and
                        ; return from the subroutine using a tail call, as part
                        ; of the circle definitely appears on-screen

 BNE PL21               ; If A is non-zero, then the top edge of the circle is
                        ; below the bottom of the screen, so jump to PL21 to set
                        ; the C flag and return from the subroutine, as the
                        ; whole circle is off-screen to the bottom

 CPX Yx2M1              ; If we get here then A is zero, which means the top
                        ; edge of the circle is within the screen boundary, so
                        ; now we need to check whether it is in the space view
                        ; (in which case it is on-screen) or the dashboard (in
                        ; which case the top of the circle is hidden by the
                        ; dashboard, so the circle isn't on-screen). We do this
                        ; by checking the low byte of the result in X against
                        ; Yx2M1, and returning the C flag from this comparison.
                        ; The value in Yx2M1 is the y-coordinate of the bottom
                        ; pixel row of the space view, so this does the
                        ; following:
                        ;
                        ;   * The C flag is set if coordinate (A X) is below the
                        ;     bottom row of the space view, i.e. the top edge of
                        ;     the circle is hidden by the dashboard
                        ;
                        ;   * The C flag is clear if coordinate (A X) is above
                        ;     the bottom row of the space view, i.e. the top
                        ;     edge of the circle is on-screen

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: PL21
;       Type: Subroutine
;   Category: Drawing planets
;    Summary: Return from a planet/sun-drawing routine with a failure flag
;
; ------------------------------------------------------------------------------
;
; Set the C flag and return from the subroutine. This is used to return from a
; planet- or sun-drawing routine with the C flag indicating an overflow in the
; calculation.
;
; ******************************************************************************

.PL21

 SEC                    ; Set the C flag to indicate an overflow

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: PLS6
;       Type: Subroutine
;   Category: Drawing planets
;    Summary: Calculate (X K) = (A P+1 P) / (z_sign z_hi z_lo)
;
; ------------------------------------------------------------------------------
;
; Calculate the following:
;
;   (X K) = (A P+1 P) / (z_sign z_hi z_lo)
;
; returning an overflow in the C flag if the result is >= 1024.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   INWK                The planet or sun's ship data block
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              Set if the result >= 1024, clear otherwise
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   PL44                Clear the C flag and return from the subroutine
;
;   PL6                 Contains an RTS
;
; ******************************************************************************

.PLS6

 JSR DVID3B2            ; Call DVID3B2 to calculate:
                        ;
                        ;   K(3 2 1 0) = (A P+1 P) / (z_sign z_hi z_lo)

 LDA K+3                ; Set A = |K+3| OR K+2
 AND #%01111111
 ORA K+2

 BNE PL21               ; If A is non-zero then the two high bytes of K(3 2 1 0)
                        ; are non-zero, so jump to PL21 to set the C flag and
                        ; return from the subroutine

                        ; We can now just consider K(1 0), as we know the top
                        ; two bytes of K(3 2 1 0) are both 0

 LDX K+1                ; Set X = K+1, so now (X K) contains the result in
                        ; K(1 0), which is the format we want to return the
                        ; result in

 CPX #4                 ; If the high byte of K(1 0) >= 4 then the result is
 BCS PL6                ; >= 1024, so return from the subroutine with the C flag
                        ; set to indicate an overflow (as PL6 contains an RTS)

 LDA K+3                ; Fetch the sign of the result from K+3 (which we know
                        ; has zeroes in bits 0-6, so this just fetches the sign)

;CLC                    ; This instruction is commented out in the original
                        ; source. It would have no effect as we know the C flag
                        ; is already clear, as we skipped past the BCS above

 BPL PL6                ; If the sign bit is clear and the result is positive,
                        ; then the result is already correct, so return from
                        ; the subroutine with the C flag clear to indicate
                        ; success (as PL6 contains an RTS)

 LDA K                  ; Otherwise we need to negate the result, which we do
 EOR #%11111111         ; using two's complement, starting with the low byte:
 ADC #1                 ;
 STA K                  ;   K = ~K + 1

 TXA                    ; And then the high byte:
 EOR #%11111111         ;
 ADC #0                 ;   X = ~X
 TAX

.PL44

 CLC                    ; Clear the C flag to indicate success

.PL6

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: YESNO
;       Type: Subroutine
;   Category: Keyboard
;    Summary: Wait until either "Y" or "N" is pressed
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              Set if "Y" was pressed, clear if "N" was pressed
;
; ******************************************************************************

.YESNO

 JSR t                  ; Scan the keyboard until a key is pressed, returning
                        ; the ASCII code in A and X

 CMP #'Y'               ; If "Y" was pressed, return from the subroutine with
 BEQ PL6                ; the C flag set (as the CMP sets the C flag, and PL6
                        ; contains an RTS)

 CMP #'N'               ; If "N" was not pressed, loop back to keep scanning
 BNE YESNO              ; for key presses

 CLC                    ; Clear the C flag

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TT17
;       Type: Subroutine
;   Category: Keyboard
;    Summary: Scan the keyboard for cursor key or joystick movement
;
; ------------------------------------------------------------------------------
;
; Scan the keyboard and joystick for cursor key or stick movement, and return
; the result as deltas (changes) in x- and y-coordinates as follows:
;
;   * For joystick, X and Y are integers between -2 and +2 depending on how far
;     the stick has moved
;
;   * For keyboard, X and Y are integers between -1 and +1 depending on which
;     keys are pressed
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   A                   The key pressed, if the arrow keys were used
;
;   X                   Change in the x-coordinate according to the cursor keys
;                       being pressed or joystick movement, as an integer (see
;                       above)
;
;   Y                   Change in the y-coordinate according to the cursor keys
;                       being pressed or joystick movement, as an integer (see
;                       above)
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   TJ1                 Check for cursor key presses and return the combined
;                       deltas for the digital joystick and cursor keys (Master
;                       Compact only)
;
; ******************************************************************************

.TT17

 LDA QQ11               ; If this not the space view, skip the following three
 BNE TT17afterall       ; instructions to move onto the SHIFT key logic

 JSR DOKEY              ; This is the space view, so scan the keyboard for
                        ; flight controls and pause keys, (or the equivalent on
                        ; joystick) and update the key logger, setting KL to the
                        ; key pressed

 TXA                    ; Transfer the value of the key pressed from X to A

 RTS                    ; Return from the subroutine

.TT17afterall

 JSR DOKEY              ; Scan the keyboard for flight controls and pause keys,
                        ; (or the equivalent on joystick) and update the key
                        ; logger, setting KL to the key pressed

 LDA JSTK               ; If the joystick is not configured, jump down to TJ1,
 BEQ TJ1                ; otherwise we move the cursor with the joystick

 LDA JSTY               ; Fetch the joystick pitch, ranging from 1 to 255 with
                        ; 128 as the centre point

 JSR TJS1               ; Call TJS1 just below to set A to a value between -4
                        ; and +4 depending on the joystick pitch value (moving
                        ; the stick up and down)

 TAY                    ; Copy the result into Y

 LDA JSTX               ; Fetch the joystick roll, ranging from 1 to 255 with
                        ; 128 as the centre point

 EOR #$FF               ; Flip the sign so A = -JSTX, because the joystick roll
                        ; works in the opposite way to moving a cursor on-screen
                        ; in terms of left and right

 JSR TJS1               ; Call TJS1 just below to set A to a value between -4
                        ; and +4 depending on the joystick roll value (moving
                        ; the stick sideways)

 TAX                    ; Copy A to X, so X contains the joystick roll value

IF _SOURCE_DISK_CODE_FILES

 LDA $80                ; ???
 RTS
 LDA $85
 BIT $86
 BPL L794B
 LDA #$01
     
.L794B

 BIT $87

 BPL L7951
 ASL A
 ASL A

.L7951

 TAY

 LDA #$00
 STA $83
 STA $84
 STA $85
 STA $86
 STA $87

ENDIF

 LDA thiskey            ; Fetch the key pressed from thiskey in the key logger

 RTS                    ; Return from the subroutine

.TJ1

IF _IB_DISK

 LDA #0
 STA $8C
 STA $8E

ENDIF

 LDA thiskey            ; Fetch the key pressed from thiskey in the key logger

 LDX #0                 ; Set the initial values for the results, X = Y = 0,
 LDY #0                 ; which we now increase or decrease appropriately

 CMP #8                 ; ???

IF _IB_DISK

 BEQ $794B
 CMP #$4A

ENDIF

 BNE P%+3
 DEX
 CMP #21

IF _IB_DISK

 BEQ P%+6
 CMP #$4B

ENDIF

 BNE P%+3
 INX
 CMP #10

IF _IB_DISK

 BEQ P%+6
 CMP #$4D

ENDIF

 BNE P%+3
 DEY
 CMP #11

IF _IB_DISK

 BEQ P%+6
 CMP #$49

ENDIF

 BNE P%+3
 INY
 RTS

.TJS1

                        ; This routine calculates the following:
                        ;
                        ;   A = round(A / 16) - 4
                        ;
                        ; This set A to a value between -4 and +4, given an
                        ; initial value ranging from 1 to 255 with 128 as
                        ; the centre point

 LSR A                  ; Set A = A / 16
 LSR A                  ;
 LSR A                  ; and C contains the last bit to be shifted out
 LSR A
 LSR A

 ADC #0                 ; If that last bit was a 1, this increments A, so
                        ; this effectively implements a rounding function,
                        ; where 0.5 and above get rounded up

 SBC #3                 ; The addition will not overflow, so the C flag is
                        ; clear at this point, so this performs:
                        ;
                        ;   A = A - 3 - (1 - C)
                        ;     = A - 3 - (1 - 0)
                        ;     = A - 3 - 1
                        ;     = A - 4

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
; Save ELTE.bin
;
; ******************************************************************************

 PRINT "ELITE E"
 PRINT "Assembled at ", ~CODE_E%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_E%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_E%

 PRINT "S.ELTE ", ~CODE_E%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_E%
 SAVE "3-assembled-output/ELTE.bin", CODE_E%, P%, LOAD%

; ******************************************************************************
;
; ELITE F FILE
;
; Produces the binary file ELTF.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_F% = P%

 LOAD_F% = LOAD% + P% - CODE%

; ******************************************************************************
;
;       Name: KS3
;       Type: Subroutine
;   Category: Universe
;    Summary: Set the SLSP ship line heap pointer after shuffling ship slots
;
; ------------------------------------------------------------------------------
;
; The final part of the KILLSHP routine, called after we have shuffled the ship
; slots and sorted out our missiles. This simply sets SLSP to the new bottom of
; the ship line heap.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   P(1 0)              Points to the ship line heap of the ship in the last
;                       occupied slot (i.e. it points to the bottom of the
;                       descending heap)
;
; ******************************************************************************

.KS3

 LDA P                  ; After shuffling the ship slots, P(1 0) will point to
 STA SLSP               ; the new bottom of the ship line heap, so store this in
 LDA P+1                ; SLSP(1 0), which stores the bottom of the heap
 STA SLSP+1

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: KS1
;       Type: Subroutine
;   Category: Universe
;    Summary: Remove the current ship from our local bubble of universe
;
; ------------------------------------------------------------------------------
;
; Part 12 of the main flight loop calls this routine to remove the ship that is
; currently being analysed by the flight loop. Once the ship is removed, it
; jumps back to MAL1 to rejoin the main flight loop, with X pointing to the
; same slot that we just cleared (and which now contains the next ship in the
; local bubble of universe).
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   XX0                 The address of the blueprint for this ship
;
;   INF                 The address of the data block for this ship
;
; ******************************************************************************

.KS1

 LDX XSAV               ; Store the current ship's slot number in XSAV

 JSR KILLSHP            ; Call KILLSHP to remove the ship in slot X from our
                        ; local bubble of universe

 LDX XSAV               ; Restore the current ship's slot number from XSAV,
                        ; which now points to the next ship in the bubble

 JMP MAL1               ; Jump to MAL1 to rejoin the main flight loop at the
                        ; start of the ship analysis loop

; ******************************************************************************
;
;       Name: KS4
;       Type: Subroutine
;   Category: Universe
;    Summary: Remove the space station and replace it with the sun
;
; ******************************************************************************

.KS4

 JSR ZINF               ; Call ZINF to reset the INWK ship workspace

 JSR FLFLLS             ; Reset the LSO block, returns with A = 0

 STA FRIN+1             ; Set the second slot in the FRIN table to 0, which
                        ; sets this slot to empty, so when we call NWSHP below
                        ; the new sun that gets created will go into FRIN+1

 STA SSPR               ; Set the "space station present" flag to 0, as we are
                        ; no longer in the space station's safe zone

 JSR SPBLB              ; Call SPBLB to redraw the space station bulb, which
                        ; will erase it from the dashboard

 LDA #6                 ; Set the sun's y_sign to 6
 STA INWK+5

 LDA #129               ; Set A = 129, the ship type for the sun

 JMP NWSHP              ; Call NWSHP to set up the sun's data block and add it
                        ; to FRIN, where it will get put in the second slot as
                        ; we just cleared out the second slot, and the first
                        ; slot is already taken by the planet

; ******************************************************************************
;
;       Name: KS2
;       Type: Subroutine
;   Category: Universe
;    Summary: Check the local bubble for missiles with target lock
;
; ------------------------------------------------------------------------------
;
; Check the local bubble of universe to see if there are any missiles with
; target lock in the vicinity. If there are, then check their targets; if we
; just removed their target in the KILLSHP routine, then switch off their AI so
; they just drift in space, otherwise update their targets to reflect the newly
; shuffled slot numbers.
;
; This is called from KILLSHP once the slots have been shuffled down, following
; the removal of a ship.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   XX4                 The slot number of the ship we removed just before
;                       calling this routine
;
; ******************************************************************************

.KS2

 LDX #$FF               ; We want to go through the ships in our local bubble
                        ; and pick out all the missiles, so set X to $FF to
                        ; use as a counter

.KSL4

 INX                    ; Increment the counter (so it starts at 0 on the first
                        ; iteration)

 LDA FRIN,X             ; If slot X is empty then we have worked our way through
 BEQ KS3                ; all the slots, so jump to KS3 to stop looking

 CMP #MSL               ; If the slot does not contain a missile, loop back to
 BNE KSL4               ; KSL4 to check the next slot

                        ; We have found a slot containing a missile, so now we
                        ; want to check whether it has target lock

 TXA                    ; Set Y = X * 2 and fetch the Y-th address from UNIV
 ASL A                  ; and store it in SC and SC+1 - in other words, set
 TAY                    ; SC(1 0) to point to the missile's ship data block
 LDA UNIV,Y
 STA SC
 LDA UNIV+1,Y
 STA SC+1

 LDY #32                ; Fetch byte #32 from the missile's ship data (AI)
 LDA (SC),Y

 BPL KSL4               ; If bit 7 of byte #32 is clear, then the missile is
                        ; dumb and has no AI, so loop back to KSL4 to move on
                        ; to the next slot

 AND #%01111111         ; Otherwise this missile has AI, so clear bit 7 and
 LSR A                  ; shift right to set the C flag to the missile's "is
                        ; locked" flag, and A to the target's slot number

 CMP XX4                ; If this missile's target is less than XX4, then the
 BCC KSL4               ; target's slot isn't being shuffled down, so jump to
                        ; KSL4 to move on to the next slot

 BEQ KS6                ; If this missile was locked onto the ship that we just
                        ; removed in KILLSHP, jump to KS6 to stop the missile
                        ; from continuing to hunt it down

 SBC #1                 ; Otherwise this missile is locked and has AI enabled,
                        ; and its target will have moved down a slot, so
                        ; subtract 1 from the target number (we know C is set
                        ; from the BCC above)

 ASL A                  ; Shift the target number left by 1, so it's in bits
                        ; 1-6 once again, and also set bit 0 to 1, as the C
                        ; flag is still set, so this makes sure the missile is
                        ; still set to being locked

 ORA #%10000000         ; Set bit 7, so the missile's AI is enabled

 STA (SC),Y             ; Update the missile's AI flag to the value in A

 BNE KSL4               ; Loop back to KSL4 to move on to the next slot (this
                        ; BNE is effectively a JMP as A will never be zero)

.KS6

 LDA #0                 ; The missile's target lock just got removed, so set the
 STA (SC),Y             ; AI flag to 0 to make it dumb and not locked

 BEQ KSL4               ; Loop back to KSL4 to move on to the next slot (this
                        ; BEQ is effectively a JMP as A is always zero)

; ******************************************************************************
;
;       Name: KILLSHP
;       Type: Subroutine
;   Category: Universe
;    Summary: Remove a ship from our local bubble of universe
;
; ------------------------------------------------------------------------------
;
; Remove the ship in slot X from our local bubble of universe. This happens
; when we kill a ship, collide with a ship and destroy it, or when a ship moves
; outside our local bubble.
;
; We also use this routine when we move out of range of the space station, in
; which case we replace it with the sun.
;
; When removing a ship, this creates a gap in the ship slots at FRIN, so we
; shuffle all the later slots down to close the gap. We also shuffle the ship
; data blocks at K% and ship line heap at WP, to reclaim all the memory that
; the removed ship used to occupy.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The slot number of the ship to remove
;
;   XX0                 The address of the blueprint for the ship to remove
;
;   INF                 The address of the data block for the ship to remove
;
; ******************************************************************************

.KILLSHP

 STX XX4                ; Store the slot number of the ship to remove in XX4

 LDA MSTG               ; Check whether this slot matches the slot number in
 CMP XX4                ; MSTG, which is the target of our missile lock

 BNE KS5                ; If our missile is not locked on this ship, jump to KS5

 LDY #GREEN             ; Otherwise we need to remove our missile lock, so call
 JSR ABORT              ; ABORT to disarm the missile and update the missile
                        ; indicators on the dashboard to green (Y = #GREEN)

 LDA #200               ; Print recursive token 40 ("TARGET LOST") as an
 JSR MESS               ; in-flight message

.KS5

 LDY XX4                ; Restore the slot number of the ship to remove into Y

 LDX FRIN,Y             ; Fetch the contents of the slot, which contains the
                        ; ship type

 CPX #SST               ; If this is the space station, then jump to KS4 to
 BEQ KS4                ; replace the space station with the sun

 CPX #CON               ; Did we just kill the Constrictor from mission 1? If
 BNE lll                ; not, jump to lll

 LDA TP                 ; We just killed the Constrictor from mission 1, so set
 ORA #%00000010         ; bit 1 of TP to indicate that we have successfully
 STA TP                 ; completed mission 1

 INC TALLY+1            ; Award 256 kill points for killing the Constrictor

.lll

 CPX #HER               ; Did we just kill a rock hermit? If we did, jump to
 BEQ blacksuspenders    ; blacksuspenders to decrease the junk count

 CPX #JL                ; If JL <= X < JH, i.e. the type of ship we killed in X
 BCC KS7                ; is junk (escape pod, alloy plate, cargo canister,
 CPX #JH                ; asteroid, splinter, Shuttle or Transporter), then keep
 BCS KS7                ; going, otherwise jump to KS7

.blacksuspenders

 DEC JUNK               ; We just killed junk, so decrease the junk counter

.KS7

 DEC MANY,X             ; Decrease the number of this type of ship in our little
                        ; bubble, which is stored in MANY+X (where X is the ship
                        ; type)

 LDX XX4                ; Restore the slot number of the ship to remove into X

                        ; We now want to remove this ship and reclaim all the
                        ; memory that it uses. Removing the ship will leave a
                        ; gap in three places, which we need to close up:
                        ;
                        ;   * The ship slots in FRIN
                        ;
                        ;   * The ship data blocks in K%
                        ;
                        ;   * The descending ship line heap at WP down
                        ;
                        ; The rest of this routine closes up these gaps by
                        ; looping through all the occupied ship slots after the
                        ; slot we are removing, one by one, and shuffling each
                        ; ship's slot, data block and line heap down to close
                        ; up the gaps left by the removed ship. As part of this,
                        ; we have to make sure we update any address pointers
                        ; so they point to the newly shuffled data blocks and
                        ; line heaps
                        ;
                        ; In the following, when shuffling a ship's data down
                        ; into the preceding empty slot, we call the ship that
                        ; we are shuffling down the "source", and we call the
                        ; empty slot we are shuffling it into the "destination"
                        ;
                        ; Before we start looping through the ships we need to
                        ; shuffle down, we need to set up some variables to
                        ; point to the source and destination line heaps

 LDY #5                 ; Fetch byte #5 of the removed ship's blueprint into A,
 LDA (XX0),Y            ; which gives the ship's maximum heap size for the ship
                        ; we are removing (i.e. the size of the gap in the heap
                        ; created by the ship removal)

                        ; INF currently contains the ship data for the ship we
                        ; are removing, and INF(34 33) contains the address of
                        ; the bottom of the ship's heap, so we can calculate
                        ; the address of the top of the heap by adding the heap
                        ; size to this address

 LDY #33                ; First we add A and the address in INF+33, to get the
 CLC                    ; low byte of the top of the heap, which we store in P
 ADC (INF),Y
 STA P

 INY                    ; And next we add A and the address in INF+34, with any
 LDA (INF),Y            ; carry from the previous addition, to get the high byte
 ADC #0                 ; of the top of the heap, which we store in P+1, so
 STA P+1                ; P(1 0) points to the top of this ship's heap

                        ; Now, we're ready to start looping through the ships
                        ; we want to move, moving the slots, data blocks and
                        ; line heap from the source to the destination. In the
                        ; following, we set up SC to point to the source data,
                        ; and INF (which currently points to the removed ship's
                        ; data that we can now overwrite) points to the
                        ; destination
                        ;
                        ; So P(1 0) now points to the top of the line heap for
                        ; the destination

.KSL1

 INX                    ; On entry, X points to the empty slot we want to
                        ; shuffle the next ship into (the destination), so
                        ; this increment points X to the next slot - i.e. the
                        ; source slot we want to shuffle down

 LDA FRIN,X             ; Copy the contents of the source slot into the
 STA FRIN-1,X           ; destination slot

 BNE P%+5               ; If the slot we just shuffled down is not empty, then
                        ; skip the following instruction

 JMP KS2                ; The source slot is empty and we are done shuffling,
                        ; so jump to KS2 to move on to processing missiles

 ASL A                  ; Otherwise we have a source ship to shuffle down into
 TAY                    ; the destination, so set Y = A * 2 so it can act as an
                        ; index into the two-byte ship blueprint lookup table
                        ; at XX21 for the source ship

 LDA XX21-2,Y           ; Set SC(0 1) to point to the blueprint data for the
 STA SC                 ; source ship
 LDA XX21-1,Y
 STA SC+1

 LDY #5                 ; Fetch blueprint byte #5 for the source ship, which
 LDA (SC),Y             ; gives us its maximum heap size, and store it in T
 STA T

                        ; We now subtract T from P(1 0), so P(1 0) will point to
                        ; the bottom of the line heap for the destination
                        ; (which we will use later when closing up the gap in
                        ; the heap space)

 LDA P                  ; First, we subtract the low bytes
 SEC
 SBC T
 STA P

 LDA P+1                ; And then we do the high bytes, for which we subtract
 SBC #0                 ; 0 to include any carry, so this is effectively doing
 STA P+1                ; P(1 0) = P(1 0) - (0 T)

                        ; Next, we want to set SC(1 0) to point to the source
                        ; ship's data block

 TXA                    ; Set Y = X * 2 so it can act as an index into the
 ASL A                  ; two-byte lookup table at UNIV, which contains the
 TAY                    ; addresses of the ship data blocks. In this case we are
                        ; multiplying X by 2, and X contains the source ship's
                        ; slot number so Y is now an index for the source ship's
                        ; entry in UNIV

 LDA UNIV,Y             ; Set SC(1 0) to the address of the data block for the
 STA SC                 ; source ship
 LDA UNIV+1,Y
 STA SC+1

                        ; We have now set up our variables as follows:
                        ;
                        ;   SC(1 0) points to the source's ship data block
                        ;
                        ;   INF(1 0) points to the destination's ship data block
                        ;
                        ;   P(1 0) points to the destination's line heap
                        ;
                        ; so let's start copying data from the source to the
                        ; destination

 LDY #36                ; We are going to be using Y as a counter for the 37
                        ; bytes of ship data we want to copy from the source
                        ; to the destination, so we set it to 36 to start things
                        ; off, and will decrement Y for each byte we copy

 LDA (SC),Y             ; Fetch byte #36 of the source's ship data block at SC,
 STA (INF),Y            ; and store it in byte #36 of the destination's block
 DEY                    ; at INF, so that's the ship's NEWB flags copied from
                        ; the source to the destination. One down, quite a few
                        ; to go...

 LDA (SC),Y             ; Fetch byte #35 of the source's ship data block at SC,
 STA (INF),Y            ; and store it in byte #35 of the destination's block
                        ; at INF, so that's the ship's energy copied from the
                        ; source to the destination

 DEY                    ; Fetch byte #34 of the source ship, which is the
 LDA (SC),Y             ; high byte of the source ship's line heap, and store
 STA K+1                ; in K+1

 LDA P+1                ; Set the low byte of the destination's heap pointer
 STA (INF),Y            ; to P+1

 DEY                    ; Fetch byte #33 of the source ship, which is the
 LDA (SC),Y             ; low byte of the source ship's heap, and store in K
 STA K                  ; so now we have the following:
                        ;
                        ;   K(1 0) points to the source's line heap

 LDA P                  ; Set the low byte of the destination's heap pointer
 STA (INF),Y            ; to P, so now the destination's heap pointer is to
                        ; P(1 0), so that's the heap pointer in bytes #33 and
                        ; #34 done

 DEY                    ; Luckily, we can just copy the rest of the source's
                        ; ship data block into the destination, as there are no
                        ; more address pointers, so first we decrement our
                        ; counter in Y to point to the next byte (the AI flag)
                        ; in byte #32) and then start looping

.KSL2

 LDA (SC),Y             ; Copy the Y-th byte of the source to the Y-th byte of
 STA (INF),Y            ; the destination

 DEY                    ; Decrement the counter

 BPL KSL2               ; Loop back to KSL2 to copy the next byte until we have
                        ; copied the whole block

                        ; We have now shuffled the ship's slot and the ship's
                        ; data block, so we only have the heap data itself to do

 LDA SC                 ; First, we copy SC into INF, so when we loop round
 STA INF                ; again, INF will correctly point to the destination for
 LDA SC+1               ; the next iteration
 STA INF+1

 LDY T                  ; Now we want to move the contents of the heap, as all
                        ; we did above was to update the pointers, so first
                        ; we set a counter in Y that is initially set to T
                        ; (which we set above to the maximum heap size for the
                        ; source ship)
                        ;
                        ; As a reminder, we have already set the following:
                        ;
                        ;   K(1 0) points to the source's line heap
                        ;
                        ;   P(1 0) points to the destination's line heap
                        ;
                        ; so we can move the heap data by simply copying the
                        ; correct number of bytes from K(1 0) to P(1 0)
.KSL3

 DEY                    ; Decrement the counter

 LDA (K),Y              ; Copy the Y-th byte of the source heap at K(1 0) to
 STA (P),Y              ; the destination heap at P(1 0)

 TYA                    ; Loop back to KSL3 to copy the next byte, until we
 BNE KSL3               ; have done them all

 BEQ KSL1               ; We have now shuffled everything down one slot, so
                        ; jump back up to KSL1 to see if there is another slot
                        ; that needs shuffling down (this BEQ is effectively a
                        ; JMP as A will always be zero)

; ******************************************************************************
;
;       Name: THERE
;       Type: Subroutine
;   Category: Missions
;    Summary: Check whether we are in the Constrictor's system in mission 1
;
; ------------------------------------------------------------------------------
;
; The stolen Constrictor is the target of mission 1. We finally track it down to
; the Orarra system in the second galaxy, which is at galactic coordinates
; (144, 33). This routine checks whether we are in this system and sets the C
; flag accordingly.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              Set if we are in the Constrictor system, otherwise clear
;
; ******************************************************************************

.THERE

 LDX GCNT               ; Set X = GCNT - 1
 DEX

 BNE THEX               ; If X is non-zero (i.e. GCNT is not 1, so we are not in
                        ; the second galaxy), then jump to THEX

 LDA QQ0                ; Set A = the current system's galactic x-coordinate

 CMP #144               ; If A <> 144 then jump to THEX
 BNE THEX

 LDA QQ1                ; Set A = the current system's galactic y-coordinate

 CMP #33                ; If A = 33 then set the C flag

 BEQ THEX+1             ; If A = 33 then jump to THEX+1, so we return from the
                        ; subroutine with the C flag set (otherwise we clear the
                        ; C flag with the next instruction)

.THEX

 CLC                    ; Clear the C flag

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: RESET
;       Type: Subroutine
;   Category: Start and end
;    Summary: Reset most variables
;
; ------------------------------------------------------------------------------
;
; Reset our ship and various controls, recharge shields and energy, and then
; fall through into RES2 to reset the stardust and the ship workspace at INWK.
;
; In this subroutine, this means zero-filling the following locations:
;
;   * Pages $9, $A, $B, $C and $D
;
;   * BETA to BETA+6, which covers the following:
;
;     * BETA, BET1 - Set pitch to 0
;
;     * XC, YC - Set text cursor to (0, 0)
;
;     * QQ22 - Set hyperspace counters to 0
;
;     * ECMA - Turn E.C.M. off
;
; It also sets QQ12 to $FF, to indicate we are docked, recharges the shields and
; energy banks, and then falls through into RES2.
;
; ******************************************************************************

.RESET

 JSR ZERO               ; Reset the ship slots for the local bubble of universe,
                        ; and various flight and ship status variables

 LDX #6                 ; Set up a counter for zeroing BETA through BETA+6

.SAL3

 STA BETA,X             ; Zero the X-th byte after BETA

 DEX                    ; Decrement the loop counter

 BPL SAL3               ; Loop back for the next byte to zero

 STX JSTGY              ; X is now negative - i.e. $FF - so this sets JSTGY to
                        ; $FF to set the joystick Y-channel to the default
                        ; direction

 TXA                    ; X is now negative - i.e. $FF - so this sets A and QQ12
 STA QQ12               ; to $FF to indicate we are docked

 LDX #2                 ; We're now going to recharge both shields and the
                        ; energy bank, which live in the three bytes at FSH,
                        ; ASH (FSH+1) and ENERGY (FSH+2), so set a loop counter
                        ; in X for 3 bytes

.REL5

 STA FSH,X              ; Set the X-th byte of FSH to $FF to charge up that
                        ; shield/bank

 DEX                    ; Decrement the loop counter

 BPL REL5               ; Loop back to REL5 until we have recharged both shields
                        ; and the energy bank

                        ; Fall through into RES2 to reset the stardust and ship
                        ; workspace at INWK

; ******************************************************************************
;
;       Name: RES2
;       Type: Subroutine
;   Category: Start and end
;    Summary: Reset a number of flight variables and workspaces
;
; ------------------------------------------------------------------------------
;
; This is called after we launch from a space station, arrive in a new system
; after hyperspace, launch an escape pod, or die a cold, lonely death in the
; depths of space.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   Y                   Y is set to $FF
;
; ******************************************************************************

.RES2

;JSR stopbd             ; This instruction is commented out in the original
                        ; source

 LDA #NOST              ; Reset NOSTM, the number of stardust particles, to the
 STA NOSTM              ; maximum allowed (20)

 LDX #$FF               ; Reset LSX2 and LSY2, the ball line heaps used by the
 STX LSX2               ; BLINE routine for drawing circles, to $FF, to set the
 STX LSY2               ; heap to empty

 STX MSTG               ; Reset MSTG, the missile target, to $FF (no target)

 LDA #128               ; Set the current pitch rate to the mid-point, 128
 STA JSTY

 STA ALP2               ; Reset ALP2 (roll sign) and BET2 (pitch sign)
 STA BET2               ; to negative, i.e. pitch and roll negative

 ASL A                  ; This sets A to 0

 STA BETA               ; Reset BETA (pitch angle alpha) to 0

 STA BET1               ; Reset BET1 (magnitude of the pitch angle) to 0

 STA ALP2+1             ; Reset ALP2+1 (flipped roll sign) and BET2+1 (flipped
 STA BET2+1             ; pitch sign) to positive, i.e. pitch and roll negative

 STA MCNT               ; Reset MCNT (the main loop counter) to 0

;STA TRIBCT             ; This instruction is commented out in the original
                        ; source; it is left over from the Commodore 64 version
                        ; of Elite and would reset the number of Trumbles

 LDA #3                 ; Reset DELTA (speed) to 3
 STA DELTA

 STA ALPHA              ; Reset ALPHA (roll angle alpha) to 3

 STA ALP1               ; Reset ALP1 (magnitude of roll angle alpha) to 3

;LDA #$10               ; These instructions are commented out in the original
;STA COL2               ; source

 LDA #0                 ; Set dontclip to 0 (though this variable is never used,
 STA dontclip           ; so this has no effect)

 LDA #2*Y-1             ; Set Yx2M1 to the number of pixel lines in the space
 STA Yx2M1              ; view

 LDA SSPR               ; Fetch the "space station present" flag, and if we are
 BEQ P%+5               ; not inside the safe zone, skip the next instruction

 JSR SPBLB              ; Light up the space station bulb on the dashboard

 LDA ECMA               ; Fetch the E.C.M. status flag, and if E.C.M. is off,
 BEQ yu                 ; skip the next instruction

 JSR ECMOF              ; Turn off the E.C.M. sound

.yu

 JSR WPSHPS             ; Wipe all ships from the scanner

 JSR ZERO               ; Reset the ship slots for the local bubble of universe,
                        ; and various flight and ship status variables

 LDA #LO(LS%)           ; We have reset the ship line heap, so we now point
 STA SLSP               ; SLSP to LS% (the byte below the ship blueprints at D%)
 LDA #HI(LS%)           ; to indicate that the heap is empty
 STA SLSP+1

                        ; Finally, fall through into ZINF to reset the INWK
                        ; ship workspace

; ******************************************************************************
;
;       Name: ZINF
;       Type: Subroutine
;   Category: Universe
;    Summary: Reset the INWK workspace and orientation vectors
;  Deep dive: Orientation vectors
;
; ------------------------------------------------------------------------------
;
; Zero-fill the INWK ship workspace and reset the orientation vectors, with
; nosev pointing out of the screen, towards us.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   Y                   Y is set to $FF
;
; ******************************************************************************

.ZINF

 LDY #NI%-1             ; There are NI% bytes in the INWK workspace, so set a
                        ; counter in Y so we can loop through them

 LDA #0                 ; Set A to 0 so we can zero-fill the workspace

.ZI1

 STA INWK,Y             ; Zero the Y-th byte of the INWK workspace

 DEY                    ; Decrement the loop counter

 BPL ZI1                ; Loop back for the next byte, ending when we have
                        ; zero-filled the last byte at INWK, which leaves Y
                        ; with a value of $FF

                        ; Finally, we reset the orientation vectors as follows:
                        ;
                        ;   sidev = (1,  0,  0)
                        ;   roofv = (0,  1,  0)
                        ;   nosev = (0,  0, -1)
                        ;
                        ; 96 * 256 ($6000) represents 1 in the orientation
                        ; vectors, while -96 * 256 ($E000) represents -1. We
                        ; already set the vectors to zero above, so we just
                        ; need to set up the high bytes of the diagonal values
                        ; and we're done. The negative nosev makes the ship
                        ; point towards us, as the z-axis points into the screen

 LDA #96                ; Set A to represent a 1 (in vector terms)

 STA INWK+18            ; Set byte #18 = roofv_y_hi = 96 = 1

 STA INWK+22            ; Set byte #22 = sidev_x_hi = 96 = 1

 ORA #%10000000         ; Flip the sign of A to represent a -1

 STA INWK+14            ; Set byte #14 = nosev_z_hi = -96 = -1

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: msblob
;       Type: Subroutine
;   Category: Dashboard
;    Summary: Display the dashboard's missile indicators in green
;
; ------------------------------------------------------------------------------
;
; Display the dashboard's missile indicators, with all the missiles reset to
; green (i.e. not armed or locked).
;
; ******************************************************************************

.msblob

 LDX #4                 ; Set up a loop counter in X to count through all four
                        ; missile indicators

.ss

 CPX NOMSL              ; If the counter is equal to the number of missiles,
 BEQ SAL8               ; jump down to SAL8 to draw the remaining missiles, as
                        ; the rest of them are present and should be drawn in
                        ; green

 LDY #BLACK             ; Draw the missile indicator at position X in black
 JSR MSBAR

 DEX                    ; Decrement the counter to point to the next missile

 BNE ss                 ; Loop back to ss if we still have missiles to draw

 RTS                    ; Return from the subroutine

.SAL8

 LDY #GREEN             ; Draw the missile indicator at position X in green
 JSR MSBAR

 DEX                    ; Decrement the counter to point to the next missile

 BNE SAL8               ; Loop back to SAL8 if we still have missiles to draw

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: me2
;       Type: Subroutine
;   Category: Flight
;    Summary: Remove an in-flight message from the space view
;
; ******************************************************************************

.me2

 LDA QQ11               ; If this is not the space view, jump down to clynsneed
 BNE clynsneed          ; to skip displaying the in-flight message

 LDA MCH                ; Fetch the token number of the current message into A

 JSR MESS               ; Call MESS to print the token, which will remove it
                        ; from the screen as printing uses EOR logic

 LDA #0                 ; Set the delay in DLY to 0, so any new in-flight
 STA DLY                ; messages will be shown instantly

 JMP me3                ; Jump back into the main spawning loop at me3

.clynsneed

 JSR CLYNS              ; Clear the bottom three text rows of the upper screen,
                        ; and move the text cursor to column 1 on row 21, i.e.
                        ; the start of the top row of the three bottom rows

 JMP me3                ; Jump back into the main spawning loop at me3

; ******************************************************************************
;
;       Name: Ze
;       Type: Subroutine
;   Category: Universe
;    Summary: Initialise the INWK workspace to a hostile ship
;  Deep dive: Fixing ship positions
;
; ------------------------------------------------------------------------------
;
; Specifically, this routine does the following:
;
;   * Reset the INWK ship workspace
;
;   * Set the ship to a fair distance away in all axes, in front of us but
;     randomly up or down, left or right
;
;   * Give the ship a 4% chance of having E.C.M.
;
;   * Set the ship to hostile, with AI enabled
;
; This routine also sets A, X, T1 and the C flag to random values.
;
; Note that because this routine uses the value of X returned by DORND, and X
; contains the value of A returned by the previous call to DORND, this routine
; does not necessarily set the new ship to a totally random location. See the
; deep dive on "Fixing ship positions" for details.
;
; ******************************************************************************

.Ze

 JSR ZINF               ; Call ZINF to reset the INWK ship workspace

 JSR DORND              ; Set A and X to random numbers

 STA T1                 ; Store A in T1

 AND #%10000000         ; Extract the sign of A and store in x_sign
 STA INWK+2

 TXA                    ; Extract the sign of X and store in y_sign
 AND #%10000000
 STA INWK+5

 LDA #25                ; Set x_hi = y_hi = z_hi = 25, a fair distance away
 STA INWK+1
 STA INWK+4
 STA INWK+7

 TXA                    ; Set the C flag if X >= 245 (4% chance)
 CMP #245

 ROL A                  ; Set bit 0 of A to the C flag (i.e. there's a 4%
                        ; chance of this ship having E.C.M.)

 ORA #%11000000         ; Set bits 6 and 7 of A, so the ship is hostile (bit 6
                        ; and has AI (bit 7)

 STA INWK+32            ; Store A in the AI flag of this ship

                        ; Fall through into DORND2 to set A, X and the C flag
                        ; randomly

; ******************************************************************************
;
;       Name: DORND
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Generate random numbers
;  Deep dive: Generating random numbers
;             Fixing ship positions
;
; ------------------------------------------------------------------------------
;
; Set A and X to random numbers (though note that X is set to the random number
; that was returned in A the last time DORND was called).
;
; The C and V flags are also set randomly.
;
; If we want to generate a repeatable sequence of random numbers, when
; generating explosion clouds, for example, then we call DORND2 to ensure that
; the value of the C flag on entry doesn't affect the outcome, as otherwise we
; might not get the same sequence of numbers if the C flag changes.
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   DORND2              Make sure the C flag doesn't affect the outcome
;
; ******************************************************************************

.DORND2

 CLC                    ; Clear the C flag so the value of the C flag on entry
                        ; doesn't affect the outcome

.DORND

 LDA RAND               ; Calculate the next two values f2 and f3 in the feeder
 ROL A                  ; sequence:
 TAX                    ;
 ADC RAND+2             ;   * f2 = (f1 << 1) mod 256 + C flag on entry
 STA RAND               ;   * f3 = f0 + f2 + (1 if bit 7 of f1 is set)
 STX RAND+2             ;   * C flag is set according to the f3 calculation

 LDA RAND+1             ; Calculate the next value m2 in the main sequence:
 TAX                    ;
 ADC RAND+3             ;   * A = m2 = m0 + m1 + C flag from feeder calculation
 STA RAND+1             ;   * X = m1
 STX RAND+3             ;   * C and V flags set according to the m2 calculation

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: Main game loop (Part 1 of 6)
;       Type: Subroutine
;   Category: Main loop
;    Summary: Spawn a trader (a Cobra Mk III, Python, Boa or Anaconda)
;  Deep dive: Program flow of the main game loop
;             Ship data blocks
;
; ------------------------------------------------------------------------------
;
; This is part of the main game loop. This is where the core loop of the game
; lives, and it's in two parts. The shorter loop (just parts 5 and 6) is
; iterated when we are docked, while the entire loop from part 1 to 6 iterates
; if we are in space.
;
; This section covers the following:
;
;   * Spawn a trader, i.e. a Cobra Mk III, Python, Boa or Anaconda, with a 50%
;     chance of it having a missile, a 50% chance of it having an E.C.M., a 50%
;     chance of it docking and being aggressive if attacked, a speed between 16
;     and 31, and a gentle clockwise roll
;
; We call this from within the main loop.
;
; ******************************************************************************

.MTT4

 JSR DORND              ; Set A and X to random numbers

 LSR A                  ; Clear bit 7 of our random number in A and set the C
                        ; flag to bit 0 of A, which is random

 STA INWK+32            ; Store this in the ship's AI flag, so this ship does
                        ; not have AI

 STA INWK+29            ; Store A in the ship's roll counter, giving it a
                        ; clockwise roll (as bit 7 is clear), and a 1 in 127
                        ; chance of it having no damping

 ROL INWK+31            ; Set bit 0 of the ship's missile count randomly (as the
                        ; C flag was set), giving the ship either no missiles or
                        ; one missile

 AND #31                ; Set the ship speed to our random number, set to a
 ORA #16                ; minimum of 16 and a maximum of 31
 STA INWK+27

 JSR DORND              ; Set A and X to random numbers, plus the C flag

 BMI nodo               ; If A is negative (50% chance), jump to nodo to skip
                        ; the following

                        ; If we get here then we are going to spawn a ship that
                        ; is minding its own business and trying to dock

 LDA INWK+32            ; Set bits 6 and 7 of the ship's AI flag, to make it
 ORA #%11000000         ; aggressive if attacked, and enable its AI
 STA INWK+32

 LDX #%00010000         ; Set bit 4 of the ship's NEWB flags, to indicate that
 STX NEWB               ; this ship is docking

.nodo

 AND #2                 ; If we jumped here with a random value of A from the
                        ; BMI above, then this reduces A to a random value of
                        ; either 0 or 2; if we didn't take the BMI and made the
                        ; ship hostile, then A will be 0

 ADC #CYL               ; Set A = A + C + #CYL
                        ;
                        ; where A is 0 or 2 and C is 0 or 1, so this gives us a
                        ; ship type from the following: Cobra Mk III, Python,
                        ; Boa or Anaconda

 CMP #HER               ; If A is now the ship type of a rock hermit, jump to
 BEQ TT100              ; TT100 to skip the following instruction

 JSR NWSHP              ; Add a new ship of type A to the local bubble and fall
                        ; through into the main game loop again

; ******************************************************************************
;
;       Name: Main game loop (Part 2 of 6)
;       Type: Subroutine
;   Category: Main loop
;    Summary: Call the main flight loop, and potentially spawn a trader, an
;             asteroid, or a cargo canister
;  Deep dive: Program flow of the main game loop
;             Ship data blocks
;             Fixing ship positions
;
; ------------------------------------------------------------------------------
;
; This section covers the following:
;
;   * Call M% to do the main flight loop
;
;   * Potentially spawn a trader, asteroid or cargo canister
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   TT100               The entry point for the start of the main game loop,
;                       which calls the main flight loop and the moves into the
;                       spawning routine
;
;   me3                 Used by me2 to jump back into the main game loop after
;                       printing an in-flight message
;
; ******************************************************************************

.TT100

 JSR M%                 ; Call M% to iterate through the main flight loop

 DEC DLY                ; Decrement the delay counter in DLY, so any in-flight
                        ; messages get removed once the counter reaches zero

 BEQ me2                ; If DLY is now 0, jump to me2 to remove any in-flight
                        ; message from the space view, and once done, return to
                        ; me3 below, skipping the following two instructions

 BPL me3                ; If DLY is positive, jump to me3 to skip the next
                        ; instruction

 INC DLY                ; If we get here, DLY is negative, so we have gone too
                        ; and need to increment DLY back to 0

.me3

 DEC MCNT               ; Decrement the main loop counter in MCNT

 BEQ P%+5               ; If the counter has reached zero, which it will do
                        ; every 256 main loops, skip the next JMP instruction
                        ; (or to put it another way, if the counter hasn't
                        ; reached zero, jump down to MLOOP, skipping all the
                        ; following checks)

.ytq

 JMP MLOOP              ; Jump down to MLOOP to do some end-of-loop tidying and
                        ; restart the main loop

                        ; We only get here once every 256 iterations of the
                        ; main loop. If we aren't in witchspace and don't
                        ; already have 3 or more asteroids in our local bubble,
                        ; then this section has a 13% chance of spawning
                        ; something benign (the other 87% of the time we jump
                        ; down to consider spawning cops, pirates and bounty
                        ; hunters)
                        ;
                        ; If we are in that 13%, then 50% of the time this will
                        ; be a Cobra Mk III trader, and the other 50% of the
                        ; time it will either be an asteroid (98.5% chance) or,
                        ; very rarely, a cargo canister (1.5% chance)

 LDA MJ                 ; If we are in witchspace following a mis-jump, skip the
 BNE ytq                ; following by jumping down to MLOOP (via ytq above)

 JSR DORND              ; Set A and X to random numbers

 CMP #35                ; If A >= 35 (87% chance), jump down to MTT1 to skip
 BCS MTT1               ; the spawning of an asteroid or cargo canister and
                        ; potentially spawn something else

 LDA JUNK               ; If we already have 3 or more bits of junk in the local
 CMP #3                 ; bubble, jump down to MTT1 to skip the following and
 BCS MTT1               ; potentially spawn something else

 JSR ZINF               ; Call ZINF to reset the INWK ship workspace

 LDA #38                ; Set z_hi = 38 (far away)
 STA INWK+7

 JSR DORND              ; Set A, X and C flag to random numbers

 STA INWK               ; Set x_lo = random

 STX INWK+3             ; Set y_lo = random
                        ;
                        ; Note that because we use the value of X returned by
                        ; DORND, and X contains the value of A returned by the
                        ; previous call to DORND, this does not set the new ship
                        ; to a totally random location. See the deep dive on
                        ; "Fixing ship positions" for details

 AND #%10000000         ; Set x_sign = bit 7 of x_lo
 STA INWK+2

 TXA                    ; Set y_sign = bit 7 of y_lo
 AND #%10000000
 STA INWK+5

 ROL INWK+1             ; Set bit 1 of x_hi to the C flag, which is random, so
 ROL INWK+1             ; this randomly moves us off-centre by 512 (as if x_hi
                        ; is %00000010, then (x_hi x_lo) is 512 + x_lo)

 JSR DORND              ; Set A, X and V flag to random numbers

 BVS MTT4               ; If V flag is set (50% chance), jump up to MTT4 to
                        ; spawn a trader

 ORA #%01101111         ; Take the random number in A and set bits 0-3 and 5-6,
 STA INWK+29            ; so the result has a 50% chance of being positive or
                        ; negative, and a 50% chance of bits 0-6 being 127.
                        ; Storing this number in the roll counter therefore
                        ; gives our new ship a fast roll speed with a 50%
                        ; chance of having no damping, plus a 50% chance of
                        ; rolling clockwise or anti-clockwise

 LDA SSPR               ; If we are inside the space station safe zone, jump
 BNE MTT1               ; down to MTT1 to skip the following and potentially
                        ; spawn something else

 TXA                    ; Set A to the random X we set above, which we haven't
 BCS MTT2               ; used yet, and if the C flag is set (50% chance) jump
                        ; down to MTT2 to skip the following

 AND #31                ; Set the ship speed to our random number, set to a
 ORA #16                ; minimum of 16 and a maximum of 31
 STA INWK+27

 BCC MTT3               ; Jump down to MTT3, skipping the following (this BCC
                        ; is effectively a JMP as we know the C flag is clear,
                        ; having passed through the BCS above)

.MTT2

 ORA #%01111111         ; Set bits 0-6 of A to 127, leaving bit 7 as random, so
 STA INWK+30            ; storing this number in the pitch counter means we have
                        ; full pitch with no damping, with a 50% chance of
                        ; pitching up or down

.MTT3

 JSR DORND              ; Set A and X to random numbers

 CMP #252               ; If random A < 252 (98.8% of the time), jump to thongs
 BCC thongs             ; to skip the following

 LDA #HER               ; Set A to #HER so we spawn a rock hermit 1.2% of the
                        ; time

 STA INWK+32            ; Set byte #32 to %00001111 to give the rock hermit an
                        ; E.C.M.

 BNE whips              ; Jump to whips (this BNE is effectively a JMP as A will
                        ; never be zero)

.thongs

 CMP #10                ; If random A >= 10 (96% of the time), set the C flag

 AND #1                 ; Reduce A to a random number that's 0 or 1

 ADC #OIL               ; Set A = #OIL + A + C, so there's a tiny chance of us
                        ; spawning a cargo canister (#OIL) and an even chance of
                        ; us spawning either a boulder (#OIL + 1) or an asteroid
                        ; (#OIL + 2)

.whips

 JSR NWSHP              ; Add our new asteroid or canister to the universe

; ******************************************************************************
;
;       Name: Main game loop (Part 3 of 6)
;       Type: Subroutine
;   Category: Main loop
;    Summary: Potentially spawn a cop, particularly if we've been bad
;  Deep dive: Program flow of the main game loop
;             Ship data blocks
;             Fixing ship positions
;
; ------------------------------------------------------------------------------
;
; This section covers the following:
;
;   * Potentially spawn a cop (in a Viper), very rarely if we have been good,
;     more often if have been naughty, and very often if we have been properly
;     bad
;
;   * Very rarely, consider spawning a Thargoid, or vanishingly rarely, a Cougar
;
; ******************************************************************************

.MTT1

 LDA SSPR               ; If we are outside the space station's safe zone, skip
 BEQ P%+5               ; the following instruction

.MLOOPS

 JMP MLOOP              ; Jump to MLOOP to skip the following

 JSR BAD                ; Call BAD to work out how much illegal contraband we
                        ; are carrying in our hold (A is up to 40 for a
                        ; standard hold crammed with contraband, up to 70 for
                        ; an extended cargo hold full of narcotics and slaves)

 ASL A                  ; Double A to a maximum of 80 or 140

 LDX MANY+COPS          ; If there are no cops in the local bubble, skip the
 BEQ P%+5               ; next instruction

 ORA FIST               ; There are cops in the vicinity and we've got a hold
                        ; full of jail time, so OR the value in A with FIST to
                        ; get a new value that is at least as high as both
                        ; values, to reflect the fact that they have almost
                        ; certainly scanned our ship

 STA T                  ; Store our badness level in T

 JSR Ze                 ; Call Ze to initialise INWK to a potentially hostile
                        ; ship, and set A and X to random values
                        ;
                        ; Note that because Ze uses the value of X returned by
                        ; DORND, and X contains the value of A returned by the
                        ; previous call to DORND, this does not set the new ship
                        ; to a totally random location. See the deep dive on
                        ; "Fixing ship positions" for details

 CMP #136               ; If the random number in A = 136 (0.4% chance), jump
 BEQ fothg              ; to fothg in part 4 to spawn either a Thargoid or, very
                        ; rarely, a Cougar

 CMP T                  ; If the random value in A >= our badness level, which
 BCS P%+7               ; will be the case unless we have been really, really
                        ; bad, then skip the following two instructions (so
                        ; if we are really bad, there's a higher chance of
                        ; spawning a cop, otherwise we got away with it, for
                        ; now)

 LDA #COPS              ; Add a new police ship to the local bubble
 JSR NWSHP

 LDA MANY+COPS          ; If we now have at least one cop in the local bubble,
 BNE MLOOPS             ; jump down to MLOOPS to stop spawning, otherwise fall
                        ; through into the next part to look at spawning
                        ; something else

; ******************************************************************************
;
;       Name: Main game loop (Part 4 of 6)
;       Type: Subroutine
;   Category: Main loop
;    Summary: Potentially spawn a lone bounty hunter, a Thargoid, or up to four
;             pirates
;  Deep dive: Program flow of the main game loop
;             Ship data blocks
;             Fixing ship positions
;             The elusive Cougar
;
; ------------------------------------------------------------------------------
;
; This section covers the following:
;
;   * Potentially spawn (35% chance) either a lone bounty hunter (a Cobra Mk
;     III, Asp Mk II, Python or Fer-de-lance), a Thargoid, or a group of up to 4
;     pirates (a mix of Sidewinders, Mambas, Kraits, Adders, Geckos, Cobras Mk I
;     and III, and Worms)
;
;   * Also potentially spawn a Constrictor if this is the mission 1 endgame, or
;     Thargoids if mission 2 is in progress
;
; ******************************************************************************

 DEC EV                 ; Decrement EV, the extra vessels spawning delay, and if
 BPL MLOOPS             ; it is still positive, jump to MLOOPS to stop spawning,
                        ; so we only do the following when the EV counter runs
                        ; down

 INC EV                 ; EV is negative, so bump it up again, setting it back
                        ; to 0

 LDA TP                 ; Fetch bits 2 and 3 of TP, which contain the status of
 AND #%00001100         ; mission 2

 CMP #%00001000         ; If bit 3 is set and bit 2 is clear, keep going to
 BNE nopl               ; spawn a Thargoid as we are transporting the plans in
                        ; mission 2 and the Thargoids are trying to stop us,
                        ; otherwise jump to nopl to skip spawning a Thargoid

 JSR DORND              ; Set A and X to random numbers

 CMP #200               ; If the random number in A < 200 (78% chance), jump to
 BCC nopl               ; nopl to skip spawning a Thargoid

.fothg

.fothg2

 JSR GTHG               ; Call GTHG to spawn a Thargoid ship and a Thargon
                        ; companion

.nopl

 JSR DORND              ; Set A and X to random numbers

 LDY gov                ; If the government of this system is 0 (anarchy), jump
 BEQ LABEL_2            ; straight to LABEL_2 to start spawning pirates or a
                        ; lone bounty hunter

 CMP #90                ; If the random number in A >= 90 (65% chance), jump to
 BCS MLOOPS             ; MLOOPS to stop spawning (so there's a 35% chance of
                        ; spawning pirates or a lone bounty hunter)

 AND #7                 ; Reduce the random number in A to the range 0-7, and
 CMP gov                ; if A is less than government of this system, jump
 BCC MLOOPS             ; to MLOOPS to stop spawning (so safer governments with
                        ; larger gov numbers have a greater chance of jumping
                        ; out, which is another way of saying that more
                        ; dangerous systems spawn pirates and bounty hunters
                        ; more often)

.LABEL_2

                        ; Now to spawn a lone bounty hunter, a Thargoid or a
                        ; group of pirates

 JSR Ze                 ; Call Ze to initialise INWK to a potentially hostile
                        ; ship, and set A and X to random values
                        ;
                        ; Note that because Ze uses the value of X returned by
                        ; DORND, and X contains the value of A returned by the
                        ; previous call to DORND, this does not set the new ship
                        ; to a totally random location. See the deep dive on
                        ; "Fixing ship positions" for details

 CMP #100               ; If the random number in A >= 100 (61% chance), jump
 BCS mt1                ; to mt1 to spawn pirates, otherwise keep going to
                        ; spawn a lone bounty hunter or a Thargoid

 INC EV                 ; Increase the extra vessels spawning counter, to
                        ; prevent the next attempt to spawn extra vessels

 AND #3                 ; Set A = random number in the range 0-3, which we
                        ; will now use to determine the type of ship

 ADC #CYL2              ; Add A to #CYL2 (we know the C flag is clear as we
                        ; passed through the BCS above), so A is now one of the
                        ; lone bounty hunter ships, i.e. Cobra Mk III (pirate),
                        ; Asp Mk II, Python (pirate) or Fer-de-lance
                        ;
                        ; Interestingly, this logic means that the Moray, which
                        ; is the ship after the Fer-de-lance in the XX21 table,
                        ; never spawns, as the above logic chooses a blueprint
                        ; number in the range CYL2 to CYL2+3 (i.e. 24 to 27),
                        ; and the Moray is blueprint 28
                        ;
                        ; No other code spawns the ship with blueprint 28, so
                        ; this means the Moray is never seen in Elite
                        ;
                        ; This is presumably a bug, which could be very easily
                        ; fixed by inserting one of the following instructions
                        ; before the ADC #CYL2 instruction above:
                        ;
                        ;   * SEC would change the range to 25 to 28, which
                        ;     would cover the Asp Mk II, Python (pirate),
                        ;     Fer-de-lance and Moray
                        ;
                        ;   * LSR A would set the C flag to a random number to
                        ;     give a range of 24 to 28, which would cover the
                        ;     Cobra Mk III (pirate), Asp Mk II, Python (pirate),
                        ;     Fer-de-lance and Moray
                        ;
                        ; It's hard to know what the authors' original intent
                        ; was, but the second approach makes the Moray and Cobra
                        ; Mk III the rarest choices, with the Asp Mk II, Python
                        ; and Fer-de-Lance being more likely, and as the Moray
                        ; is described in the literature as a rare ship, and the
                        ; Cobra can already be spawned as part of a group of
                        ; pirates (see mt1 below), I tend to favour the LSR A
                        ; solution over the SEC approach

 TAY                    ; Copy the new ship type to Y

 JSR THERE              ; Call THERE to see if we are in the Constrictor's
                        ; system in mission 1

 BCC NOCON              ; If the C flag is clear then we are not in the
                        ; Constrictor's system, so skip to NOCON

 LDA #%11111001         ; Set the AI flag of this ship so that it has E.C.M.,
 STA INWK+32            ; has a very high aggression level of 28 out of 31, is
                        ; hostile, and has AI enabled - nasty stuff!

 LDA TP                 ; Fetch bits 0 and 1 of TP, which contain the status of
 AND #%00000011         ; mission 1

 LSR A                  ; Shift bit 0 into the C flag

 BCC NOCON              ; If bit 0 is clear, skip to NOCON as mission 1 is not
                        ; in progress

 ORA MANY+CON           ; Bit 0 of A now contains bit 1 of TP, so this will be
                        ; set if we have already completed mission 1, so this OR
                        ; will be non-zero if we have either completed mission
                        ; 1, or there is already a Constrictor in our local
                        ; bubble of universe (in which case MANY+CON will be
                        ; non-zero)

 BEQ YESCON             ; If A = 0 then mission 1 is in progress, we haven't
                        ; completed it yet, and there is no Constrictor in the
                        ; vicinity, so jump to YESCON to spawn the Constrictor

.NOCON

 LDA #%00000100         ; Set bit 2 of the NEWB flags and clear all other bits,
 STA NEWB               ; so the ship we are about to spawn is hostile

                        ; We now build the AI flag for this ship in A

 JSR DORND              ; Set A and X to random numbers

 CMP #200               ; First, set the C flag if X >= 200 (22% chance)

 ROL A                  ; Set bit 0 of A to the C flag (i.e. there's a 22%
                        ; chance of this ship having E.C.M.)

 ORA #%11000000         ; Set bits 6 and 7 of A, so the ship is hostile (bit 6)
                        ; and has AI (bit 7)

 STA INWK+32            ; Store A in the AI flag of this ship

 TYA                    ; Set A to the new ship type in Y

 EQUB $2C               ; Skip the next instruction by turning it into
                        ; $2C $A9 $1F, or BIT $1FA9, which does nothing apart
                        ; from affect the flags

.YESCON

 LDA #CON               ; If we jump straight here, we are in the mission 1
                        ; endgame and it's time to spawn the Constrictor, so
                        ; set A to the Constrictor's type

.focoug

 JSR NWSHP              ; Spawn the new ship, whether it's a pirate, Thargoid,
                        ; Cougar or Constrictor

.mj1

 JMP MLOOP              ; Jump down to MLOOP, as we are done spawning ships

;.fothg                 ; These instructions are commented out in the original
;LDA K+6                ; source
;AND #$3E
;BNE fothg2
;LDA #18
;STA INWK+27
;LDA #$79
;STA INWK+32
;LDA #COU
;BNE focoug

.mt1

 AND #3                 ; It's time to spawn a group of pirates, so set A to a
                        ; random number in the range 0-3, which will be the
                        ; loop counter for spawning pirates below (so we will
                        ; spawn 1-4 pirates)

 STA EV                 ; Delay further spawnings by this number

 STA XX13               ; Store the number in XX13, the pirate counter

.mt3

 JSR DORND              ; Set A and X to random numbers

 STA T                  ; Set T to a random number

 JSR DORND              ; Set A and X to random numbers

 AND T                  ; Set A to the AND of two random numbers, so each bit
                        ; has 25% chance of being set which makes the chances
                        ; of a smaller number higher

 AND #7                 ; Reduce A to a random number in the range 0-7, though
                        ; with a bigger chance of a smaller number in this range

 ADC #PACK              ; #PACK is set to #SH3, the ship type for a Sidewinder,
                        ; so this sets our new ship type to one of the pack
                        ; hunters, namely a Sidewinder, Mamba, Krait, Adder,
                        ; Gecko, Cobra Mk I, Worm or Cobra Mk III (pirate)

 JSR NWSHP              ; Try adding a new ship of type A to the local bubble

 DEC XX13               ; Decrement the pirate counter

 BPL mt3                ; If we need more pirates, loop back up to mt3,
                        ; otherwise we are done spawning, so fall through into
                        ; the end of the main loop at MLOOP

; ******************************************************************************
;
;       Name: Main game loop (Part 5 of 6)
;       Type: Subroutine
;   Category: Main loop
;    Summary: Cool down lasers, make calls to update the dashboard
;  Deep dive: Program flow of the main game loop
;             The dashboard indicators
;
; ------------------------------------------------------------------------------
;
; This is the first half of the minimal game loop, which we iterate when we are
; docked. This section covers the following:
;
;   * Cool down lasers
;
;   * Make calls to update the dashboard
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   MLOOP               The entry point for the main game loop. This entry point
;                       comes after the call to the main flight loop and
;                       spawning routines, so it marks the start of the main
;                       game loop for when we are docked (as we don't need to
;                       call the main flight loop or spawning routines if we
;                       aren't in space)
;
; ******************************************************************************

.MLOOP

 LDX #$FF               ; Set the stack pointer to $01FF, which is the standard
 TXS                    ; location for the 6502 stack, so this instruction
                        ; effectively resets the stack

 LDX GNTMP              ; If the laser temperature in GNTMP is non-zero,
 BEQ EE20               ; decrement it (i.e. cool it down a bit)
 DEC GNTMP

.EE20

 LDX LASCT              ; Set X to the value of LASCT, the laser pulse count

 BEQ NOLASCT            ; If X = 0 then jump to NOLASCT to skip reducing LASCT,
                        ; as it can't be reduced any further

 DEX                    ; Decrement the value of LASCT in X

 BEQ P%+3               ; If X = 0, skip the next instruction

 DEX                    ; Decrement the value of LASCT in X again

 STX LASCT              ; Store the decremented value of X in LASCT, so LASCT
                        ; gets reduced by 2, but not into negative territory

.NOLASCT

;LDA QQ11               ; These instructions are commented out in the original
;BNE P%+5               ; source

 JSR DIALS              ; Call DIALS to update the dashboard

 LDA QQ11               ; If this is a space view, jump to plus13 to skip the
 BEQ plus13             ; following five instructions

 AND PATG               ; If PATG = $FF (author names are shown on start-up)
 LSR A                  ; and bit 0 of QQ11 is 1 (the current view is type 1),
 BCS plus13             ; then skip the following two instructions

 LDY #2                 ; Wait for 2/50 of a second (0.04 seconds), to slow the
 JSR DELAY              ; main loop down a bit

.plus13

 JSR TT17               ; Scan the keyboard for the cursor keys or joystick,
                        ; returning the cursor's delta values in X and Y and
                        ; the key pressed in A

; ******************************************************************************
;
;       Name: Main game loop (Part 6 of 6)
;       Type: Subroutine
;   Category: Main loop
;    Summary: Process non-flight key presses (docked keys)
;  Deep dive: Program flow of the main game loop
;
; ------------------------------------------------------------------------------
;
; This is the second half of the minimal game loop, which we iterate when we are
; docked. This section covers the following:
;
;   * Process more key presses (red function keys, docked keys etc.)
;
; It also supports joining the main loop with a key already "pressed", so we can
; jump into the main game loop to perform a specific action. In practice, this
; is used when we enter the docking bay in BAY to display Status Mode (red key
; f8), and when we finish buying or selling cargo in BAY2 to jump to the
; Inventory (red key f9).
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   FRCE                The entry point for the main game loop if we want to
;                       jump straight to a specific screen, by pretending to
;                       "press" a key, in which case A contains the internal key
;                       number of the key we want to "press"
;
; ******************************************************************************

.FRCE

 JSR TT102              ; Call TT102 to process the key pressed in A

 LDA QQ12               ; Fetch the docked flag from QQ12 into A

 BEQ P%+5               ; If we are docked, loop back up to MLOOP just above
 JMP MLOOP              ; to restart the main loop, but skipping all the flight
                        ; and spawning code in the top part of the main loop

 JMP TT100              ; Otherwise jump to TT100 to restart the main loop from
                        ; the start

; ******************************************************************************
;
;       Name: TT102
;       Type: Subroutine
;   Category: Keyboard
;    Summary: Process function key, save key, hyperspace and chart key presses
;             and update the hyperspace counter
;
; ------------------------------------------------------------------------------
;
; Process function key presses, plus "@" (save commander), "H" (hyperspace),
; "D" (show distance to system) and "O" (move chart cursor back to current
; system). We can also pass cursor position deltas in X and Y to indicate that
; the cursor keys or joystick have been used (i.e. the values that are returned
; by routine TT17).
;
; This routine also checks for the "F" key press (search for a system), which
; applies to enhanced versions only.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The key number of the key pressed
;
;   X                   The amount to move the crosshairs in the x-axis
;
;   Y                   The amount to move the crosshairs in the y-axis
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   T95                 Print the distance to the selected system
;
; ******************************************************************************

.TT102

 CMP #f8                ; If key "8" was pressed, jump to STATUS to show the
 BNE P%+5               ; Status Mode screen, returning from the subroutine
 JMP STATUS             ; using a tail call

 CMP #f4                ; If key "4" was pressed, jump to TT22 to show the
 BNE P%+5               ; Long-range Chart, returning from the subroutine using
 JMP TT22               ; a tail call

 CMP #f5                ; If key "5" was pressed, jump to TT23 to show the
 BNE P%+5               ; Short-range Chart, returning from the subroutine using
 JMP TT23               ; a tail call

 CMP #f6                ; If key "6" was pressed, call TT111 to select the
 BNE TT92               ; system nearest to galactic coordinates (QQ9, QQ10)
 JSR TT111              ; (the location of the chart crosshairs) and set ZZ to
 JMP TT25               ; the system number, and then jump to TT25 to show the
                        ; Data on System screen (along with an extended system
                        ; description for the system in ZZ if we're docked),
                        ; returning from the subroutine using a tail call

.TT92

 CMP #f9                ; If key "9" was pressed, jump to TT213 to show the
 BNE P%+5               ; Inventory screen, returning from the subroutine
 JMP TT213              ; using a tail call

 CMP #f7                ; If key "7" was pressed, jump to TT167 to show the
 BNE P%+5               ; Market Price screen, returning from the subroutine
 JMP TT167              ; using a tail call

 CMP #f0                ; If key "1" was pressed, jump to TT110 to launch our
 BNE fvw                ; ship (if docked), returning from the subroutine using
 JMP TT110              ; a tail call

.fvw

 BIT QQ12               ; If bit 7 of QQ12 is clear (i.e. we are not docked, but
 BPL INSP               ; in space), jump to INSP to skip the following checks
                        ; for f1-f3 and "@" (save commander file) key presses

 CMP #f3                ; If key "3" was pressed, jump to EQSHP to show the
 BNE P%+5               ; Equip Ship screen, returning from the subroutine using
 JMP EQSHP              ; a tail call

 CMP #f1                ; If key "1" was pressed, jump to TT219 to show the
 BNE P%+5               ; Buy Cargo screen, returning from the subroutine using
 JMP TT219              ; a tail call

 CMP #'I'               ; If "I" was not pressed, skip to nosave
 BNE nosave

 JSR SVE                ; "@" was pressed, so call SVE to show the disc access
                        ; menu

 BCC P%+5               ; If the C flag was set by SVE, then we loaded a new
 JMP QU5                ; commander file, so jump to QU5 to restart the game
                        ; with the newly loaded commander

 JMP BAY                ; Otherwise the C flag was clear, so jump to BAY to go
                        ; to the docking bay (i.e. show the Status Mode screen)

.nosave

 CMP #f2                ; If key "2" was pressed, jump to TT208 to show the
 BNE LABEL_3            ; Sell Cargo screen, returning from the subroutine using
 JMP TT208              ; a tail call

.INSP

 CMP #f12               ; If key "2" was pressed, jump to chview1
 BEQ chview1

 CMP #f22               ; If key "3" was pressed, jump to chview2
 BEQ chview2

 CMP #f32               ; If key "4" was not pressed, jump to LABEL_3 to keep
 BNE LABEL_3            ; checking for which key was pressed

 LDX #3                 ; Key "4" was pressed, so set the view number in X to
                        ; 3 for the right view

 EQUB $2C               ; Skip the next instruction by turning it into
                        ; $2C $A2 $02, or BIT $02A2, which does nothing apart
                        ; from affect the flags

.chview2

 LDX #2                 ; If we jump to here, key "3" was pressed, so set the
                        ; view number in X to 2 for the left view

 EQUB $2C               ; Skip the next instruction by turning it into
                        ; $2C $A2 $01, or BIT $02A2, which does nothing apart
                        ; from affect the flags

.chview1

 LDX #1                 ; If we jump to here, key "2" was pressed, so set the
                        ; view number in X to 1 for the rear view

 JMP LOOK1              ; Jump to LOOK1 to switch to view X (rear, left or
                        ; right), returning from the subroutine using a tail
                        ; call

.LABEL_3

 LDA KL                 ; ???
 CMP #'H'
 BNE P%+5
 JMP hyp
 CMP #'G'
 BNE P%+5
 JMP hyp

.NWDAV5

 CMP #'D'               ; If "D" was pressed, jump to T95 to print the distance
 BEQ T95                ; to a system (if we are in one of the chart screens)

 CMP #'F'               ; If "F" was not pressed, jump down to HME1, otherwise
 BNE HME1               ; keep going to process searching for systems

 LDA QQ12               ; If QQ12 = 0 (we are not docked), we can't search for
 BEQ t95                ; systems, so return from the subroutine (as t95
                        ; contains an RTS)

 LDA QQ11               ; If the current view is a chart (QQ11 = 64 or 128),
 AND #%11000000         ; keep going, otherwise return from the subroutine (as
 BEQ t95                ; t95 contains an RTS)

 JMP HME2               ; Jump to HME2 to let us search for a system, returning
                        ; from the subroutine using a tail call

.HME1

 STA T1                 ; Store A (the key that's been pressed) in T1

 LDA QQ11               ; If the current view is a chart (QQ11 = 64 or 128),
 AND #%11000000         ; keep going, otherwise jump down to TT107 to skip the
 BEQ TT107              ; following

 LDA QQ22+1             ; If the on-screen hyperspace counter is non-zero,
 BNE TT107              ; then we are already counting down, so jump to TT107
                        ; to skip the following

 LDA T1                 ; Restore the original value of A (the key that's been
                        ; pressed) from T1

 CMP #'O'               ; If "O" was pressed, do the following three jumps,
 BNE ee2                ; otherwise skip to ee2 to continue

 JSR TT103              ; Draw small crosshairs at coordinates (QQ9, QQ10),
                        ; which will erase the crosshairs currently there

 JSR ping               ; Set the target system to the current system (which
                        ; will move the location in (QQ9, QQ10) to the current
                        ; home system

 JMP TT103              ; Draw small crosshairs at coordinates (QQ9, QQ10),
                        ; which will draw the crosshairs at our current home
                        ; system, and return from the subroutine using a tail
                        ; call

.ee2

 JSR TT16               ; Call TT16 to move the crosshairs by the amount in X
                        ; and Y, which were passed to this subroutine as
                        ; arguments

.TT107

 LDA QQ22+1             ; If the on-screen hyperspace counter is zero, return
 BEQ t95                ; from the subroutine (as t95 contains an RTS), as we
                        ; are not currently counting down to a hyperspace jump

 DEC QQ22               ; Decrement the internal hyperspace counter

 BNE t95                ; If the internal hyperspace counter is still non-zero,
                        ; then we are still counting down, so return from the
                        ; subroutine (as t95 contains an RTS)

                        ; If we get here then the internal hyperspace counter
                        ; has just reached zero and it wasn't zero before, so
                        ; we need to reduce the on-screen counter and update
                        ; the screen. We do this by first printing the next
                        ; number in the countdown sequence, and then printing
                        ; the old number, which will erase the old number
                        ; and display the new one because printing uses EOR
                        ; logic

 LDX QQ22+1             ; Set X = the on-screen hyperspace counter - 1
 DEX                    ; (i.e. the next number in the sequence)

 JSR ee3                ; Print the 8-bit number in X at text location (0, 1)

 LDA #5                 ; Reset the internal hyperspace counter to 5
 STA QQ22

 LDX QQ22+1             ; Set X = the on-screen hyperspace counter (i.e. the
                        ; current number in the sequence, which is already
                        ; shown on-screen)

 JSR ee3                ; Print the 8-bit number in X at text location (0, 1),
                        ; i.e. print the hyperspace countdown in the top-left
                        ; corner

 DEC QQ22+1             ; Decrement the on-screen hyperspace countdown

 BNE t95                ; If the countdown is not yet at zero, return from the
                        ; subroutine (as t95 contains an RTS)

 JMP TT18               ; Otherwise the countdown has finished, so jump to TT18
                        ; to do a hyperspace jump, returning from the subroutine
                        ; using a tail call

.t95

 RTS                    ; Return from the subroutine

.T95

                        ; If we get here, "D" was pressed, so we need to show
                        ; the distance to the selected system (if we are in a
                        ; chart view)

 LDA QQ11               ; If the current view is a chart (QQ11 = 64 or 128),
 AND #%11000000         ; keep going, otherwise return from the subroutine (as
 BEQ t95                ; t95 contains an RTS)

 JSR hm                 ; Call hm to move the crosshairs to the target system
                        ; in (QQ9, QQ10), returning with A = 0

;STA QQ17               ; This instruction is commented out in the original
                        ; source

 JSR cpl                ; Print control code 3 (the selected system name)

 LDA #%10000000         ; Set bit 7 of QQ17 to switch to Sentence Case, with the
 STA QQ17               ; next letter in capitals

 LDA #12                ; Print a line feed to move the text cursor down a line
 JSR TT26

 JMP TT146              ; Print the distance to the selected system and return
                        ; from the subroutine using a tail call

; ******************************************************************************
;
;       Name: BAD
;       Type: Subroutine
;   Category: Status
;    Summary: Calculate how bad we have been
;
; ------------------------------------------------------------------------------
;
; Work out how bad we are from the amount of contraband in our hold. The
; formula is:
;
;   (slaves + narcotics) * 2 + firearms
;
; so slaves and narcotics are twice as illegal as firearms. The value in FIST
; (our legal status) is set to at least this value whenever we launch from a
; space station, and a FIST of 50 or more gives us fugitive status, so leaving a
; station carrying 25 tonnes of slaves/narcotics, or 50 tonnes of firearms
; across multiple trips, is enough to make us a fugitive.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   A                   A value that determines how bad we are from the amount
;                       of contraband in our hold
;
; ******************************************************************************

.BAD

 LDA QQ20+3             ; Set A to the number of tonnes of slaves in the hold

 CLC                    ; Clear the C flag so we can do addition without the
                        ; C flag affecting the result

 ADC QQ20+6             ; Add the number of tonnes of narcotics in the hold

 ASL A                  ; Double the result and add the number of tonnes of
 ADC QQ20+10            ; firearms in the hold

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: FAROF
;       Type: Subroutine
;   Category: Maths (Geometry)
;    Summary: Compare x_hi, y_hi and z_hi with 224
;
; ------------------------------------------------------------------------------
;
; Compare x_hi, y_hi and z_hi with 224, and set the C flag if all three <= 224,
; otherwise clear the C flag.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              Set if x_hi <= 224 and y_hi <= 224 and z_hi <= 224
;
;                       Clear otherwise (i.e. if any one of them are bigger than
;                       224)
;
; ******************************************************************************

.FAROF

 LDA #224               ; Set A = 224 and fall through into FAROF2 to do the
                        ; comparison

; ******************************************************************************
;
;       Name: FAROF2
;       Type: Subroutine
;   Category: Maths (Geometry)
;    Summary: Compare x_hi, y_hi and z_hi with A
;
; ------------------------------------------------------------------------------
;
; Compare x_hi, y_hi and z_hi with A, and set the C flag if all three <= A,
; otherwise clear the C flag.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   C flag              Set if x_hi <= A and y_hi <= A and z_hi <= A
;
;                       Clear otherwise (i.e. if any one of them are bigger than
;                       A)
;
; ******************************************************************************

.FAROF2

 CMP INWK+1             ; If A < x_hi, C will be clear so jump to FA1 to
 BCC FA1                ; return from the subroutine with C clear, otherwise
                        ; C will be set so move on to the next one

 CMP INWK+4             ; If A < y_hi, C will be clear so jump to FA1 to
 BCC FA1                ; return from the subroutine with C clear, otherwise
                        ; C will be set so move on to the next one

 CMP INWK+7             ; If A < z_hi, C will be clear, otherwise C will be set

.FA1

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: MAS4
;       Type: Subroutine
;   Category: Maths (Geometry)
;    Summary: Calculate a cap on the maximum distance to a ship
;
; ------------------------------------------------------------------------------
;
; Logical OR the value in A with the high bytes of the ship's position (x_hi,
; y_hi and z_hi).
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   A                   A OR x_hi OR y_hi OR z_hi
;
; ******************************************************************************

.MAS4

 ORA INWK+1             ; OR A with x_hi, y_hi and z_hi
 ORA INWK+4
 ORA INWK+7

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: brkd
;       Type: Variable
;   Category: Utility routines
;    Summary: The brkd counter for error handling
;
; ------------------------------------------------------------------------------
;
; This counter starts at zero, and is decremented whenever the BRKV handler at
; BRBR prints an error message. It is incremented every time an error message
; is printed out as part of the TITLE routine.
;
; ******************************************************************************

.brkd

 EQUB 0

; ******************************************************************************
;
;       Name: BRBR
;       Type: Subroutine
;   Category: Utility routines
;    Summary: The standard BRKV handler for the game
;
; ------------------------------------------------------------------------------
;
; This routine is used to display error messages, before restarting the game.
; When called, it makes a beep and prints the system error message in the block
; pointed to by ($FD $FE), which is where the MOS will put any system errors. It
; then waits for a key press and restarts the game.
;
; ******************************************************************************

.BRBR

 DEC brkd               ; Decrement the brkd counter

 LDX #$FF               ; Set the stack pointer to $01FF, which is the standard
 TXS                    ; location for the 6502 stack, so this instruction
                        ; effectively resets the stack

 JSR backtonormal       ; Disable the keyboard and set the SVN flag to 0

 TAY                    ; The call to backtonormal sets A to 0, so this sets Y
                        ; to 0, which we use as a loop counter below

 LDA #7                 ; Set A = 7 to generate a beep before we print the error
                        ; message

.BRBRLOOP

 JSR CHPR               ; Print the character in A, which contains a line feed
                        ; on the first loop iteration, and then any non-zero
                        ; characters we fetch from the error message

 INY                    ; Increment the loop counter

 LDA ($FD),Y            ; Fetch the Y-th byte of the block pointed to by
                        ; ($FD $FE), so that's the Y-th character of the message
                        ; pointed to by the MOS error message pointer

 BNE BRBRLOOP           ; If the fetched character is non-zero, loop back to the
                        ; JSR OSWRCH above to print the it, and keep looping
                        ; until we fetch a zero (which marks the end of the
                        ; message)

 JMP BR1                ; Jump to BR1 to restart the game

; ******************************************************************************
;
;       Name: DEATH
;       Type: Subroutine
;   Category: Start and end
;    Summary: Display the death screen
;
; ------------------------------------------------------------------------------
;
; We have been killed, so display the chaos of our destruction above a "GAME
; OVER" sign, and clean up the mess ready for the next attempt.
;
; ******************************************************************************

.DEATH

 LDY #210               ; Call the SOEXPL routine with Y = 210 to make the sound
 JSR SOEXPL             ; of us dying

 JSR RES2               ; Reset a number of flight variables and workspaces

 ASL DELTA              ; Divide our speed in DELTA by 4
 ASL DELTA

;LDX #24                ; These instructions are commented out in the original
;JSR DET1               ; source (they would hide the dashboard)

 LDA #0                 ; Clear the top part of the screen, draw a white border,
 JSR TT66               ; and set the current view type in QQ11 to 0 ???

 JSR nWq                ; Create a cloud of stardust containing the correct
                        ; number of dust particles (i.e. NOSTM of them)

 LDA #12                ; Move the text cursor to column 12 on row 12
 STA XC
 STA YC

 LDA #146               ; Print recursive token 146 ("{all caps}GAME OVER")
 JSR ex

.D1

 JSR Ze                 ; Call Ze to initialise INWK to a potentially hostile
                        ; ship, and set A and X to random values

 LSR A                  ; Set A = A / 4, so A is now between 0 and 63, and
 LSR A                  ; store in byte #0 (x_lo)
 STA INWK

 LDY #0                 ; Set the following to 0: x_hi, y_hi, z_hi and the AI
 STY INWK+1             ; flag (no AI or E.C.M. and not hostile)
 STY INWK+4
 STY INWK+7
 STY INWK+32

 DEY                    ; Set Y = 255

 STY MCNT               ; Reset the main loop counter to 255, so all timer-based
                        ; calls will be stopped

 EOR #%00101010         ; Flip bits 1, 3 and 5 in A (x_lo) to get another number
 STA INWK+3             ; between 48 and 63, and store in byte #3 (y_lo)

 ORA #%01010000         ; Set bits 4 and 6 of A to bump it up to between 112 and
 STA INWK+6             ; 127, and store in byte #6 (z_lo)

 TXA                    ; Set A to the random number in X and keep bits 0-3 and
 AND #%10001111         ; the sign in bit 7 to get a number between -15 and +15,
 STA INWK+29            ; and store in byte #29 (roll counter) to give our ship
                        ; a gentle roll with damping

 LDY #64                ; Set the laser count to 64 to act as a counter in the
 STY LASCT              ; D2 loop below, so this setting determines how long the
                        ; death animation lasts (it's 64 * 2 iterations of the
                        ; main flight loop)

 SEC                    ; Set the C flag

 ROR A                  ; This sets A to a number between 0 and +7, which we
 AND #%10000111         ; store in byte #30 (the pitch counter) to give our ship
 STA INWK+30            ; a very gentle downwards pitch with damping

 LDX #OIL               ; Set X to #OIL, the ship type for a cargo canister

 LDA XX21-1+2*PLT       ; Fetch the byte from location XX21 - 1 + 2 * PLT, which
                        ; equates to XX21 + 7 (the high byte of the address of
                        ; SHIP_PLATE), which seems a bit odd. It might make more
                        ; sense to do LDA (XX21-2+2*PLT) as this would fetch the
                        ; first byte of the alloy plate's blueprint (which
                        ; determines what happens when alloys are destroyed),
                        ; but there aren't any brackets, so instead this always
                        ; returns $D0, which is never zero, so the following
                        ; BEQ is never true. (If the brackets were there, then
                        ; we could stop plates from spawning on death by setting
                        ; byte #0 of the blueprint to 0... but then scooping
                        ; plates wouldn't give us alloys, so who knows what this
                        ; is all about?)

 BEQ D3                 ; If A = 0, jump to D3 to skip the following instruction

 BCC D3                 ; If the C flag is clear, which will be random following
                        ; the above call to Ze, jump to D3 to skip the following
                        ; instruction

 DEX                    ; Decrement X, which sets it to #PLT, the ship type for
                        ; an alloy plate

.D3

 JSR fq1                ; Call fq1 with X set to #OIL or #PLT, which adds a new
                        ; cargo canister or alloy plate to our local bubble of
                        ; universe and points it away from us with double DELTA
                        ; speed (i.e. 6, as DELTA was set to 3 by the call to
                        ; RES2 above). INF is set to point to the new arrival's
                        ; ship data block in K%

 JSR DORND              ; Set A and X to random numbers and extract bit 7 from A
 AND #%10000000

 LDY #31                ; Store this in byte #31 of the ship's data block, so it
 STA (INF),Y            ; has a 50% chance of marking our new arrival as being
                        ; killed (so it will explode)

 LDA FRIN+4             ; The call we made to RES2 before we entered the loop at
 BEQ D1                 ; D1 will have reset all the ship slots at FRIN, so this
                        ; checks to see if the fifth slot is empty, and if it
                        ; is we loop back to D1 to add another canister, until
                        ; we have added five of them

;JSR U%                 ; This instruction is commented out in the original
                        ; source

 LDA #0                 ; Set our speed in DELTA to 0, as we aren't going
 STA DELTA              ; anywhere any more

 JSR M%                 ; Call the M% routine to do the main flight loop once,
                        ; which will display our exploding canister scene and
                        ; move everything about, as well as decrementing the
                        ; value in LASCT

;JSR NOSPRITES          ; This instruction is commented out in the original
                        ; source

.D2

 JSR M%                 ; Call the M% routine to do the main flight loop once,
                        ; which will display our exploding canister scene and
                        ; move everything about, as well as decrementing the
                        ; value in LASCT

 DEC LASCT              ; Decrement the counter in LASCT, which we set above,
                        ; so for each loop around D2, we decrement LASCT by 5
                        ; (the main loop decrements it by 4, and this one makes
                        ; it 5)

 BNE D2                 ; Loop back to call the main flight loop again, until we
                        ; have called it 127 times

;LDX #31                ; These instructions are commented out in the original
;JSR DET1               ; source (they would show the dashboard)

 JMP DEATH2             ; Jump to DEATH2 to reset and restart the game

; ******************************************************************************
;
;       Name: spasto
;       Type: Variable
;   Category: Universe
;    Summary: Contains the address of the Coriolis space station's ship
;             blueprint
;
; ******************************************************************************

.spasto

IF _IB_DISK

 EQUW $A49E

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 EQUW $8888

ENDIF

; ******************************************************************************
;
;       Name: BEGIN
;       Type: Subroutine
;   Category: Loader
;    Summary: Initialise the configuration variables and start the game
;
; ******************************************************************************

.BEGIN

 LDX #(DISK-COMC)       ; We start by zeroing all the configuration variables
                        ; between COMC and DISK, to set them to their default
                        ; values, so set a counter in X for DISK - COMC bytes

 LDA #0                 ; Set A = 0 so we can zero the variables

.BEL1

 STA COMC,X             ; Zero the X-th configuration variable

 DEX                    ; Decrement the loop counter

 BPL BEL1               ; Loop back to BEL1 to zero the next byte, until we have
                        ; zeroed them all

 LDA XX21+SST*2-2       ; Set spasto(1 0) to the Coriolis space station entry
 STA spasto             ; from the ship blueprint lookup table at XX21 (so
 LDA XX21+SST*2-1       ; spasto(1 0) points to the Coriolis blueprint)
 STA spasto+1

 JSR JAMESON            ; Call JAMESON to set the last saved commander to the
                        ; default "JAMESON" commander

                        ; Fall through into TT170 to start the game

; ******************************************************************************
;
;       Name: TT170
;       Type: Subroutine
;   Category: Start and end
;    Summary: Main entry point for the Elite game code
;  Deep dive: Program flow of the main game loop
;
; ------------------------------------------------------------------------------
;
; This is the main entry point for the main game code.
;
; ******************************************************************************

.TT170

 LDX #$FF               ; Set the stack pointer to $01FF, which is the standard
 TXS                    ; location for the 6502 stack, so this instruction
                        ; effectively resets the stack

 JSR RESET              ; Call RESET to initialise most of the game variables

                        ; Fall through into DEATH2 to start the game

; ******************************************************************************
;
;       Name: DEATH2
;       Type: Subroutine
;   Category: Start and end
;    Summary: Reset most of the game and restart from the title screen
;
; ------------------------------------------------------------------------------
;
; This routine is called following death, and when the game is quit by pressing
; ESCAPE when paused.
;
; ******************************************************************************

.DEATH2

 LDX #$FF               ; Set the stack pointer to $01FF, which is the standard
 TXS                    ; location for the 6502 stack, so this instruction
                        ; effectively resets the stack

 JSR RES2               ; Reset a number of flight variables and workspaces
                        ; and fall through into the entry code for the game
                        ; to restart from the title screen

; ******************************************************************************
;
;       Name: BR1 (Part 1 of 2)
;       Type: Subroutine
;   Category: Start and end
;    Summary: Show the "Load New Commander (Y/N)?" screen and start the game
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   QU5                 Restart the game using the last saved commander without
;                       asking whether to load a new commander file
;
; ******************************************************************************

.BR1

 JSR ZEKTRAN            ; Call ZEKTRAN to clear the key logger

 LDA #3                 ; Set XC = 3 (set text cursor to column 3)
 STA XC

;JSR startat            ; This instruction is commented out in the original
                        ; source

 LDX #CYL               ; Call TITLE to show a rotating Cobra Mk III (#CYL) and
 LDA #6                 ; token 6 ("LOAD NEW {single cap}COMMANDER {all caps}
 LDY #250               ; (Y/N)?{sentence case}{cr}{cr}"), with the ship at a
 JSR TITLE              ; distance of 250, returning with the internal number
                        ; of the key pressed in A

 CPX #'Y'               ; Did we press "Y"? If not, jump to QU5, otherwise
 BNE QU5                ; continue on to load a new commander

;JSR stopat             ; This instruction is commented out in the original
                        ; source

 JSR DFAULT             ; Call DFAULT to reset the current commander data block
                        ; to the last saved commander

 JSR SVE                ; Call SVE to load a new commander into the last saved
                        ; commander data block

;JSR startat            ; This instruction is commented out in the original
                        ; source

.QU5

 JSR DFAULT             ; Call DFAULT to reset the current commander data block
                        ; to the last saved commander

; ******************************************************************************
;
;       Name: BR1 (Part 2 of 2)
;       Type: Subroutine
;   Category: Start and end
;    Summary: Show the "Press Fire or Space, Commander" screen and start the
;             game
;
; ------------------------------------------------------------------------------
;
; BRKV is set to point to BR1 by the loading process.
;
; ******************************************************************************

 JSR msblob             ; Reset the dashboard's missile indicators so none of
                        ; them are targeted

 LDA #7                 ; Call TITLE to show a rotating Sidewinder (#SH3) and
 LDX #SH3               ; token 7 ("PRESS SPACE OR FIRE,{single cap}COMMANDER.
 LDY #75                ; {cr}{cr}"), with the ship at a distance of 75,
 JSR TITLE              ; returning with the internal number of the key pressed
                        ; in A

;JSR stopat             ; This instruction is commented out in the original
                        ; source

 JSR ping               ; Set the target system coordinates (QQ9, QQ10) to the
                        ; current system coordinates (QQ0, QQ1) we just loaded

 JSR TT111              ; Select the system closest to galactic coordinates
                        ; (QQ9, QQ10)

 JSR jmp                ; Set the current system to the selected system

 LDX #5                 ; We now want to copy the seeds for the selected system
                        ; in QQ15 into QQ2, where we store the seeds for the
                        ; current system, so set up a counter in X for copying
                        ; 6 bytes (for three 16-bit seeds)

                        ; The label below is called likeTT112 because this code
                        ; is almost identical to the TT112 loop in the hyp1
                        ; routine

.likeTT112

 LDA QQ15,X             ; Copy the X-th byte in QQ15 to the X-th byte in QQ2
 STA QQ2,X

 DEX                    ; Decrement the counter

 BPL likeTT112          ; Loop back to likeTT112 if we still have more bytes to
                        ; copy

 INX                    ; Set X = 0 (as we ended the above loop with X = $FF)

 STX EV                 ; Set EV, the extra vessels spawning counter, to 0, as
                        ; we are entering a new system with no extra vessels
                        ; spawned

 LDA QQ3                ; Set the current system's economy in QQ28 to the
 STA QQ28               ; selected system's economy from QQ3

 LDA QQ5                ; Set the current system's tech level in tek to the
 STA tek                ; selected system's economy from QQ5

 LDA QQ4                ; Set the current system's government in gov to the
 STA gov                ; selected system's government from QQ4

                        ; Fall through into the docking bay routine below

; ******************************************************************************
;
;       Name: BAY
;       Type: Subroutine
;   Category: Status
;    Summary: Go to the docking bay (i.e. show the Status Mode screen)
;
; ------------------------------------------------------------------------------
;
; We end up here after the start-up process (load commander etc.), as well as
; after a successful save, an escape pod launch, a successful docking, the end
; of a cargo sell, and various errors (such as not having enough cash, entering
; too many items when buying, trying to fit an item to your ship when you
; already have it, running out of cargo space, and so on).
;
; ******************************************************************************

.BAY

 LDA #$FF               ; Set QQ12 = $FF (the docked flag) to indicate that we
 STA QQ12               ; are docked

 LDA #f8                ; Jump into the main loop at FRCE, setting the key
 JMP FRCE               ; that's "pressed" to the Status Mode key

; ******************************************************************************
;
;       Name: DFAULT
;       Type: Subroutine
;   Category: Start and end
;    Summary: Reset the current commander data block to the last saved commander
;
; ******************************************************************************

.DFAULT

 LDX #NT%+8             ; The size of the last saved commander data block is NT%
                        ; bytes, and it is preceded by the 8 bytes of the
                        ; commander name (seven characters plus a carriage
                        ; return). The commander data block at NAME is followed
                        ; by the commander data block, so we need to copy the
                        ; name and data from the "last saved" buffer at NA% to
                        ; the current commander workspace at NAME. So we set up
                        ; a counter in X for the NT% + 8 bytes that we want to
                        ; copy

.QUL1

 LDA NA%-1,X            ; Copy the X-th byte of NA%-1 to the X-th byte of
 STA NAME-1,X           ; NAME-1 (the -1 is because X is counting down from
                        ; NT% + 8 to 1)

 DEX                    ; Decrement the loop counter

 BNE QUL1               ; Loop back for the next byte of the commander data
                        ; block

 STX QQ11               ; X is 0 by the end of the above loop, so this sets QQ11
                        ; to 0, which means we will be showing a view without a
                        ; boxed title at the top (i.e. we're going to use the
                        ; screen layout of a space view in the following)

                        ; If the commander check below fails, we keep jumping
                        ; back to here to crash the game with an infinite loop

.doitagain

 JSR CHECK              ; Call the CHECK subroutine to calculate the checksum
                        ; for the current commander block at NA%+8 and put it
                        ; in A

 CMP CHK                ; Test the calculated checksum against CHK

IF _REMOVE_CHECKSUMS

 NOP                    ; If we have disabled checksums, then ignore the result
 NOP                    ; of the comparison and fall through into the next part

ELSE

 BNE doitagain          ; If the calculated checksum does not match CHK, then
                        ; loop back to repeat the check - in other words, we
                        ; enter an infinite loop here, as the checksum routine
                        ; will keep returning the same incorrect value

ENDIF

                        ; The checksum CHK is correct, so now we check whether
                        ; CHK2 = CHK EOR A9, and if this check fails, bit 7 of
                        ; the competition flags at COK gets set, to indicate
                        ; to Acornsoft via the competition code that there has
                        ; been some hacking going on with this competition entry

 EOR #$A9               ; X = checksum EOR $A9
 TAX

 LDA COK                ; Set A to the competition flags in COK

 CPX CHK2               ; If X = CHK2, then skip the next instruction
 BEQ tZ

 ORA #%10000000         ; Set bit 7 of A to indicate this commander file has
                        ; been tampered with

.tZ

 ORA #%00001000         ; Set bit 3 of A to denote that this is the Apple II
                        ; version (which is the same flag as the BBC Master
                        ; version)

 STA COK                ; Store the updated competition flags in COK

 JSR CHECK2             ; ???
 CMP CHK3
 BNE doitagain

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TITLE
;       Type: Subroutine
;   Category: Start and end
;    Summary: Display a title screen with a rotating ship and prompt
;
; ------------------------------------------------------------------------------
;
; Display the title screen, with a rotating ship and a text token at the bottom
; of the screen.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The number of the extended token to show below the
;                       rotating ship (see variable TKN1 for details of
;                       recursive tokens)
;
;   X                   The type of the ship to show (see variable XX21 for a
;                       list of ship types)
;
;   Y                   The distance to show the ship rotating, once it has
;                       finished moving towards us
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   X                   If a key is being pressed, X contains the ASCII code
;                       of the key pressed
;
; ******************************************************************************

.TITLE

 STY distaway           ; Store the ship distance in distaway

 PHA                    ; Store the token number on the stack for later

 STX TYPE               ; Store the ship type in location TYPE

 LDA #$FF               ; ???
 STA MULIE

 JSR RESET              ; Reset our ship so we can use it for the rotating
                        ; title ship

 LDA #0                 ; ???
 STA MULIE

 JSR ZEKTRAN            ; Call ZEKTRAN to clear the key logger

;LDA #32                ; These instructions are commented out in the original
;JSR DOVDU19            ; source

 LDA #13                ; Clear the top part of the screen, draw a white border,
 JSR TT66               ; and set the current view type in QQ11 to 13 (rotating
                        ; ship view)

;LDA #RED               ; These instructions are commented out in the original
;JSR DOCOL              ; source (they are left over from the 6502 Second
                        ; Processor version of Elite and would change the colour
                        ; to red)

 LDA #0                 ; Set QQ11 to 0, so from here on we are using a space
 STA QQ11               ; view

 LDA #96                ; Set nosev_z hi = 96 (96 is the value of unity in the
 STA INWK+14            ; rotation vector)

 LDA #96                ; Set A = 96 as the distance that the ship starts at

 STA INWK+7             ; Set z_hi, the high byte of the ship's z-coordinate,
                        ; to 96, which is the distance at which the rotating
                        ; ship starts out before coming towards us

 LDX #127               ; Set roll counter = 127, so don't dampen the roll and
 STX INWK+29            ; make the roll direction clockwise

 STX INWK+30            ; Set pitch counter = 127, so don't dampen the pitch and
                        ; set the pitch direction to dive

 INX                    ; Set QQ17 to 128 (so bit 7 is set) to switch to
 STX QQ17               ; Sentence Case, with the next letter printing in upper
                        ; case

 LDA TYPE               ; Set up a new ship, using the ship type in TYPE
 JSR NWSHP

 LDA #6                 ; Move the text cursor to column 6
 STA XC

 LDA #30                ; Print recursive token 144 ("---- E L I T E ----")
 JSR plf                ; followed by a newline

 LDA #10                ; Print a line feed to move the text cursor down a line
 JSR TT26

 LDA #6                 ; Move the text cursor to column 6 again
 STA XC

 LDA PATG               ; If PATG = 0, skip the following two lines, which
 BEQ awe                ; print the author credits (PATG can be toggled by
                        ; pausing the game and pressing "X")

 LDA #13                ; Print extended token 13 ("BY D.BRABEN & I.BELL")
 JSR DETOK

.awe

 LDA brkd               ; If brkd = 0, jump to BRBR2 to skip the following, as
 BEQ BRBR2              ; we do not have a system error message to display

 INC brkd               ; Increment the brkd counter

 LDA #7                 ; Move the text cursor to column 7
 STA XC

 LDA #9                 ; Move the text cursor to row 9
 STA YC

                        ; The following loop prints out the null-terminated
                        ; message pointed to by ($FD $FE), which is the OS
                        ; error message pointer - so this prints the error
                        ; message on the next line

 LDY #0                 ; Set Y = 0 to act as a character counter

 JSR CHPR               ; Print the character in A (which contains a line feed
                        ; on the first loop iteration), and then any non-zero
                        ; characters we fetch from the error message

 INY                    ; Increment the loop counter

 LDA ($FD),Y            ; Fetch the Y-th byte of the block pointed to by
                        ; ($FD $FE), so that's the Y-th character of the message
                        ; pointed to by the OS error message pointer

 BNE P%-6               ; If the fetched character is non-zero, loop back to the
                        ; JSR CHPR above to print it, and keep looping until
                        ; we fetch a zero (which marks the end of the message)

.BRBR2

 LDY #0                 ; Set DELTA = 0 (i.e. ship speed = 0)
 STY DELTA

 STY JSTK               ; Set JSTK = 0 (i.e. keyboard, not joystick)

 LDA #14                ; Move the text cursor to row 14
 STA YC

 LDA #1                 ; Move the text cursor to column 1
 STA XC

 PLA                    ; Restore the recursive token number we stored on the
                        ; stack at the start of this subroutine

 JSR DETOK              ; Print the extended token in A

 LDA #3                 ; Move the text cursor to column 3
 STA XC

 LDA #12                ; Print extended token 12 ("{single cap}C) {single
 JSR DETOK              ; cap}D.{single cap}BRABEN & {single cap}I.{single
                        ; cap}BELL 1985")

 LDA #12                ; Set CNT2 = 12 as the outer loop counter for the loop
 STA CNT2               ; starting at TLL2

 LDA #5                 ; Set the main loop counter in MCNT to 5, to act as the
 STA MCNT               ; inner loop counter for the loop starting at TLL2

.TLL2

 LDA INWK+7             ; If z_hi (the ship's distance) is 1, jump to TL1 to
 CMP #1                 ; skip the following decrement
 BEQ TL1

 DEC INWK+7             ; Decrement the ship's distance, to bring the ship
                        ; a bit closer to us

.TL1

 JSR MVEIT              ; Move the ship in space according to the orientation
                        ; vectors and the new value in z_hi

 LDX distaway           ; Set z_lo to the distance value we passed to the
 STX INWK+6             ; routine, so this is the closest the ship gets to us

 LDA MCNT               ; This has no effect - it is presumably left over from
 AND #3                 ; the other versions of Elite which only scan the
                        ; keyboard once every four loops, but that isn't the
                        ; case here as the result is not acted upon

 LDA #0                 ; Set x_lo = 0, so the ship remains in the screen centre
 STA INWK

 STA INWK+3             ; Set y_lo = 0, so the ship remains in the screen centre

 JSR LL9                ; Call LL9 to display the ship

 JSR RDKEY              ; Scan the keyboard for a key press and return the
                        ; key in X (or 0 for no key press)

 DEC MCNT               ; Decrement the main loop counter

 LDA $C061              ; ???
 ORA $C062

IF _IB_DISK

 AND $4562

ENDIF

 BMI TL3

 BCC TLL2               ; ???

 RTS                    ; Return from the subroutine

.TL3

 DEC JSTK               ; Joystick fire button was pressed, so set JSTK to $FF
                        ; (it was set to 0 above), to disable keyboard and
                        ; enable joysticks

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: CHECK
;       Type: Subroutine
;   Category: Save and load
;    Summary: Calculate the checksum for the last saved commander data block
;  Deep dive: Commander save files
;
; ------------------------------------------------------------------------------
;
; The checksum for the last saved commander data block is saved as part of the
; commander file, in two places (CHK AND CHK2), to protect against file
; tampering. This routine calculates the checksum and returns it in A.
;
; This algorithm is also implemented in elite-checksum.py.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   A                   The checksum for the last saved commander data block
;
; ******************************************************************************

.CHECK

 LDX #NT%-3             ; Set X to the size of the commander data block, less
                        ; 3 (as there are two checksum bytes and the save count)

 CLC                    ; Clear the C flag so we can do addition without the
                        ; C flag affecting the result

 TXA                    ; Seed the checksum calculation by setting A to the
                        ; size of the commander data block, less 2

                        ; We now loop through the commander data block,
                        ; starting at the end and looping down to the start
                        ; (so at the start of this loop, the X-th byte is the
                        ; last byte of the commander data block, i.e. the save
                        ; count)

.QUL2

 ADC NA%+7,X            ; Add the X-1-th byte of the data block to A, plus the
                        ; C flag

 EOR NA%+8,X            ; EOR A with the X-th byte of the data block

 DEX                    ; Decrement the loop counter

 BNE QUL2               ; Loop back for the next byte in the calculation, until
                        ; we have added byte #0 and EOR'd with byte #1 of the
                        ; data block

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: CHECK2
;       Type: Subroutine
;   Category: Save and load
;    Summary: Calculate the second checksum for the last saved commander data
;             block (Commodore 64 and Apple II versions onlt)
;
; ******************************************************************************

.CHECK2

 LDX #NT%-3             ; Set X to the size of the commander data block, less
                        ; 3 (as there are two checksum bytes and the save count)

 CLC                    ; Clear the C flag so we can do addition without the
                        ; C flag affecting the result

 TXA                    ; Seed the checksum calculation by setting A to the
                        ; size of the commander data block, less 2

                        ; We now loop through the commander data block,
                        ; starting at the end and looping down to the start
                        ; (so at the start of this loop, the X-th byte is the
                        ; last byte of the commander data block, i.e. the save
                        ; count)

.QU2L2

 STX T                  ; Set A = A EOR X
 EOR T                  ;
 ROR A                  ; This additional step is the only difference between
                        ; the original checksum from BBC Micro Elite (in CHECK),
                        ; and this additional checksum in the Commodore 64 and
                        ; Apple II versions

 ADC NA%+7,X            ; Add the X-1-th byte of the data block to A, plus the
                        ; C flag

 EOR NA%+8,X            ; EOR A with the X-th byte of the data block

 DEX                    ; Decrement the loop counter

 BNE QU2L2              ; Loop back for the next byte in the calculation, until
                        ; we have added byte #0 and EOR'd with byte #1 of the
                        ; data block

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: JAMESON
;       Type: Subroutine
;   Category: Save and load
;    Summary: Restore the default JAMESON commander
;
; ******************************************************************************

.JAMESON

 LDY #(NAEND%-NA2%)     ; We are going to copy the default commander at NA2%
                        ; over the top of the last saved commander at NA%, so
                        ; set a counter to copy all the bytes between NA2% and
                        ; NAEND%

.JAMEL1

 LDA NA2%,Y             ; Copy the Y-th byte of NA2% to the Y-th byte of NA%
 STA NA%,Y

 DEY                    ; Decrement the loop counter

 BPL JAMEL1             ; Loop back until we have copied the whole commander

 LDY #7                 ; Set oldlong to 7, the length of the commander name
 STY oldlong            ; "JAMESON"

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: COPYNAME
;       Type: Subroutine
;   Category: Save and load
;    Summary: Copy  the last saved commander's name from ??? to ???
;
; ******************************************************************************

.COPYNAME

 LDX #0                 ; ???

.COPYL1

 LDA INWK+5,X
 CMP #13
 BEQ COPYL2
 STA comnam,X
 INX
 CPX #7
 BCC COPYL1

.COPYL2

 LDA #$20

.COPYL3

 STA comnam,X
 INX
 CPX #30
 BCC COPYL3
 RTS

; ******************************************************************************
;
;       Name: TRNME
;       Type: Subroutine
;   Category: Save and load
;    Summary: Copy the last saved commander's name from INWK to NA%
;
; ******************************************************************************

.TRNME

 LDX #7                 ; The commander's name can contain a maximum of 7
                        ; characters, and is terminated by a carriage return,
                        ; so set up a counter in X to copy 8 characters

 LDA thislong           ; Copy the length of the commander's name from thislong
 STA oldlong            ; to oldlong (though this is never used, so this
                        ; doesn't have any effect)

.GTL1

 LDA INWK+5,X           ; Copy the X-th byte of INWK+5 to the X-th byte of NA%
 STA NA%,X

 DEX                    ; Decrement the loop counter

 BPL GTL1               ; Loop back until we have copied all 8 bytes

                        ; Fall through into TR1 to copy the name back from NA%
                        ; to INWK. This isn't necessary as the name is already
                        ; there, but it does save one byte, as we don't need an
                        ; RTS here

; ******************************************************************************
;
;       Name: TR1
;       Type: Subroutine
;   Category: Save and load
;    Summary: Copy the last saved commander's name from NA% to INWK
;
; ******************************************************************************

.TR1

 LDX #7                 ; The commander's name can contain a maximum of 7
                        ; characters, and is terminated by a carriage return,
                        ; so set up a counter in X to copy 8 characters

.GTL2

 LDA NA%,X              ; Copy the X-th byte of NA% to the X-th byte of INWK+5
 STA INWK+5,X

 DEX                    ; Decrement the loop counter

 BPL GTL2               ; Loop back until we have copied all 8 bytes

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: GTNMEW
;       Type: Subroutine
;   Category: Save and load
;    Summary: Fetch the name of a commander file to save or load
;
; ------------------------------------------------------------------------------
;
; Get the commander's name for loading or saving a commander file. The name is
; stored in the INWK workspace and is terminated by a return character (13).
;
; If ESCAPE is pressed or a blank name is entered, then the name stored is set
; to the name from the last saved commander block.
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   INWK                The full filename, including drive and directory, in
;                       the form ":0.E.JAMESON", for example, terminated by a
;                       return character (13)
;
; ******************************************************************************

.GTNMEW

;LDY #8                 ; These instructions are commented out in the original
;JSR DELAY              ; source

.GTNME

 LDX #4                 ; First we want to copy the drive and directory part of
                        ; the commander file from NA%-5, so set a counter in X
                        ; for 5 bytes, as the string is of the form ":0.E."

.GTL3

 LDA NA%-5,X            ; Copy the X-th byte from NA%-5 to INWK
 STA INWK,X

 DEX                    ; Decrement the loop counter

 BPL GTL3               ; Loop back until the whole drive and directory string
                        ; has been copied to INWK to INWK+4

 LDA #7                 ; The call to MT26 below uses the OSWORD block at RLINE
 STA RLINE+2            ; to fetch the line, and RLINE+2 defines the maximum
                        ; line length allowed, so this changes the maximum
                        ; length to 7 (as that's the longest commander name
                        ; allowed)

 LDA #8                 ; Print extended token 8 ("{single cap}COMMANDER'S
 JSR DETOK              ; NAME? ")

 JSR MT26               ; Call MT26 to fetch a line of text from the keyboard
                        ; to INWK+5, with the text length in Y, so INWK now
                        ; contains the full pathname of the file, as in
                        ; ":0.E.JAMESON", for example

 LDA #9                 ; Reset the maximum length in RLINE+2 to the original
 STA RLINE+2            ; value of 9

 TYA                    ; The OSWORD call returns the length of the commander's
                        ; name in Y, so transfer this to A

 BEQ TR1                ; If A = 0, no name was entered, so jump to TR1 to copy
                        ; the last saved commander's name from NA% to INWK
                        ; and return from the subroutine there

 STY thislong           ; Store the length of the length of the commander's that
                        ; was entered in thislong

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: MT26
;       Type: Subroutine
;   Category: Text
;    Summary: Fetch a line of text from the keyboard
;  Deep dive: Extended text tokens
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   Y                   The size of the entered text, or 0 if none was entered
;
;   INWK+5              The entered text, terminated by a carriage return
;
;   C flag              Set if ESCAPE was pressed
;
; ******************************************************************************

.MT26

;LDA #MAG2              ; These instructions are commented out in the original
;STA COL                ; source

 LDY #8                 ; Wait for 8/50 of a second (0.16 seconds)
 JSR DELAY

 JSR FLKB               ; Call FLKB to flush the keyboard buffer

 LDY #0                 ; Set Y = 0 to hold the length of the text entered

.OSW0L

 JSR TT217              ; Scan the keyboard until a key is pressed, and return
                        ; the key's ASCII code in A (and X)

 CMP #13                ; If RETURN was pressed, jump to OSW03
 BEQ OSW03

 CMP #27                ; If ESCAPE was pressed, jump to OSW04
 BEQ OSW04

 CMP #127               ; If DELETE was pressed, jump to OSW05
 BEQ OSW05

 CPY RLINE+2            ; If Y >= RLINE+2 (the maximum line length from the
 BCS OSW01              ; OSWORD configuration block at RLINE), then jump to
                        ; OSW01 to give an error beep as we have reached the
                        ; character limit

 CMP RLINE+3            ; If the key pressed is less than the character in
 BCC OSW01              ; RLINE+3 (the lowest allowed character from the OSWORD
                        ; configuration block at RLINE), then jump to OSW01
                        ; to give an error beep as the key pressed is out of
                        ; range

 CMP RLINE+4            ; If the key pressed is greater than or equal to the
 BCS OSW01              ; character in RLINE+4 (the highest allowed character
                        ; from the OSWORD configuration block at RLINE), then
                        ; jump to OSW01 to give an error beep as the key
                        ; pressed is out of range

 STA INWK+5,Y           ; Store the key's ASCII code in the Y-th byte of INWK+5

 INY                    ; Increment Y to point to the next free byte in INWK+5

 EQUB $2C               ; Skip the next instruction by turning it into
                        ; $2C $A9 $07, or BIT $07A9, which does nothing apart
                        ; from affect the flags

.OSW01

 LDA #7                 ; Set A to the beep character, so the next instruction
                        ; makes a system beep

.OSW06

 JSR CHPR               ; Print the character in A (and clear the C flag)

 BCC OSW0L              ; Loop back to OSW0L to fetch another key press (this
                        ; BCC is effectively a JMP as CHPR clears the C flag)

.OSW03

 STA INWK+5,Y           ; Store the return character in the Y-th byte of INWK+5

;LDA #$10               ; These instructions are commented out in the original
;STA COL2               ; source

 LDA #12                ; Print a newline and return from the subroutine using a
 JMP CHPR               ; tail call

.OSW04

;LDA #$10               ; These instructions are commented out in the original
;STA COL2               ; source

 SEC                    ; Set the C flag as ESCAPE was pressed

 RTS                    ; Return from the subroutine

.OSW05

 TYA                    ; If the length of the line so far in Y is 0, then we
 BEQ OSW01              ; just pressed DELETE on an empty line, so jump to
                        ; OSW01 give an error beep

 DEY                    ; Otherwise we want to delete a character, so decrement
                        ; the length of the line so far in Y

 LDA #127               ; Set A = 127 and jump back to OSW06 to print the
 BNE OSW06              ; character in A (i.e. the DELETE character) and listen
                        ; for the next key press

; ******************************************************************************
;
;       Name: RLINE
;       Type: Variable
;   Category: Text
;    Summary: The OSWORD configuration block used to fetch a line of text from
;             the keyboard
;
; ------------------------------------------------------------------------------
;
; This block is left over from the BBC Micro version of Elite and is not used in
; this version.
;
; ******************************************************************************

.RLINE

 EQUW INWK+5            ; The address to store the input, so the text entered
                        ; will be stored in INWK+5 as it is typed

 EQUB 9                 ; Maximum line length = 9, as that's the maximum size
                        ; for a commander's name including a directory name

 EQUB '!'               ; Allow ASCII characters from "!" through to "{" in
 EQUB '{'               ; the input

; ******************************************************************************
;
;       Name: FILEPR
;       Type: Subroutine
;   Category: Save and load
;    Summary: Display the currently selected media (disc or tape)
;  Deep dive: Extended text tokens
;
; ******************************************************************************

.FILEPR

 LDA #3                 ; Print extended token 3 + DISK, i.e. token 3 or 2 (as
 CLC                    ; DISK can be 0 or $FF). Token 2 is "disk" and token 3
 ADC DISK               ; is "tape", so this displays the currently selected
 JMP DETOK              ; media

; ******************************************************************************
;
;       Name: OTHERFILEPR
;       Type: Subroutine
;   Category: Save and load
;    Summary: Display the non-selected media (disc or tape)
;  Deep dive: Extended text tokens
;
; ******************************************************************************

.OTHERFILEPR

 LDA #2                 ; Print extended token 2 - DISK, i.e. token 2 or 3 (as
 SEC                    ; DISK can be 0 or $FF). Token 2 is "disk" and token 3
 SBC DISK               ; is "tape", so this displays the other, non-selected
 JMP DETOK              ; media

; ******************************************************************************
;
;       Name: ZERO
;       Type: Subroutine
;   Category: Utility routines
;    Summary: Reset the local bubble of universe and ship status
;
; ------------------------------------------------------------------------------
;
; This resets the following workspaces to zero:
;
;   * UP workspace variables from FRIN to de, which include the ship slots for
;     the local bubble of universe, and various flight and ship status variables
;
; ******************************************************************************

.ZERO

 LDX #(de-FRIN)         ; We're going to zero the UP workspace variables from
                        ; FRIN to de, so set a counter in X for the correct
                        ; number of bytes

 LDA #0                 ; Set A = 0 so we can zero the variables

.ZEL2

 STA FRIN,X             ; Zero the X-th byte of FRIN to de

 DEX                    ; Decrement the loop counter

 BPL ZEL2               ; Loop back to zero the next variable until we have done
                        ; them all

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: ZEBC
;       Type: Subroutine
;   Category: Utility routines
;    Summary: Zero-fill pages $B and $C
;
; ******************************************************************************

.ZEBC

 RTS                    ; Return from the subroutine, as ZEBC does nothing in
                        ; this version of Elite (it is left over from the BBC
                        ; Micro version)

 LDX #$C                ; Call ZES1 with X = $C to zero-fill page $C
 JSR ZES1

 DEX                    ; Decrement X to $B

                        ; Fall through into ZES1 to zero-fill page $B

; ******************************************************************************
;
;       Name: ZES1
;       Type: Subroutine
;   Category: Utility routines
;    Summary: Zero-fill the page whose number is in X
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The page we want to zero-fill
;
; ******************************************************************************

.ZES1

 LDY #0                 ; If we set Y = SC = 0 and fall through into ZES2
 STY SC                 ; below, then we will zero-fill 255 bytes starting from
                        ; SC - in other words, we will zero-fill the whole of
                        ; page X

; ******************************************************************************
;
;       Name: ZES2
;       Type: Subroutine
;   Category: Utility routines
;    Summary: Zero-fill a specific page
;
; ------------------------------------------------------------------------------
;
; Zero-fill from address (X SC) + Y to (X SC) + $FF.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The high byte (i.e. the page) of the starting point of
;                       the zero-fill
;
;   Y                   The offset from (X SC) where we start zeroing, counting
;                       up to $FF
;
;   SC                  The low byte (i.e. the offset into the page) of the
;                       starting point of the zero-fill
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   Z flag              Z flag is set
;
; ******************************************************************************

.ZES2

 LDA #0                 ; Load A with the byte we want to fill the memory block
                        ; with - i.e. zero

 STX SC+1               ; We want to zero-fill page X, so store this in the
                        ; high byte of SC, so the 16-bit address in SC and
                        ; SC+1 is now pointing to the SC-th byte of page X

.ZEL1

 STA (SC),Y             ; Zero the Y-th byte of the block pointed to by SC,
                        ; so that's effectively the Y-th byte before SC

 INY                    ; Increment the loop counter

 BNE ZEL1               ; Loop back to zero the next byte

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: SVE
;       Type: Subroutine
;   Category: Save and load
;    Summary: Display the disk access menu and process saving of commander files
;  Deep dive: Commander save files
;             The competition code
;
; ******************************************************************************

.SVE

 LDA #1                 ; Print extended token 1, the disk access menu, which
 JSR DETOK              ; presents these options:
                        ;
                        ;   1. Load New Commander
                        ;   2. Save Commander {commander name}
                        ;   3. Default JAMESON
                        ;   4. Exit

 JSR t                  ; Scan the keyboard until a key is pressed, returning
                        ; the ASCII code in A and X

 CMP #'1'               ; Option 1 was chosen, so jump to loading to load a new
 BEQ loading            ; commander

 CMP #'2'               ; Option 2 was chosen, so jump to SV1 to save the
 BEQ SV1                ; current commander

 CMP #'3'               ; If option 3 wasn't chosen, jump to feb13 to exit the
;BEQ feb10              ; menu
;CMP #'4'               ;
 BNE feb13              ; The instructions in the middle are commented out in
                        ; the original source

 LDA #224               ; Option 3 was chosen, so print extended token 224
 JSR DETOK              ; ("ARE YOU SURE?")

 JSR YESNO              ; Call YESNO to wait until either "Y" or "N" is pressed

 BCC feb13              ; If "N" was pressed, jump to feb13

 JSR JAMESON            ; Otherwise "Y" was pressed, so call JAMESON to set the
                        ; last saved commander to the default "JAMESON"
                        ; commander

 JMP DFAULT             ; Jump to DFAULT to reset the current commander data
                        ; block to the last saved commander, returning from the
                        ; subroutine using a tail call

.feb13

 CLC                    ; Option 5 was chosen, so clear the C flag to indicate
                        ; that nothing was loaded

 RTS                    ; Return from the subroutine

;.feb10                 ; These instructions are commented out in the original
;LDA DISK               ; source
;EOR #$FF
;STA DISK
;JMP SVE

.loading

 JSR GTNMEW             ; If we get here then option 1 (load) was chosen, so
                        ; call GTNMEW to fetch the name of the commander file
                        ; to load (including drive number and directory) into
                        ; INWK

 JSR LOD                ; Call LOD to load the commander file

 JSR TRNME              ; Transfer the commander filename from INWK to NA%

 SEC                    ; Set the C flag to indicate we loaded a new commander

 RTS                    ; Return from the subroutine

.SV1

 JSR GTNMEW             ; If we get here then option 2 (save) was chosen, so
                        ; call GTNMEW to fetch the name of the commander file
                        ; to save (including drive number and directory) into
                        ; INWK

 JSR TRNME              ; Transfer the commander filename from INWK to NA%

 LSR SVC                ; Halve the save count value in SVC

 LDA #4                 ; Print extended token 4 ("COMPETITION NUMBER:")
 JSR DETOK

 LDX #NT%               ; We now want to copy the current commander data block
                        ; from location TP to the last saved commander block at
                        ; NA%+8, so set a counter in X to copy the NT% bytes in
                        ; the commander data block

.SVL1

 LDA TP,X               ; Copy the X-th byte of TP to the X-th byte of NA%+8
;STA $0B00,X            ;
 STA NA%+8,X            ; The STA is commented out in the original source

 DEX                    ; Decrement the loop counter

 BPL SVL1               ; Loop back until we have copied all the bytes in the
                        ; commander data block

 JSR CHECK2             ; Call CHECK2 to calculate the second checksum for the
                        ; last saved commander and return it in A

 STA CHK3               ; Store the checksum in CHK3, which is at the end of the
                        ; last saved commander block

 JSR CHECK              ; Call CHECK to calculate the checksum for the last
                        ; saved commander and return it in A

 STA CHK                ; Store the checksum in CHK, which is at the end of the
                        ; last saved commander block

 PHA                    ; Store the checksum on the stack

 ORA #%10000000         ; Set K = checksum with bit 7 set
 STA K

 EOR COK                ; Set K+2 = K EOR COK (the competition flags)
 STA K+2

 EOR CASH+2             ; Set K+1 = K+2 EOR CASH+2 (the third cash byte)
 STA K+1

 EOR #$5A               ; Set K+3 = K+1 EOR $5A EOR TALLY+1 (the high byte of
 EOR TALLY+1            ; the kill tally)
 STA K+3

 CLC                    ; Clear the C flag so the call to BPRNT does not include
                        ; a decimal point

 JSR BPRNT              ; Print the competition number stored in K to K+3. The
                        ; value of U might affect how this is printed, and as
                        ; it's a temporary variable in zero page that isn't
                        ; reset by ZERO, it might have any value, but as the
                        ; competition code is a 10-digit number, this just means
                        ; it may or may not have an extra space of padding

 JSR TT67               ; Call TT67 twice to print two newlines
 JSR TT67

 PLA                    ; Restore the checksum from the stack

 EOR #$A9               ; Store the checksum EOR $A9 in CHK2, the penultimate
 STA CHK2               ; byte of the last saved commander block

 JSR COPYNAME           ; ???

                        ; We now copy the current commander data block into the
                        ; TAP% staging area

 LDY #NT%               ; Set a counter in X to copy the NT% bytes in the
                        ; commander data block

.copyme2

 LDA NA%+8,Y            ; Copy the X-th byte of NA% to the X-th byte of TAP%
 STA TAP%,Y

 DEY                    ; Decrement the loop counter

 BPL copyme2            ; Loop back until we have copied all the bytes in the
                        ; commander data block

 JSR wfile              ; ???
 BCS diskerror

 JSR DFAULT             ; Call DFAULT to reset the current commander data block
                        ; to the last saved commander

 JSR t                  ; Scan the keyboard until a key is pressed, returning
                        ; the ASCII code in A and X

.SVEX

 CLC                    ; Clear the C flag to indicate we didn't just load a new
                        ; commander file

 RTS                    ; Return from the subroutine

                        ; Fall through into diskerror to show the disk error

; ******************************************************************************
;
;       Name: diskerror
;       Type: Subroutine
;   Category: Save and load
;    Summary: ???
;
; ******************************************************************************

.diskerror

 ASL A                  ; ???
 TAX
 LDA ERTAB-2,X
 STA XX15
 LDA ERTAB-1,X
 STA XX15+1
 LDY #0

.dskerllp

 LDA (XX15),Y
 BEQ dskerllp2
 JSR TT26
 INY
 BNE dskerllp

.dskerllp2 

 JSR BOOP

 JSR t                  ; Scan the keyboard until a key is pressed, returning
                        ; the ASCII code in A and X

 JMP SVE                ; Jump to SVE to display the disc access menu and return
                        ; from the subroutine using a tail call

; ******************************************************************************
;
;       Name: thislong
;       Type: Variable
;   Category: Save and load
;    Summary: Contains the length of the most recently entered commander name
;
; ******************************************************************************

.thislong

 EQUB 7

; ******************************************************************************
;
;       Name: oldlong
;       Type: Variable
;   Category: Save and load
;    Summary: Contains the length of the last saved commander name
;
; ******************************************************************************

.oldlong

 EQUB 7

; ******************************************************************************
;
;       Name: LOD
;       Type: Subroutine
;   Category: Save and load
;    Summary: Load a commander file
;
; ------------------------------------------------------------------------------
;
; The filename should be stored at INWK, terminated with a carriage return (13).
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   LOR                 Set the C flag and return from the subroutine
;
; ******************************************************************************

.LOD

 JSR COPYNAME           ; ???
 JSR rfile
 BCS diskerror
 JSR UNMUTILATE

 LDA TAP%               ; If the first byte of the loaded file has bit 7 set,
 BMI ELT2F              ; jump to ELT2F, as this is an invalid commander file
                        ;
                        ; ELT2F contains a BRK instruction, which will force an
                        ; interrupt to call the address in BRKV, which will
                        ; print out the system error at ELT2F

 LDY #NT%               ; We have successfully loaded the commander file to the
                        ; TAP% staging area, so now we want to copy it to the
                        ; last saved commander data block at NA%+8, so we set up
                        ; a counter in Y to copy NT% bytes

.copyme

 LDA TAP%,Y             ; Copy the Y-th byte of TAP% to the Y-th byte of NA%+8
 STA NA%+8,Y

 DEY                    ; Decrement the loop counter

 BPL copyme             ; Loop back until we have copied all NT% bytes

.LOR

 SEC                    ; Set the C flag

 RTS                    ; Return from the subroutine

.ELT2F

 LDA #9                 ; Print extended token 9 ("{cr}{all caps}ILLEGAL ELITE
 JSR DETOK              ; II FILE{sentence case}")

 JSR t                  ; Scan the keyboard until a key is pressed, returning
                        ; the ASCII code in A and X

 JMP SVE                ; Jump to SVE to display the disc access menu and return
                        ; from the subroutine using a tail call

; ******************************************************************************
;
;       Name: DERR1
;       Type: Variable
;   Category: Save and load
;    Summary: ???
;
; ******************************************************************************

.DERR1

 EQUS "DISK WRITE PROTECTED"
 EQUB 0

; ******************************************************************************
;
;       Name: DERR2
;       Type: Variable
;   Category: Save and load
;    Summary: ???
;
; ******************************************************************************

.DERR2

 EQUS "DISK FULL"
 EQUB 0

; ******************************************************************************
;
;       Name: DERR3
;       Type: Variable
;   Category: Save and load
;    Summary: ???
;
; ******************************************************************************

.DERR3

 EQUS "CATALOG FULL"
 EQUB 0

; ******************************************************************************
;
;       Name: DERR4
;       Type: Variable
;   Category: Save and load
;    Summary: ???
;
; ******************************************************************************

.DERR4

 EQUS "DISK I/O ERROR"
 EQUB 0

; ******************************************************************************
;
;       Name: DERR5
;       Type: Variable
;   Category: Save and load
;    Summary: ???
;
; ******************************************************************************

.DERR5

 EQUS "FILE NOT FOUND"
 EQUB 0

; ******************************************************************************
;
;       Name: ERTAB
;       Type: Variable
;   Category: Save and load
;    Summary: ???
;
; ******************************************************************************

.ERTAB

 EQUW DERR1
 EQUW DERR2
 EQUW DERR3
 EQUW DERR4
 EQUW DERR5

; ******************************************************************************
;
;       Name: backtonormal
;       Type: Subroutine
;   Category: Utility routines
;    Summary: Do nothing
;
; ******************************************************************************

.backtonormal

 RTS                    ; Return from the subroutine, as backtonormal does
                        ; nothing in this version of Elite (it is left over from
                        ; the 6502 Second Processor version)

; ******************************************************************************
;
;       Name: CLDELAY
;       Type: Subroutine
;   Category: Utility routines
;    Summary: Do nothing
;
; ******************************************************************************

.CLDELAY

 RTS                    ; Return from the subroutine, as CLDELAY does nothing in
                        ; this version of Elite (it is left over from the 6502
                        ; Second Processor version)

; ******************************************************************************
;
;       Name: ZEKTRAN
;       Type: Subroutine
;   Category: Keyboard
;    Summary: Clear the key logger
;
; ******************************************************************************

.ZEKTRAN

 LDA #0                 ; We want to zero the key logger buffer, so set A % 0

 LDX #16                ; We want to clear the 17 key logger locations from
                        ; KEYLOOK to KEYLOOK+16, so set a counter in X

.ZEKLOOP

 STA KEYLOOK,X          ; Reset the X-th byte of the key logger buffer to 0

 DEX                    ; Decrement the loop counter

 BPL ZEKLOOP            ; Loop back until we have zeroed bytes #11 through #0

 RTS                    ; Return from the subroutine

 RTS                    ; This instruction has no effect as we already returned
                        ; from the subroutine

; ******************************************************************************
;
;       Name: SPS1
;       Type: Subroutine
;   Category: Maths (Geometry)
;    Summary: Calculate the vector to the planet and store it in XX15
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   SPS1+1              A BRK instruction
;
; ******************************************************************************

.SPS1

 LDX #0                 ; Copy the two high bytes of the planet's x-coordinate
 JSR SPS3               ; into K3(2 1 0), separating out the sign bit into K3+2

 LDX #3                 ; Copy the two high bytes of the planet's y-coordinate
 JSR SPS3               ; into K3(5 4 3), separating out the sign bit into K3+5

 LDX #6                 ; Copy the two high bytes of the planet's z-coordinate
 JSR SPS3               ; into K3(8 7 6), separating out the sign bit into K3+8

                        ; Fall through into TAS2 to build XX15 from K3

; ******************************************************************************
;
;       Name: TAS2
;       Type: Subroutine
;   Category: Maths (Geometry)
;    Summary: Normalise the three-coordinate vector in K3
;
; ------------------------------------------------------------------------------
;
; Normalise the vector in K3, which has 16-bit values and separate sign bits,
; and store the normalised version in XX15 as a signed 8-bit vector.
;
; A normalised vector (also known as a unit vector) has length 1, so this
; routine takes an existing vector in K3 and scales it so the length of the
; new vector is 1. This is used in two places: when drawing the compass, and
; when applying AI tactics to ships.
;
; We do this in two stages. This stage shifts the 16-bit vector coordinates in
; K3 to the left as far as they will go without losing any bits off the end, so
; we can then take the high bytes and use them as the most accurate 8-bit vector
; to normalise. Then the next stage (in routine NORM) does the normalisation.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   K3(2 1 0)           The 16-bit x-coordinate as (x_sign x_hi x_lo), where
;                       x_sign is just bit 7
;
;   K3(5 4 3)           The 16-bit y-coordinate as (y_sign y_hi y_lo), where
;                       y_sign is just bit 7
;
;   K3(8 7 6)           The 16-bit z-coordinate as (z_sign z_hi z_lo), where
;                       z_sign is just bit 7
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   XX15                The normalised vector, with:
;
;                         * The x-coordinate in XX15
;
;                         * The y-coordinate in XX15+1
;
;                         * The z-coordinate in XX15+2
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   TA2                 Calculate the length of the vector in XX15 (ignoring the
;                       low coordinates), returning it in Q
;
; ******************************************************************************

.TAS2

 LDA K3                 ; OR the three low bytes and 1 to get a byte that has
 ORA K3+3               ; a 1 wherever any of the three low bytes has a 1
 ORA K3+6               ; (as well as always having bit 0 set), and store in
 ORA #1                 ; K3+9
 STA K3+9

 LDA K3+1               ; OR the three high bytes to get a byte in A that has a
 ORA K3+4               ; 1 wherever any of the three high bytes has a 1
 ORA K3+7

                        ; (A K3+9) now has a 1 wherever any of the 16-bit
                        ; values in K3 has a 1
.TAL2

 ASL K3+9               ; Shift (A K3+9) to the left, so bit 7 of the high byte
 ROL A                  ; goes into the C flag

 BCS TA2                ; If the left shift pushed a 1 out of the end, then we
                        ; know that at least one of the coordinates has a 1 in
                        ; this position, so jump to TA2 as we can't shift the
                        ; values in K3 any further to the left

 ASL K3                 ; Shift K3(1 0), the x-coordinate, to the left
 ROL K3+1

 ASL K3+3               ; Shift K3(4 3), the y-coordinate, to the left
 ROL K3+4

 ASL K3+6               ; Shift K3(6 7), the z-coordinate, to the left
 ROL K3+7

 BCC TAL2               ; Jump back to TAL2 to do another shift left (this BCC
                        ; is effectively a JMP as we know bit 7 of K3+7 is not a
                        ; 1, as otherwise bit 7 of A would have been a 1 and we
                        ; would have taken the BCS above)

.TA2

 LDA K3+1               ; Fetch the high byte of the x-coordinate from our left-
 LSR A                  ; shifted K3, shift it right to clear bit 7, stick the
 ORA K3+2               ; sign bit in there from the x_sign part of K3, and
 STA XX15               ; store the resulting signed 8-bit x-coordinate in XX15

 LDA K3+4               ; Fetch the high byte of the y-coordinate from our left-
 LSR A                  ; shifted K3, shift it right to clear bit 7, stick the
 ORA K3+5               ; sign bit in there from the y_sign part of K3, and
 STA XX15+1             ; store the resulting signed 8-bit y-coordinate in
                        ; XX15+1

 LDA K3+7               ; Fetch the high byte of the z-coordinate from our left-
 LSR A                  ; shifted K3, shift it right to clear bit 7, stick the
 ORA K3+8               ; sign bit in there from the z_sign part of K3, and
 STA XX15+2             ; store the resulting signed 8-bit  z-coordinate in
                        ; XX15+2

                        ; Now we have a signed 8-bit version of the vector K3 in
                        ; XX15, so fall through into NORM to normalise it

; ******************************************************************************
;
;       Name: NORM
;       Type: Subroutine
;   Category: Maths (Geometry)
;    Summary: Normalise the three-coordinate vector in XX15
;  Deep dive: Tidying orthonormal vectors
;             Orientation vectors
;
; ------------------------------------------------------------------------------
;
; We do this by dividing each of the three coordinates by the length of the
; vector, which we can calculate using Pythagoras. Once normalised, 96 ($60) is
; used to represent a value of 1, and 96 with bit 7 set ($E0) is used to
; represent -1. This enables us to represent fractional values of less than 1
; using integers.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   XX15                The vector to normalise, with:
;
;                         * The x-coordinate in XX15
;
;                         * The y-coordinate in XX15+1
;
;                         * The z-coordinate in XX15+2
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   XX15                The normalised vector
;
;   Q                   The length of the original XX15 vector
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   NO1                 Contains an RTS
;
; ******************************************************************************

.NORM

 LDA XX15               ; Fetch the x-coordinate into A

 JSR SQUA               ; Set (A P) = A * A = x^2

 STA R                  ; Set (R Q) = (A P) = x^2
 LDA P
 STA Q

 LDA XX15+1             ; Fetch the y-coordinate into A

 JSR SQUA               ; Set (A P) = A * A = y^2

 STA T                  ; Set (T P) = (A P) = y^2

 LDA P                  ; Set (R Q) = (R Q) + (T P) = x^2 + y^2
 ADC Q                  ;
 STA Q                  ; First, doing the low bytes, Q = Q + P

 LDA T                  ; And then the high bytes, R = R + T
 ADC R
 STA R

 LDA XX15+2             ; Fetch the z-coordinate into A

 JSR SQUA               ; Set (A P) = A * A = z^2

 STA T                  ; Set (T P) = (A P) = z^2

 LDA P                  ; Set (R Q) = (R Q) + (T P) = x^2 + y^2 + z^2
 ADC Q                  ;
 STA Q                  ; First, doing the low bytes, Q = Q + P

 LDA T                  ; And then the high bytes, R = R + T
 ADC R
 STA R

 JSR LL5                ; We now have the following:
                        ;
                        ; (R Q) = x^2 + y^2 + z^2
                        ;
                        ; so we can call LL5 to use Pythagoras to get:
                        ;
                        ; Q = SQRT(R Q)
                        ;   = SQRT(x^2 + y^2 + z^2)
                        ;
                        ; So Q now contains the length of the vector (x, y, z),
                        ; and we can normalise the vector by dividing each of
                        ; the coordinates by this value, which we do by calling
                        ; routine TIS2. TIS2 returns the divided figure, using
                        ; 96 to represent 1 and 96 with bit 7 set for -1

 LDA XX15               ; Call TIS2 to divide the x-coordinate in XX15 by Q,
 JSR TIS2               ; with 1 being represented by 96
 STA XX15

 LDA XX15+1             ; Call TIS2 to divide the y-coordinate in XX15+1 by Q,
 JSR TIS2               ; with 1 being represented by 96
 STA XX15+1

 LDA XX15+2             ; Call TIS2 to divide the z-coordinate in XX15+2 by Q,
 JSR TIS2               ; with 1 being represented by 96
 STA XX15+2

.NO1

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: RDS1
;       Type: Subroutine
;   Category: Keyboard
;    Summary: Scan the joysticks
;
; ******************************************************************************

.RDS1

 \Read Joystick X
 LDA $C064,X            ; ???
 BMI RDS1
 LDY $C070
 LDY #0
 NOP
 NOP

.RDL2

 LDA $C064,X
 BPL RDR1
 INY
 BNE RDL2
 DEY

.RDR1

 TYA
 EOR JSTE
 RTS

; ******************************************************************************
;
;       Name: RDKEY
;       Type: Subroutine
;   Category: Keyboard
;    Summary: Scan the keyboard for key presses
;
; ******************************************************************************

.RDKEY

 TYA                    ; ???
 PHA
 JSR ZEKTRAN

.scanmatrix

 CLC
 LDA $C000
 BPL nokeys2
 BIT $C010
 AND #127
 STA thiskey
 LDX #16

.RDL1

 CMP KYTB,X
 BNE RD1
 DEC KEYLOOK,X

.RD1

 DEX
 BNE RDL1
 SEC

.nokeys2

 LDA JSTK

IF _IB_DISK

 BPL nofast+2

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 BPL nojoyst

ENDIF

IF _IB_DISK OR _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES

 LDX auto
 BNE nojoyst
;LDX #0

ELIF _SOURCE_DISK_CODE_FILES

 LDX #0

ENDIF

 JSR RDS1
 EOR #$FF
 STA JSTX
 INX
 JSR RDS1
 EOR JSTGY
 STA JSTY

.nojoyst

 LDA #$FF
 BIT $C061
 BPL nofire
 BIT $C062
 BPL noslow
 STA KY1
 BMI nofast

.noslow

 STA KY7

.nofire

 BIT $C062
 BPL nofast
 STA KY2

.nofast

 LDA QQ11
 BEQ allkeys
 LDA #0
 STA KY12
 STA KY13
 STA KY14
 STA KY15
 STA KY16
 STA KY17
 STA KY18
 STA KY19
 STA KY20

.allkeys

 PLA
 TAY
 LDA thiskey
 TAX
 RTS  ;!!
 \.......

; ******************************************************************************
;
;       Name: WARP
;       Type: Subroutine
;   Category: Flight
;    Summary: Perform an in-system jump
;
; ------------------------------------------------------------------------------
;
; This is called when we press "J" during flight. The following checks are
; performed:
;
;   * Make sure we don't have any ships or space stations in the vicinity
;
;   * Make sure we are not in witchspace
;
;   * If we are facing the planet, make sure we aren't too close
;
;   * If we are facing the sun, make sure we aren't too close
;
; If the above checks are passed, then we perform an in-system jump by moving
; the sun and planet in the opposite direction to travel, so we appear to jump
; in space. This means that any asteroids, cargo canisters or escape pods get
; dragged along for the ride.
;
; ******************************************************************************

.WARP

 LDX JUNK               ; Set X to the total number of junk items in the
                        ; vicinity (e.g. asteroids, escape pods, cargo
                        ; canisters, Shuttles, Transporters and so on)

 LDA FRIN+2,X           ; If the slot at FRIN+2+X is non-zero, then we have
                        ; something else in the vicinity besides asteroids,
                        ; escape pods and cargo canisters, so to check whether
                        ; we can jump, we first grab the slot contents into A

 ORA SSPR               ; If there is a space station nearby, then SSPR will
                        ; be non-zero, so OR'ing with SSPR will produce a
                        ; non-zero result if either A or SSPR are non-zero

 ORA MJ                 ; If we are in witchspace, then MJ will be non-zero, so
                        ; OR'ing with MJ will produce a non-zero result if
                        ; either A or SSPR or MJ are non-zero

 BNE WA1                ; A is non-zero if we have either a ship or a space
                        ; station in the vicinity, or we are in witchspace, in
                        ; which case jump to WA1 to make a low beep to show that
                        ; we can't do an in-system jump

 LDY K%+8               ; Otherwise we can do an in-system jump, so now we fetch
                        ; the byte at K%+8, which contains the z_sign for the
                        ; first ship slot, i.e. the distance of the planet

 BMI WA3                ; If the planet's z_sign is negative, then the planet
                        ; is behind us, so jump to WA3 to skip the following

 TAY                    ; Set A = Y = 0 (as we didn't BNE above) so the call
                        ; to MAS2 measures the distance to the planet

 JSR MAS2               ; Call MAS2 to set A to the largest distance to the
                        ; planet in any of the three axes (we could also call
                        ; routine m to do the same thing, as A = 0)

 CMP #2                 ; If A < 2 then jump to WA1 to abort the in-system jump
 BCC WA1                ; with a low beep, as we are facing the planet and are
                        ; too close to jump in that direction

.WA3

 LDY K%+NI%+8           ; Fetch the z_sign (byte #8) of the second ship in the
                        ; ship data workspace at K%, which is reserved for the
                        ; sun or the space station (in this case it's the
                        ; former, as we already confirmed there isn't a space
                        ; station in the vicinity)

 BMI WA2                ; If the sun's z_sign is negative, then the sun is
                        ; behind us, so jump to WA2 to skip the following

 LDY #NI%               ; Set Y to point to the offset of the ship data block
                        ; for the sun, which is NI% (as each block is NI% bytes
                        ; long, and the sun is the second block)

 JSR m                  ; Call m to set A to the largest distance to the sun
                        ; in any of the three axes

 CMP #2                 ; If A < 2 then jump to WA1 to abort the in-system jump
 BCC WA1                ; with a low beep, as we are facing the sun and are too
                        ; close to jump in that direction

.WA2

                        ; If we get here, then we can do an in-system jump, as
                        ; we don't have any ships or space stations in the
                        ; vicinity, we are not in witchspace, and if we are
                        ; facing the planet or the sun, we aren't too close to
                        ; jump towards it
                        ;
                        ; We do an in-system jump by moving the sun and planet,
                        ; rather than moving our own local bubble (this is why
                        ; in-system jumps drag asteroids, cargo canisters and
                        ; escape pods along for the ride). Specifically, we move
                        ; them in the z-axis by a fixed amount in the opposite
                        ; direction to travel, thus performing a jump towards
                        ; our destination

 LDA #$81               ; Set R = R = P = $81
 STA S
 STA R
 STA P

 LDA K%+8               ; Set A = z_sign for the planet

 JSR ADD                ; Set (A X) = (A P) + (S R)
                        ;           = (z_sign $81) + $8181
                        ;           = (z_sign $81) - $0181
                        ;
                        ; This moves the planet against the direction of travel
                        ; by reducing z_sign by 1, as the above maths is:
                        ;
                        ;         z_sign 00000000
                        ;   +   00000000 10000001
                        ;   -   00000001 10000001
                        ;
                        ; or:
                        ;
                        ;         z_sign 00000000
                        ;   +   00000000 00000000
                        ;   -   00000001 00000000
                        ;
                        ; i.e. the high byte is z_sign - 1, making sure the sign
                        ; is preserved

 STA K%+8               ; Set the planet's z_sign to the high byte of the result

 LDA K%+NI%+8           ; Set A = z_sign for the sun

 JSR ADD                ; Set (A X) = (A P) + (S R)
                        ;           = (z_sign $81) + $8181
                        ;           = (z_sign $81) - $0181
                        ;
                        ; which moves the sun against the direction of travel
                        ; by reducing z_sign by 1

 STA K%+NI%+8           ; Set the planet's z_sign to the high byte of the result

 LDA #1                 ; Temporarily set the view type to a non-zero value, so
 STA QQ11               ; the call to LOOK1 below clears the screen before
                        ; switching to the space view

 STA MCNT               ; Set the main loop counter to 1, so the next iteration
                        ; through the main loop will potentially spawn ships
                        ; (see part 2 of the main game loop at me3)

 LSR A                  ; Set EV, the extra vessels spawning counter, to 0
 STA EV                 ; (the LSR produces a 0 as A was previously 1)

 LDX VIEW               ; Set X to the current view (front, rear, left or right)
 JMP LOOK1              ; and jump to LOOK1 to initialise that view, returning
                        ; from the subroutine using a tail call

.WA1

 JMP BOOP               ; If we get here then we can't do an in-system jump, so
                        ; call the BOOP routine to make a long, low beep and
                        ; return from the subroutine using a tail call

; ******************************************************************************
;
;       Name: KYTB
;       Type: Variable
;   Category: Keyboard
;    Summary: Lookup table for in-flight keyboard controls
;  Deep dive: The key logger
;
; ------------------------------------------------------------------------------
;
; Keyboard table for in-flight controls. This table contains the ASCII values
; for the flight keys.
;
; ******************************************************************************

.KYTB

 RTS                    ; Return from the subroutine (used as an entry point and
                        ; a fall-through from above)

                        ; These are the primary flight controls (pitch, roll,
                        ; speed and lasers):

 EQUS "/"               ; ?         KYTB+1      Slow down
 EQUS " "               ; Space     KYTB+2      Speed up
 EQUS ","               ; <         KYTB+3      Roll left
 EQUS "."               ; >         KYTB+4      Roll right
 EQUS "X"               ; X         KYTB+5      Pitch up
 EQUS "S"               ; S         KYTB+6      Pitch down
 EQUS "A"               ; A         KYTB+7      Fire lasers

                        ; These are the secondary flight controls:

 EQUS "B"               ; B         KYTB+8      Energy bomb
 EQUB 27                ; ESCAPE    KYTB+9      Launch escape pod
 EQUS "T"               ; T         KYTB+10     Arm missile
 EQUS "U"               ; U         KYTB+11     Unarm missile
 EQUS "M"               ; M         KYTB+12     Fire missile
 EQUS "E"               ; E         KYTB+13     E.C.M.
 EQUS "J"               ; J         KYTB+14     In-system jump
 EQUS "C"               ; C         KYTB+15     Docking computer
 EQUS "P"               ; P         KYTB+16     Cancel docking computer

; ******************************************************************************
;
;       Name: DKSANYKEY
;       Type: Subroutine
;   Category: Keyboard
;    Summary: ???
;
; ******************************************************************************

.DKSANYKEY

 LDX #0
 BIT $C000
 BPL P%+6
 DEX
 BIT $C010
 TXA
 RTS

; ******************************************************************************
;
;       Name: DKS2
;       Type: Subroutine
;   Category: Keyboard
;    Summary: Read the joystick position
;
; ------------------------------------------------------------------------------
;
; This routine is not used in this version of Elite. It is left over from the
; BBC Micro version.
;
; ******************************************************************************

.DKS2

;LDA KTRAN+7,X          ; These instructions are commented out in the original
;EOR JSTE               ; source

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: DKS3
;       Type: Subroutine
;   Category: Keyboard
;    Summary: Toggle a configuration setting and emit a beep
;
; ------------------------------------------------------------------------------
;
; This is called when the game is paused and a key is pressed that changes the
; game's configuration.
;
; Specifically, this routine toggles the configuration settings for the
; following keys:
;
;   * CAPS LOCK toggles keyboard flight damping (0)
;   * A toggles keyboard auto-recentre (1)
;   * X toggles author names on start-up screen (2)
;   * F toggles flashing console bars (3)
;   * Y toggles reverse joystick Y channel (4)
;   * J toggles reverse both joystick channels (5)
;   * K toggles keyboard and joystick (6)
;
; The numbers in brackets are the configuration options that we pass in Y. We
; pass the ASCII code of the key that has been pressed in X, and the option to
; check it against in Y, so this routine is typically called in a loop that
; loops through the various configuration option.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   The ASCII code of the key that's been pressed
;
;   Y                   The number of the configuration option to check against
;                       from the list above (i.e. Y must be from 0 to 6)
;
; ******************************************************************************

.DKS3

 TXA                    ; Copy the ASCII code of the key that has been pressed
                        ; into A

 CMP TGINT,Y            ; If the pressed key doesn't match the configuration key
 BNE Dk3                ; for option Y (as listed in the TGINT table), then jump
                        ; to Dk3 to return from the subroutine

 LDA DAMP,Y             ; The configuration keys listed in TGINT correspond to
 EOR #$FF               ; the configuration option settings from DAMP onwards,
 STA DAMP,Y             ; so to toggle a setting, we fetch the existing byte
                        ; from DAMP+Y, invert it and put it back (0 means no
                        ; and $FF means yes in the configuration bytes, so
                        ; this toggles the setting)

 BPL P%+5               ; If the result has a clear bit 7 (i.e. we just turned
                        ; the option off), skip the following instruction

 JSR BELL               ; We just turned the option on, so make a standard
                        ; system beep, so in all we make two beeps

 JSR BELL               ; Make a beep sound so we know something has happened

 TYA                    ; Store Y and A on the stack so we can retrieve them
 PHA                    ; below

 LDY #20                ; Wait for 20 vertical syncs (20/50 = 0.4 seconds)
 JSR DELAY

 PLA                    ; Restore A and Y from the stack
 TAY

.Dk3

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: U%
;       Type: Subroutine
;   Category: Keyboard
;    Summary: Clear the key logger
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   A                   A is set to 0
;
;   Y                   Y is set to 0
;
; ******************************************************************************

.U%

;LDA #0                 ; These instructions are commented out in the original
;LDY #$38               ; source

.DKL3

;STA KLO,Y              ; These instructions are commented out in the original
;DEY                    ; source
;BNE DKL3
;STA KL

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: DOKEY
;       Type: Subroutine
;   Category: Keyboard
;    Summary: Scan for the seven primary flight controls and apply the docking
;             computer manoeuvring code
;  Deep dive: The key logger
;             The docking computer
;
; ------------------------------------------------------------------------------
;
; Scan for the seven primary flight controls (or the equivalent on joystick),
; pause and configuration keys, and secondary flight controls, and update the
; key logger accordingly. Specifically, this part clears the key logger and
; updates it for the seven primary flight controls, and updates the pitch and
; roll rates accordingly.
;
; We then end up at DK4 to scan for other keys, beyond the seven primary flight
; controls.
;
; ******************************************************************************

.DOKEY

 JSR RDKEY              ; Scan the keyboard for a key press and return the
                        ; ASCII code of the key pressed in X

 LDA auto               ; If auto is 0, then the docking computer is not
 BEQ DK15               ; currently activated, so jump to DK15 to skip the
                        ; docking computer manoeuvring code below

 JSR ZINF               ; Call ZINF to reset the INWK ship workspace

 LDA #96                ; Set nosev_z_hi = 96
 STA INWK+14

 ORA #%10000000         ; Set sidev_x_hi = -96
 STA INWK+22

 STA TYPE               ; Set the ship type to -96, so the negative value will
                        ; let us check in the DOCKIT routine whether this is our
                        ; ship that is activating its docking computer, rather
                        ; than an NPC ship docking

 LDA DELTA              ; Set the ship speed to DELTA (our speed)
 STA INWK+27

 JSR DOCKIT             ; Call DOCKIT to calculate the docking computer's moves
                        ; and update INWK with the results

                        ; We now "press" the relevant flight keys, depending on
                        ; the results from DOCKIT, starting with the pitch keys

 LDA INWK+27            ; Fetch the updated ship speed from byte #27 into A

 CMP #22                ; If A < 22, skip the next instruction
 BCC P%+4

 LDA #22                ; Set A = 22, so the maximum speed during docking is 22

 STA DELTA              ; Update DELTA to the new value in A

 LDA #$FF               ; Set A = $FF, which we can insert into the key logger
                        ; to "fake" the docking computer working the keyboard

 LDX #(KY1-KLO)         ; Set X to the offset of KY1 within the KLO table, so we
                        ; "press" KY1 below ("?", slow down)

 LDY INWK+28            ; If the updated acceleration in byte #28 is zero, skip
 BEQ DK11               ; to DK11

 BMI P%+4               ; If the updated acceleration is negative, skip the
                        ; following instruction

 LDX #(KY2-KLO)         ; Set X to the offset of KY2 within the KLO table, so we
                        ; "press" KY2 with the next instruction (Space, speed
                        ; up)

 STA KLO,X              ; Store $FF in either KY1 or KY2 to "press" the relevant
                        ; key, depending on whether the updated acceleration is
                        ; negative (in which case we "press" KY1, "?", to slow
                        ; down) or positive (in which case we "press" KY2,
                        ; Space, to speed up)

.DK11

                        ; We now "press" the relevant roll keys, depending on
                        ; the results from DOCKIT

 LDA #128               ; Set A = 128, which indicates no change in roll when
                        ; stored in JSTX (i.e. the centre of the roll indicator)

 LDX #(KY3-KLO)         ; Set X to the offset of KY3 within the KLO table, so we
                        ; "press" KY3 below ("<", increase roll)

 ASL INWK+29            ; Shift ship byte #29 left, which shifts bit 7 of the
                        ; updated roll counter (i.e. the roll direction) into
                        ; the C flag

 BEQ DK12               ; If the remains of byte #29 is zero, then the updated
                        ; roll counter is zero, so jump to DK12 set JSTX to 128,
                        ; to indicate there's no change in the roll

 BCC P%+4               ; If the C flag is clear, skip the following instruction

 LDX #(KY4-KLO)         ; Set X to the offset of KY4 within the KLO table, so we
                        ; "press" KY4 below (">", decrease roll)

 BIT INWK+29            ; We shifted the updated roll counter to the left above,
 BPL DK14               ; so this tests bit 6 of the original value, and if it
                        ; is clear (i.e. the magnitude is less than 64), jump to
                        ; DK14 to "press" the key and leave JSTX unchanged

 LDA #64                ; The magnitude of the updated roll is 64 or more, so
 STA JSTX               ; set JSTX to 64 (so the roll decreases at half the
                        ; maximum rate)

 LDA #0                 ; And set A = 0 so we do not "press" any keys (so if the
                        ; docking computer needs to make a serious roll, it does
                        ; so by setting JSTX directly rather than by "pressing"
                        ; a key)

.DK14

 STA KLO,X              ; Store A in either KY3 or KY4, depending on whether
                        ; the updated roll rate is increasing (KY3) or
                        ; decreasing (KY4)

 LDA JSTX               ; Fetch A from JSTX so the next instruction has no
                        ; effect

.DK12

 STA JSTX               ; Store A in JSTX to update the current roll rate

                        ; We now "press" the relevant pitch keys, depending on
                        ; the results from DOCKIT

 LDA #128               ; Set A = 128, which indicates no change in pitch when
                        ; stored in JSTX (i.e. the centre of the pitch
                        ; indicator)

 LDX #(KY5-KLO)         ; Set X to the offset of KY5 within the KLO table, so we
                        ; "press" KY5 below ("X", decrease pitch, pulling the
                        ; nose up)

 ASL INWK+30            ; Shift ship byte #30 left, which shifts bit 7 of the
                        ; updated pitch counter (i.e. the pitch direction) into
                        ; the C flag

 BEQ DK13               ; If the remains of byte #30 is zero, then the updated
                        ; pitch counter is zero, so jump to DK13 set JSTY to
                        ; 128, to indicate there's no change in the pitch

 BCS P%+4               ; If the C flag is set, skip the following instruction

 LDX #(KY6-KLO)         ; Set X to the offset of KY6 within the KLO table, so we
                        ; "press" KY6 below ("S", increase pitch, so the nose
                        ; dives)

 STA KLO,X              ; Store 128 in either KY5 or KY6 to "press" the relevant
                        ; key, depending on whether the pitch direction is
                        ; negative (in which case we "press" KY5, "X", to
                        ; decrease the pitch, pulling the nose up) or positive
                        ; (in which case we "press" KY6, "S", to increase the
                        ; pitch, pushing the nose down)

 LDA JSTY               ; Fetch A from JSTY so the next instruction has no
                        ; effect

.DK13

 STA JSTY               ; Store A in JSTY to update the current pitch rate

.DK15

 LDX JSTX               ; Set X = JSTX, the current roll rate (as shown in the
                        ; RL indicator on the dashboard)

 LDA #20                ; Set A to 20, which is the amount we want to alter the
                        ; roll rate by if the roll keys are being pressed

 LDY KY3                ; If the "<" key is not being pressed, skip the next
 BEQ P%+5               ; instruction

 JSR BUMP2              ; The "<" key is being pressed, so call the BUMP2
                        ; routine to increase the roll rate in X by A

 LDY KY4                ; If the ">" key is not being pressed, skip the next
 BEQ P%+5               ; instruction

 JSR REDU2              ; The "<" key is being pressed, so call the REDU2
                        ; routine to decrease the roll rate in X by A, taking
                        ; the keyboard auto re-centre setting into account

 STX JSTX               ; Store the updated roll rate in JSTX

 LDX JSTY               ; Set X = JSTY, the current pitch rate (as shown in the
                        ; DC indicator on the dashboard)

 LDY KY5                ; If the "X" key is not being pressed, skip the next
 BEQ P%+5               ; instruction

 JSR REDU2              ; The "X" key is being pressed, so call the REDU2
                        ; routine to decrease the pitch rate in X by A, taking
                        ; the keyboard auto re-centre setting into account

 LDY KY6                ; If the "S" key is not being pressed, skip the next
 BEQ P%+5               ; instruction

 JSR BUMP2              ; The "S" key is being pressed, so call the BUMP2
                        ; routine to increase the pitch rate in X by A

 STX JSTY               ; Store the updated roll rate in JSTY

                        ; Fall through into DK4 to scan for other keys

; ******************************************************************************
;
;       Name: DK4
;       Type: Subroutine
;   Category: Keyboard
;    Summary: Scan for pause, configuration and secondary flight keys
;  Deep dive: The key logger
;
; ------------------------------------------------------------------------------
;
; Scan for pause and configuration keys, and if this is a space view, also scan
; for secondary flight controls.
;
; Specifically:
;
;   * Scan for the pause button ("=") and if it's pressed, pause the game and
;     process any configuration key presses until the game is unpaused ("-")
;
;   * If this is a space view, scan for secondary flight keys and update the
;     relevant bytes in the key logger
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   FREEZE              Rejoin the pause routine after processing a screen save
;
; ******************************************************************************

.DK4

 LDX thiskey            ; Fetch the key pressed from thiskey in the key logger

 STX KL                 ; Store X in KL, byte #0 of the key logger

 CPX #'='               ; If "=" is not being pressed, jump to DK2 below,
 BNE DK2                ; otherwise let's process the configuration keys

.FREEZE

                        ; COPY is being pressed, so we enter a loop that
                        ; listens for configuration keys, and we keep looping
                        ; until we detect a DELETE key press. This effectively
                        ; pauses the game when COPY is pressed, and unpauses
                        ; it when DELETE is pressed

 JSR WSCAN              ; Call WSCAN to wait for the vertical sync, so the whole
                        ; screen gets drawn

 JSR RDKEY              ; Scan the keyboard for a key press and return the
                        ; ASCII code of the key pressed in X (or 0 for no key
                        ; press)

 CPX #'Q'               ; If "Q" is not being pressed, skip to DK6
 BNE DK6

 LDX #$FF               ; "Q" is being pressed, so set DNOIZ to $FF to turn the
 STX DNOIZ              ; sound off

 LDX #'Q'               ; Set X to the ASCII for "Q" once again, so it doesn't
                        ; get changed by the above

.DK6

 LDY #0                 ; We now want to loop through the keys that toggle
                        ; various settings, so set a counter in Y to work our
                        ; way through them

.DKL4

 JSR DKS3               ; Call DKS3 to scan for the key given in Y, and toggle
                        ; the relevant setting if it is pressed

 INY                    ; Increment Y to point to the next toggle key

 CPY #(DISK+1-DAMP)     ; Check to see whether we have reached the last toggle
                        ; key (as they run from DAMP to MULIE, or DAMP+1)

 BNE DKL4               ; If not, loop back to check for the next toggle key

 CPX #'S'               ; If "S" is not being pressed, jump to DK7
 BNE DK7

 LDA #0                 ; "S" is being pressed, so set DNOIZ to 0 to turn the
 STA DNOIZ              ; sound on

.DK7

 CPX #$1B               ; If ESCAPE is not being pressed, skip over the next
 BNE P%+5               ; instruction

 JMP DEATH2             ; ESCAPE is being pressed, so jump to DEATH2 to end
                        ; the game

 CPX #'-'               ; If "-" is not being pressed, we are still paused,
 BNE FREEZE             ; so loop back up to keep listening for configuration
                        ; keys, otherwise fall through into the rest of the
                        ; key detection code, which unpauses the game

.DK2

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TT217
;       Type: Subroutine
;   Category: Keyboard
;    Summary: Scan the keyboard until a key is pressed
;
; ------------------------------------------------------------------------------
;
; Scan the keyboard until a key is pressed, and return the key's ASCII code.
; If, on entry, a key is already being held down, then wait until that key is
; released first (so this routine detects the first key down event following
; the subroutine call).
;
; ------------------------------------------------------------------------------
;
; Returns:
;
;   X                   The ASCII code of the key that was pressed
;
;   A                   Contains the same as X
;
;   Y                   Y is preserved
;
; ------------------------------------------------------------------------------
;
; Other entry points:
;
;   out                 Contains an RTS
;
;   t                   As TT217 but don't preserve Y, set it to YSAV instead
;
; ******************************************************************************

.TT217

 STY YSAV               ; Store Y in temporary storage, so we can restore it
                        ; later

.t

 LDY #2                 ; Delay for 2 vertical syncs (2/50 = 0.04 seconds) so we
 JSR DELAY              ; don't take up too much CPU time while looping round

 JSR RDKEY              ; Scan the keyboard for a key press and return the
                        ; ASCII code of the key pressed in X (or 0 for no key
                        ; press)

 BNE t                  ; If a key was already being held down when we entered
                        ; this routine, keep looping back up to t, until the
                        ; key is released

.t2

 JSR RDKEY              ; Any pre-existing key press is now gone, so we can
                        ; start scanning the keyboard again, returning the
                        ; ASCII code of the key pressed in X (or 0 for no key
                        ; press)

 BEQ t2                 ; Keep looping up to t2 until a key is pressed

 LDY YSAV               ; Restore the original value of Y we stored above

 TAX                    ; Copy A into X

.out

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: me1
;       Type: Subroutine
;   Category: Flight
;    Summary: Erase an old in-flight message and display a new one
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The text token to be printed
;
;   X                   Must be set to 0
;
; ******************************************************************************

.me1

 STX DLY                ; Set the message delay in DLY to 0, so any new
                        ; in-flight messages will be shown instantly

 PHA                    ; Store the new message token we want to print

 LDA MCH                ; Set A to the token number of the message that is
 JSR mes9               ; currently on-screen, and call mes9 to print it (which
                        ; will remove it from the screen, as printing is done
                        ; using EOR logic)

 PLA                    ; Restore the new message token

; ******************************************************************************
;
;       Name: MESS
;       Type: Subroutine
;   Category: Flight
;    Summary: Display an in-flight message
;
; ------------------------------------------------------------------------------
;
; Display an in-flight message in capitals at the bottom of the space view,
; erasing any existing in-flight message first.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   A                   The text token to be printed
;
; ******************************************************************************

.MESS

 PHA                    ; Store A on the stack so we can restore it after the
                        ; following

 LDA #15                ; Set A = 15 to use as the text row for the message if
                        ; this is a space view

 LDX QQ11               ; If this is the space view, skip the following
 BEQ infrontvw          ; instruction

 JSR CLYNS              ; Clear the bottom three text rows of the upper screen,
                        ; and move the text cursor to column 1 on row 21, i.e.
                        ; the start of the top row of the three bottom rows

 LDA #25                ; Set A = 25 to use as the text row for the message if
                        ; this is not a space view

 EQUB $2C               ; Skip the next instruction by turning it into
                        ; $2C $85 $36, or BIT $3685, which does nothing apart
                        ; from affect the flags

.infrontvw

 STA YC                ; Move the text cursor to the row specified in A

 LDX #0                 ; Set QQ17 = 0 to switch to ALL CAPS
 STX QQ17

 LDA messXC             ; Move the text cursor to column messXC, in case we
 STA XC                 ; jump to me1 below to erase the current in-flight
                        ; message (whose column we stored in messXC when we
                        ; called MESS to put it there in the first place)

 PLA                    ; Restore A from the stack

 LDY #20                ; Set Y = 20 for setting the message delay below

 CPX DLY                ; If the message delay in DLY is not zero, jump up to
 BNE me1                ; me1 to erase the current message first (whose token
                        ; number will be in MCH)

 STY DLY                ; Set the message delay in DLY to 20

 STA MCH                ; Set MCH to the token we are about to display

                        ; Before we fall through into mes9 to print the token,
                        ; we need to work out the starting column for the
                        ; message we want to print, so it's centred on-screen,
                        ; so the following doesn't print anything, it just uses
                        ; the justified text mechanism to work out the number of
                        ; characters in the message we are going to print

 LDA #%11000000         ; Set the DTW4 flag to %11000000 (justify text, buffer
 STA DTW4               ; entire token including carriage returns)

 LDA de                 ; Set the C flag to bit 1 of the destruction flag in de
 LSR A

 LDA #0                 ; Set A = 0

 BCC P%+4               ; If the destruction flag in de is not set, skip the
                        ; following instruction

 LDA #10                ; Set A = 10

 STA DTW5               ; Store A in DTW5, so DTW5 (which holds the size of the
                        ; justified text buffer at BUF) is set to 0 if the
                        ; destruction flag is not set, or 10 if it is (10 being
                        ; the number of characters in the " DESTROYED" token)

 LDA MCH                ; Call TT27 to print the token in MCH into the buffer
 JSR TT27               ; (this doesn't print it on-screen, it just puts it into
                        ; the buffer and moves the DTW5 pointer along, so DTW5
                        ; now contains the size of the message we want to print,
                        ; including the " DESTROYED" part if that's going to be
                        ; included)

 LDA #32                ; Set A = (32 - DTW5) / 2
 SEC                    ;
 SBC DTW5               ; so A now contains the column number we need to print
 LSR A                  ; our message at for it to be centred on-screen (as
                        ; there are 32 columns)

 STA messXC             ; Store A in messXC, so when we erase the message via
                        ; the branch to me1 above, messXC will tell us where to
                        ; print it

 STA XC                 ; Move the text cursor to column messXC

 JSR MT15               ; Call MT15 to switch to left-aligned text when printing
                        ; extended tokens disabling the justify text setting we
                        ; set above

 LDA MCH                ; Set MCH to the token we are about to display

                        ; Fall through into mes9 to print the token in A

; ******************************************************************************
;
;       Name: mes9
;       Type: Subroutine
;   Category: Flight
;    Summary: Print a text token, possibly followed by " DESTROYED"
;
; ------------------------------------------------------------------------------
;
; Print a text token, followed by " DESTROYED" if the destruction flag is set
; (for when a piece of equipment is destroyed).
;
; ******************************************************************************

.mes9

 JSR TT27               ; Call TT27 to print the text token in A

 LSR de                 ; If bit 0 of variable de is clear, return from the
 BCC out                ; subroutine (as out contains an RTS)

 LDA #253               ; Print recursive token 93 (" DESTROYED") and return
 JMP TT27               ; from the subroutine using a tail call

; ******************************************************************************
;
;       Name: OUCH
;       Type: Subroutine
;   Category: Flight
;    Summary: Potentially lose cargo or equipment following damage
;
; ------------------------------------------------------------------------------
;
; Our shields are dead and we are taking damage, so there is a small chance of
; losing cargo or equipment.
;
; ******************************************************************************

.OUCH

 JSR DORND              ; Set A and X to random numbers

 BMI out                ; If A < 0 (50% chance), return from the subroutine
                        ; (as out contains an RTS)

 CPX #22                ; If X >= 22 (91% chance), return from the subroutine
 BCS out                ; (as out contains an RTS)

 LDA QQ20,X             ; If we do not have any of item QQ20+X, return from the
 BEQ out                ; subroutine (as out contains an RTS). X is in the range
                        ; 0-21, so this not only checks for cargo, but also for
                        ; E.C.M., fuel scoops, energy bomb, energy unit and
                        ; docking computer, all of which can be destroyed

 LDA DLY                ; If there is already an in-flight message on-screen,
 BNE out                ; return from the subroutine (as out contains an RTS)

 LDY #3                 ; Set bit 1 of de, the equipment destruction flag, so
 STY de                 ; that when we call MESS below, " DESTROYED" is appended
                        ; to the in-flight message

 STA QQ20,X             ; A is 0 (as we didn't branch with the BNE above), so
                        ; this sets QQ20+X to 0, which destroys any cargo or
                        ; equipment we have of that type

 CPX #17                ; If X >= 17 then we just lost a piece of equipment, so
 BCS ou1                ; jump to ou1 to print the relevant message

 TXA                    ; Print recursive token 48 + A as an in-flight token,
 ADC #208               ; which will be in the range 48 ("FOOD") to 64 ("ALIEN
 JMP MESS               ; ITEMS") as the C flag is clear, so this prints the
                        ; destroyed item's name, followed by " DESTROYED" (as we
                        ; set bit 1 of the de flag above), and returns from the
                        ; subroutine using a tail call

.ou1

 BEQ ou2                ; If X = 17, jump to ou2 to print "E.C.M.SYSTEM
                        ; DESTROYED" and return from the subroutine using a tail
                        ; call

 CPX #18                ; If X = 18, jump to ou3 to print "FUEL SCOOPS
 BEQ ou3                ; DESTROYED" and return from the subroutine using a tail
                        ; call

 TXA                    ; Otherwise X is in the range 19 to 21 and the C flag is
 ADC #113-20            ; set (as we got here via a BCS to ou1), so we set A as
                        ; follows:
                        ;
                        ;   A = 113 - 20 + X + C
                        ;     = 113 - 19 + X
                        ;     = 113 to 115

 JMP MESS               ; Print recursive token A ("ENERGY BOMB", "ENERGY UNIT"
                        ; or "DOCKING COMPUTERS") as an in-flight message,
                        ; followed by " DESTROYED", and return from the
                        ; subroutine using a tail call

; ******************************************************************************
;
;       Name: ou2
;       Type: Subroutine
;   Category: Flight
;    Summary: Display "E.C.M.SYSTEM DESTROYED" as an in-flight message
;
; ******************************************************************************

.ou2

 LDA #108               ; Set A to recursive token 108 ("E.C.M.SYSTEM")

 JMP MESS               ; Print recursive token A as an in-flight message,
                        ; followed by " DESTROYED", and return from the
                        ; subroutine using a tail call

; ******************************************************************************
;
;       Name: ou3
;       Type: Subroutine
;   Category: Flight
;    Summary: Display "FUEL SCOOPS DESTROYED" as an in-flight message
;
; ******************************************************************************

.ou3

 LDA #111               ; Set A to recursive token 111 ("FUEL SCOOPS")

 JMP MESS               ; Print recursive token A as an in-flight message,
                        ; followed by " DESTROYED", and return from the
                        ; subroutine using a tail call

; ******************************************************************************
;
;       Name: ITEM
;       Type: Macro
;   Category: Market
;    Summary: Macro definition for the market prices table
;  Deep dive: Market item prices and availability
;
; ------------------------------------------------------------------------------
;
; The following macro is used to build the market prices table:
;
;   ITEM price, factor, units, quantity, mask
;
; It inserts an item into the market prices table at QQ23. See the deep dive on
; "Market item prices and availability" for more information on how the market
; system works.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   price               Base price
;
;   factor              Economic factor
;
;   units               Units: "t", "g" or "k"
;
;   quantity            Base quantity
;
;   mask                Fluctuations mask
;
; ******************************************************************************

MACRO ITEM price, factor, units, quantity, mask

 IF factor < 0
  s = 1 << 7
 ELSE
  s = 0
 ENDIF

 IF units = 't'
  u = 0
 ELIF units = 'k'
  u = 1 << 5
 ELSE
  u = 1 << 6
 ENDIF

 e = ABS(factor)

 EQUB price
 EQUB s + u + e
 EQUB quantity
 EQUB mask

ENDMACRO

; ******************************************************************************
;
;       Name: QQ23
;       Type: Variable
;   Category: Market
;    Summary: Market prices table
;
; ------------------------------------------------------------------------------
;
; Each item has four bytes of data, like this:
;
;   Byte #0 = Base price
;   Byte #1 = Economic factor in bits 0-4, with the sign in bit 7
;             Unit in bits 5-6
;   Byte #2 = Base quantity
;   Byte #3 = Mask to control price fluctuations
;
; To make it easier for humans to follow, we've defined a macro called ITEM
; that takes the following arguments and builds the four bytes for us:
;
;   ITEM base price, economic factor, units, base quantity, mask
;
; So for food, we have the following:
;
;   * Base price = 19
;   * Economic factor = -2
;   * Unit = tonnes
;   * Base quantity = 6
;   * Mask = %00000001
;
; ******************************************************************************

.QQ23

 ITEM 19,  -2, 't',   6, %00000001  ;  0 = Food
 ITEM 20,  -1, 't',  10, %00000011  ;  1 = Textiles
 ITEM 65,  -3, 't',   2, %00000111  ;  2 = Radioactives
 ITEM 40,  -5, 't', 226, %00011111  ;  3 = Slaves
 ITEM 83,  -5, 't', 251, %00001111  ;  4 = Liquor/Wines
 ITEM 196,  8, 't',  54, %00000011  ;  5 = Luxuries
 ITEM 235, 29, 't',   8, %01111000  ;  6 = Narcotics
 ITEM 154, 14, 't',  56, %00000011  ;  7 = Computers
 ITEM 117,  6, 't',  40, %00000111  ;  8 = Machinery
 ITEM 78,   1, 't',  17, %00011111  ;  9 = Alloys
 ITEM 124, 13, 't',  29, %00000111  ; 10 = Firearms
 ITEM 176, -9, 't', 220, %00111111  ; 11 = Furs
 ITEM 32,  -1, 't',  53, %00000011  ; 12 = Minerals
 ITEM 97,  -1, 'k',  66, %00000111  ; 13 = Gold

;EQUD &360A118          ; This data is commented out in the original source

 ITEM 171, -2, 'k',  55, %00011111  ; 14 = Platinum
 ITEM 45,  -1, 'g', 250, %00001111  ; 15 = Gem-Stones
 ITEM 53,  15, 't', 192, %00000111  ; 16 = Alien items

; ******************************************************************************
;
;       Name: TIDY
;       Type: Subroutine
;   Category: Maths (Geometry)
;    Summary: Orthonormalise the orientation vectors for a ship
;  Deep dive: Tidying orthonormal vectors
;             Orientation vectors
;
; ------------------------------------------------------------------------------
;
; This routine orthonormalises the orientation vectors for a ship. This means
; making the three orientation vectors orthogonal (perpendicular to each other),
; and normal (so each of the vectors has length 1).
;
; We do this because we use the small angle approximation to rotate these
; vectors in space. It is not completely accurate, so the three vectors tend
; to get stretched over time, so periodically we tidy the vectors with this
; routine to ensure they remain as orthonormal as possible.
;
; ******************************************************************************

.TI2

                        ; Called from below with A = 0, X = 0, Y = 4 when
                        ; nosev_x and nosev_y are small, so we assume that
                        ; nosev_z is big

 TYA                    ; A = Y = 4
 LDY #2
 JSR TIS3               ; Call TIS3 with X = 0, Y = 2, A = 4, to set roofv_z =
 STA INWK+20            ; -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z

 JMP TI3                ; Jump to TI3 to keep tidying

.TI1

                        ; Called from below with A = 0, Y = 4 when nosev_x is
                        ; small

 TAX                    ; Set X = A = 0

 LDA XX15+1             ; Set A = nosev_y, and if the top two magnitude bits
 AND #%01100000         ; are both clear, jump to TI2 with A = 0, X = 0, Y = 4
 BEQ TI2

 LDA #2                 ; Otherwise nosev_y is big, so set up the index values
                        ; to pass to TIS3

 JSR TIS3               ; Call TIS3 with X = 0, Y = 4, A = 2, to set roofv_y =
 STA INWK+18            ; -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y

 JMP TI3                ; Jump to TI3 to keep tidying

.TIDY

 LDA INWK+10            ; Set (XX15, XX15+1, XX15+2) = nosev
 STA XX15
 LDA INWK+12
 STA XX15+1
 LDA INWK+14
 STA XX15+2

 JSR NORM               ; Call NORM to normalise the vector in XX15, i.e. nosev

 LDA XX15               ; Set nosev = (XX15, XX15+1, XX15+2)
 STA INWK+10
 LDA XX15+1
 STA INWK+12
 LDA XX15+2
 STA INWK+14

 LDY #4                 ; Set Y = 4

 LDA XX15               ; Set A = nosev_x, and if the top two magnitude bits
 AND #%01100000         ; are both clear, jump to TI1 with A = 0, Y = 4
 BEQ TI1

 LDX #2                 ; Otherwise nosev_x is big, so set up the index values
 LDA #0                 ; to pass to TIS3

 JSR TIS3               ; Call TIS3 with X = 2, Y = 4, A = 0, to set roofv_x =
 STA INWK+16            ; -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x

.TI3

 LDA INWK+16            ; Set (XX15, XX15+1, XX15+2) = roofv
 STA XX15
 LDA INWK+18
 STA XX15+1
 LDA INWK+20
 STA XX15+2

 JSR NORM               ; Call NORM to normalise the vector in XX15, i.e. roofv

 LDA XX15               ; Set roofv = (XX15, XX15+1, XX15+2)
 STA INWK+16
 LDA XX15+1
 STA INWK+18
 LDA XX15+2
 STA INWK+20

 LDA INWK+12            ; Set Q = nosev_y
 STA Q

 LDA INWK+20            ; Set A = roofv_z

 JSR MULT12             ; Set (S R) = Q * A = nosev_y * roofv_z

 LDX INWK+14            ; Set X = nosev_z

 LDA INWK+18            ; Set A = roofv_y

 JSR TIS1               ; Set (A ?) = (-X * A + (S R)) / 96
                        ;        = (-nosev_z * roofv_y + nosev_y * roofv_z) / 96
                        ;
                        ; This also sets Q = nosev_z

 EOR #%10000000         ; Set sidev_x = -A
 STA INWK+22            ;        = (nosev_z * roofv_y - nosev_y * roofv_z) / 96

 LDA INWK+16            ; Set A = roofv_x

 JSR MULT12             ; Set (S R) = Q * A = nosev_z * roofv_x

 LDX INWK+10            ; Set X = nosev_x

 LDA INWK+20            ; Set A = roofv_z

 JSR TIS1               ; Set (A ?) = (-X * A + (S R)) / 96
                        ;        = (-nosev_x * roofv_z + nosev_z * roofv_x) / 96
                        ;
                        ; This also sets Q = nosev_x

 EOR #%10000000         ; Set sidev_y = -A
 STA INWK+24            ;        = (nosev_x * roofv_z - nosev_z * roofv_x) / 96

 LDA INWK+18            ; Set A = roofv_y

 JSR MULT12             ; Set (S R) = Q * A = nosev_x * roofv_y

 LDX INWK+12            ; Set X = nosev_y

 LDA INWK+16            ; Set A = roofv_x

 JSR TIS1               ; Set (A ?) = (-X * A + (S R)) / 96
                        ;        = (-nosev_y * roofv_x + nosev_x * roofv_y) / 96

 EOR #%10000000         ; Set sidev_z = -A
 STA INWK+26            ;        = (nosev_y * roofv_x - nosev_x * roofv_y) / 96

 LDA #0                 ; Set A = 0 so we can clear the low bytes of the
                        ; orientation vectors

 LDX #14                ; We want to clear the low bytes, so start from sidev_y
                        ; at byte #9+14 (we clear all except sidev_z_lo, though
                        ; I suspect this is in error and that X should be 16)

.TIL1

 STA INWK+9,X           ; Set the low byte in byte #9+X to zero

 DEX                    ; Set X = X - 2 to jump down to the next low byte
 DEX

 BPL TIL1               ; Loop back until we have zeroed all the low bytes

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TIS2
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate A = A / Q
;  Deep dive: Shift-and-subtract division
;
; ------------------------------------------------------------------------------
;
; Calculate the following division, where A is a sign-magnitude number and Q is
; a positive integer:
;
;   A = A / Q
;
; The value of A is returned as a sign-magnitude number with 96 representing 1,
; and the maximum value returned is 1 (i.e. 96). This routine is used when
; normalising vectors, where we represent fractions using integers, so this
; gives us an approximation to two decimal places.
;
; ******************************************************************************

.TIS2

 TAY                    ; Store the argument A in Y

 AND #%01111111         ; Strip the sign bit from the argument, so A = |A|

 CMP Q                  ; If A >= Q then jump to TI4 to return a 1 with the
 BCS TI4                ; correct sign

 LDX #%11111110         ; Set T to have bits 1-7 set, so we can rotate through 7
 STX T                  ; loop iterations, getting a 1 each time, and then
                        ; getting a 0 on the 8th iteration... and we can also
                        ; use T to catch our result bits into bit 0 each time

.TIL2

 ASL A                  ; Shift A to the left

 CMP Q                  ; If A < Q skip the following subtraction
 BCC P%+4

 SBC Q                  ; A >= Q, so set A = A - Q
                        ;
                        ; Going into this subtraction we know the C flag is
                        ; set as we passed through the BCC above, and we also
                        ; know that A >= Q, so the C flag will still be set once
                        ; we are done

 ROL T                  ; Rotate the counter in T to the left, and catch the
                        ; result bit into bit 0 (which will be a 0 if we didn't
                        ; do the subtraction, or 1 if we did)

 BCS TIL2               ; If we still have set bits in T, loop back to TIL2 to
                        ; do the next iteration of 7

                        ; We've done the division and now have a result in the
                        ; range 0-255 here, which we need to reduce to the range
                        ; 0-96. We can do that by multiplying the result by 3/8,
                        ; as 256 * 3/8 = 96

 LDA T                  ; Set T = T / 4
 LSR A
 LSR A
 STA T

 LSR A                  ; Set T = T / 8 + T / 4
 ADC T                  ;       = 3T / 8
 STA T

 TYA                    ; Fetch the sign bit of the original argument A
 AND #%10000000

 ORA T                  ; Apply the sign bit to T

 RTS                    ; Return from the subroutine

.TI4

 TYA                    ; Fetch the sign bit of the original argument A
 AND #%10000000

 ORA #96                ; Apply the sign bit to 96 (which represents 1)

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: TIS3
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate -(nosev_1 * roofv_1 + nosev_2 * roofv_2) / nosev_3
;
; ------------------------------------------------------------------------------
;
; Calculate the following expression:
;
;   A = -(nosev_1 * roofv_1 + nosev_2 * roofv_2) / nosev_3
;
; where 1, 2 and 3 are x, y, or z, depending on the values of X, Y and A. This
; routine is called with the following values:
;
;   X = 0, Y = 2, A = 4 ->
;         A = -(nosev_x * roofv_x + nosev_y * roofv_y) / nosev_z
;
;   X = 0, Y = 4, A = 2 ->
;         A = -(nosev_x * roofv_x + nosev_z * roofv_z) / nosev_y
;
;   X = 2, Y = 4, A = 0 ->
;         A = -(nosev_y * roofv_y + nosev_z * roofv_z) / nosev_x
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   X                   Index 1 (0 = x, 2 = y, 4 = z)
;
;   Y                   Index 2 (0 = x, 2 = y, 4 = z)
;
;   A                   Index 3 (0 = x, 2 = y, 4 = z)
;
; ******************************************************************************

.TIS3

 STA P+2                ; Store P+2 in A for later

 LDA INWK+10,X          ; Set Q = nosev_x_hi (plus X)
 STA Q

 LDA INWK+16,X          ; Set A = roofv_x_hi (plus X)

 JSR MULT12             ; Set (S R) = Q * A
                        ;           = nosev_x_hi * roofv_x_hi

 LDX INWK+10,Y          ; Set Q = nosev_x_hi (plus Y)
 STX Q

 LDA INWK+16,Y          ; Set A = roofv_x_hi (plus Y)

 JSR MAD                ; Set (A X) = Q * A + (S R)
                        ;           = (nosev_x,X * roofv_x,X) +
                        ;             (nosev_x,Y * roofv_x,Y)

 STX P                  ; Store low byte of result in P, so result is now in
                        ; (A P)

 LDY P+2                ; Set Q = roofv_x_hi (plus argument A)
 LDX INWK+10,Y
 STX Q

 EOR #%10000000         ; Flip the sign of A

                        ; Fall through into DIVDT to do:
                        ;
                        ;   (P+1 A) = (A P) / Q
                        ;
                        ;     = -((nosev_x,X * roofv_x,X) +
                        ;         (nosev_x,Y * roofv_x,Y))
                        ;       / nosev_x,A

; ******************************************************************************
;
;       Name: DVIDT
;       Type: Subroutine
;   Category: Maths (Arithmetic)
;    Summary: Calculate (P+1 A) = (A P) / Q
;
; ------------------------------------------------------------------------------
;
; Calculate the following integer division between sign-magnitude numbers:
;
;   (P+1 A) = (A P) / Q
;
; This uses the same shift-and-subtract algorithm as TIS2.
;
; ******************************************************************************

.DVIDT

 STA P+1                ; Set P+1 = A, so P(1 0) = (A P)

 EOR Q                  ; Set T = the sign bit of A EOR Q, so it's 1 if A and Q
 AND #%10000000         ; have different signs, i.e. it's the sign of the result
 STA T                  ; of A / Q

 LDA #0                 ; Set A = 0 for us to build a result

 LDX #16                ; Set a counter in X to count the 16 bits in P(1 0)

 ASL P                  ; Shift P(1 0) left
 ROL P+1

 ASL Q                  ; Clear the sign bit of Q the C flag at the same time
 LSR Q

.DVL2

 ROL A                  ; Shift A to the left

 CMP Q                  ; If A < Q skip the following subtraction
 BCC P%+4

 SBC Q                  ; Set A = A - Q
                        ;
                        ; Going into this subtraction we know the C flag is
                        ; set as we passed through the BCC above, and we also
                        ; know that A >= Q, so the C flag will still be set once
                        ; we are done

 ROL P                  ; Rotate P(1 0) to the left, and catch the result bit
 ROL P+1                ; into the C flag (which will be a 0 if we didn't
                        ; do the subtraction, or 1 if we did)

 DEX                    ; Decrement the loop counter

 BNE DVL2               ; Loop back for the next bit until we have done all 16
                        ; bits of P(1 0)

 LDA P                  ; Set A = P so the low byte is in the result in A

 ORA T                  ; Set A to the correct sign bit that we set in T above

.itsoff

 RTS                    ; Return from the subroutine

; ******************************************************************************
;
;       Name: KTRAN
;       Type: Variable
;   Category: Keyboard
;    Summary: An unused key logger buffer that's left over from the 6502 Second
;             Procsessor version of Elite
;
; ******************************************************************************

.buf

 EQUB 2                 ; Transmit 2 bytes as part of this command

 EQUB 15                ; Receive 15 bytes as part of this command

.KTRAN

 EQUS "1234567890"      ; A 17-byte buffer to hold the key logger data from the
 EQUS "1234567"         ; KEYBOARD routine in the I/O processor (note that only
                        ; 12 of these bytes are actually updated by the KEYBOARD
                        ; routine)

; ******************************************************************************
;
; Save ELTF.bin
;
; ******************************************************************************

 PRINT "ELITE F"
 PRINT "Assembled at ", ~CODE_F%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_F%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_F%

 PRINT "S.ELTF ", ~CODE_F%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_F%
 SAVE "3-assembled-output/ELTF.bin", CODE_F%, P%, LOAD%

; ******************************************************************************
;
; ELITE G FILE
;
; Produces the binary file ELTG.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_G% = P%

 LOAD_G% = LOAD% + P% - CODE%

.SHPPT

 JSR PROJ
 ORA K3+1
 BNE nono
 LDA K4
 CMP #Y*2-2
 BCS nono
 JSR Shpt
 LDA K4
 CLC
 ADC #1
 JSR Shpt
 LDA #8
 ORA XX1+31
 STA XX1+31
 JMP LSCLR

.nono

 lda #$F7
 and XX1+31
 sta XX1+31
 JMP LSCLR

.Shpt

 STA XX15+1
 STA XX15+3
 LDA K3
 STA XX15
 CLC
 ADC #3
 BCC P%+4
 LDA #$FF
 STA XX15+2
 JMP LSPUT

.LL5

 \2BSQRT Q = SQR(RQ)
 LDY R
 LDA Q
 STA S
 LDX #0
 STX Q
 LDA #8
 STA T

.LL6

 CPX Q
 BCC LL7
 BNE P%+6
 CPY #$40
 BCC LL7
 TYA
 SBC #$40
 TAY
 TXA
 SBC Q
 TAX

.LL7

 ROL Q
 ASL S
 TYA
 ROL A
 TAY
 TXA
 ROL A
 TAX
 ASL S
 TYA
 ROL A
 TAY
 TXA
 ROL A
 TAX
 DEC T
 BNE LL6
 RTS

.LL28

 \BFRDIV R = A*256/Q
 CMP Q
 BCS LL2
 STA widget
 TAX
 BEQ LLfix
 LDA logL,X
 LDX Q
 SEC
 SBC logL,X
 LDX widget
 LDA log,X
 LDX Q
 SBC log,X
 BCS LL2
 TAX
 LDA alogh,X

.LLfix

 STA R
 RTS
 \LL28 CMPQ
 BCS LL2
 LDX #254
 STX R

.LL31

 ASL A
 BCS LL29
 CMP Q
 BCC P%+4
 SBC Q
 ROL R
 BCS LL31
 RTS

.LL29

 SBC Q
 SEC
 ROL R
 BCS LL31
 LDA R
 RTS

.LL2

 LDA #$FF
 STA R
 RTS

.LL38

 \BADD(S)A = R+Q(SA)
 EOR S
 BMI LL39
 LDA Q
 CLC
 ADC R
 RTS

.LL39

 LDA R
 SEC
 SBC Q
 BCC LL40
 CLC
 RTS

.LL40

 PHA
 LDA S
 EOR #128
 STA S
 PLA
 EOR #255
 ADC #1
 RTS

.LL51

 \XX12 = XX15.XX16
 LDX #0
 LDY #0

.ll51

 LDA XX15
 STA Q
 LDA XX16,X
 JSR FMLTU
 STA T
 LDA XX15+1
 EOR XX16+1,X
 STA S
 LDA XX15+2
 STA Q
 LDA XX16+2,X
 JSR FMLTU
 STA Q
 LDA T
 STA R
 LDA XX15+3
 EOR XX16+3,X
 JSR LL38
 STA T
 LDA XX15+4
 STA Q
 LDA XX16+4,X
 JSR FMLTU
 STA Q
 LDA T
 STA R
 LDA XX15+5
 EOR XX16+5,X
 JSR LL38
 STA XX12,Y
 LDA S
 STA XX12+1,Y
 INY
 INY
 TXA
 CLC
 ADC #6
 TAX
 CMP #17
 BCC ll51
 RTS

.LL25

 JMP PLANET 

.LL9

 \ENTRY
 LDA TYPE
 BMI LL25
 LDA #31
 STA XX4
 LDY #1
 STY LSNUM
 DEY
 LDA #8
 BIT XX1+31
 BNE P%+5
 LDA #0
 EQUB $2C
 LDA (XX19),Y
 STA LSNUM2
 LDA NEWB
 BMI EE51
 LDA #32
 BIT XX1+31
 BNE EE28
 BPL EE28
 \Initiate explosion
 ORA XX1+31
 AND #$3F
 STA XX1+31
 LDA #0
 LDY #28
 STA (INF),Y
 LDY #30
 STA (INF),Y
 JSR EE51
 LDY #1
 LDA #18
 STA (XX19),Y
 LDY #7
 LDA (XX0),Y
 LDY #2
 STA (XX19),Y

.EE55

 INY
 JSR DORND
 STA (XX19),Y
 CPY #6
 BNE EE55

.EE28

 LDA XX1+8

.EE49

 BPL LL10

.LL14

 LDA XX1+31
 AND #32
 BEQ EE51
 LDA XX1+31
 AND #$F7
 STA XX1+31
 JMP DOEXP

.EE51

 LDA #8
 BIT XX1+31
 BEQ LL10-1
 EOR XX1+31
 STA XX1+31
 JMP LSCLR
 RTS

.LL10

 LDA XX1+7
 CMP #$C0
 BCS LL14
 LDA XX1
 CMP XX1+6
 LDA XX1+1
 SBC XX1+7
 BCS LL14
 LDA XX1+3
 CMP XX1+6
 LDA XX1+4
 SBC XX1+7
 BCS LL14
 LDY #6
 LDA (XX0),Y
 TAX
 LDA #255
 STA XX3,X
 STA XX3+1,X
 LDA XX1+6
 STA T
 LDA XX1+7
 LSR A
 ROR T
 LSR A
 ROR T
 LSR A
 ROR T
 LSR A
 BNE LL13
 LDA T
 ROR A
 LSR A
 LSR A
 LSR A
 STA XX4
 BPL LL17

.LL13

 LDY #13
 LDA (XX0),Y
 CMP XX1+7
 BCS LL17
 LDA #32
 AND XX1+31
 BNE LL17
 JMP SHPPT

.LL17

 LDX #5

.LL15

 LDA XX1+21,X
 STA XX16,X
 LDA XX1+15,X
 STA XX16+6,X
 LDA XX1+9,X
 STA XX16+12,X
 DEX
 BPL LL15
 LDA #197 ;NORM
 STA Q
 LDY #16

.LL21

 LDA XX16,Y
 ASL A
 LDA XX16+1,Y
 ROL A
 JSR LL28
 LDX R
 STX XX16,Y
 DEY
 DEY
 BPL LL21
 LDX #8

.ll91

 LDA XX1,X
 STA XX18,X
 DEX
 BPL ll91
 LDA #255
 STA XX2+15
 LDY #12
 LDA XX1+31
 AND #32
 BEQ EE29
 LDA (XX0),Y
 LSR A
 LSR A
 TAX
 LDA #$FF

.EE30

 STA XX2,X
 DEX
 BPL EE30
 INX
 STX XX4

.LL41

 JMP LL42

.EE29

 LDA (XX0),Y
 BEQ LL41
 STA XX20
 \DtProd^XX2
 LDY #18
 LDA (XX0),Y
 TAX
 LDA XX18+7

.LL90

 TAY
 BEQ LL91
 INX
 LSR XX18+4
 ROR XX18+3
 LSR XX18+1
 ROR XX18
 LSR A
 ROR XX18+6
 TAY
 BNE LL90+3

.LL91

 STX XX17
 LDA XX18+8
 STA XX15+5
 LDA XX18
 STA XX15
 LDA XX18+2
 STA XX15+1
 LDA XX18+3
 STA XX15+2
 LDA XX18+5
 STA XX15+3
 LDA XX18+6
 STA XX15+4
 JSR LL51
 LDA XX12
 STA XX18
 LDA XX12+1
 STA XX18+2
 LDA XX12+2
 STA XX18+3
 LDA XX12+3
 STA XX18+5
 LDA XX12+4
 STA XX18+6
 LDA XX12+5
 STA XX18+8
 LDY #4
 LDA (XX0),Y
 CLC
 ADC XX0
 STA V
 LDY #17
 LDA (XX0),Y
 ADC XX0+1
 STA V+1
 LDY #0

.LL86

 LDA (V),Y
 STA XX12+1
 AND #31
 CMP XX4
 BCS LL87
 TYA
 LSR A
 LSR A
 TAX
 LDA #255
 STA XX2,X
 TYA
 ADC #4
 TAY
 JMP LL88

.LL87

 LDA XX12+1
 ASL A
 STA XX12+3
 ASL A
 STA XX12+5
 INY
 LDA (V),Y
 STA XX12
 INY
 LDA (V),Y
 STA XX12+2
 INY
 LDA (V),Y
 STA XX12+4
 LDX XX17
 CPX #4
 BCC LL92

.LL143

 \Fce ofst<<PV
 LDA XX18
 STA XX15
 LDA XX18+2
 STA XX15+1
 LDA XX18+3
 STA XX15+2
 LDA XX18+5
 STA XX15+3
 LDA XX18+6
 STA XX15+4
 LDA XX18+8
 STA XX15+5
 JMP LL89

.ovflw

 LSR XX18
 LSR XX18+6
 LSR XX18+3
 LDX #1

.LL92

 LDA XX12
 STA XX15
 LDA XX12+2
 STA XX15+2
 LDA XX12+4

.LL93

 DEX
 BMI LL94
 LSR XX15
 LSR XX15+2
 LSR A
 DEX
 BPL LL93+3

.LL94

 STA R
 LDA XX12+5
 STA S
 LDA XX18+6
 STA Q
 LDA XX18+8
 JSR LL38
 BCS ovflw
 STA XX15+4
 LDA S
 STA XX15+5
 LDA XX15
 STA R
 LDA XX12+1
 STA S
 LDA XX18
 STA Q
 LDA XX18+2
 JSR LL38
 BCS ovflw
 STA XX15
 LDA S
 STA XX15+1
 LDA XX15+2
 STA R
 LDA XX12+3
 STA S
 LDA XX18+3
 STA Q
 LDA XX18+5
 JSR LL38
 BCS ovflw
 STA XX15+2
 LDA S
 STA XX15+3

.LL89

 LDA XX12
 STA Q
 LDA XX15
 JSR FMLTU
 STA T
 LDA XX12+1
 EOR XX15+1
 STA S
 LDA XX12+2
 STA Q
 LDA XX15+2
 JSR FMLTU
 STA Q
 LDA T
 STA R
 LDA XX12+3
 EOR XX15+3
 JSR LL38
 STA T
 LDA XX12+4
 STA Q
 LDA XX15+4
 JSR FMLTU
 STA Q
 LDA T
 STA R
 LDA XX15+5
 EOR XX12+5
 JSR LL38
 PHA
 TYA
 LSR A
 LSR A
 TAX
 PLA
 BIT S
 BMI P%+4
 LDA #0
 STA XX2,X
 INY

.LL88

 CPY XX20
 BCS LL42
 JMP LL86

.LL42

 \ndeX-Ycrds
 \TrnspMat
 LDY XX16+2
 LDX XX16+3
 LDA XX16+6
 STA XX16+2
 LDA XX16+7
 STA XX16+3
 STY XX16+6
 STX XX16+7
 LDY XX16+4
 LDX XX16+5
 LDA XX16+12
 STA XX16+4
 LDA XX16+13
 STA XX16+5
 STY XX16+12
 STX XX16+13
 LDY XX16+10
 LDX XX16+11
 LDA XX16+14
 STA XX16+10
 LDA XX16+15
 STA XX16+11
 STY XX16+14
 STX XX16+15
 LDY #8
 LDA (XX0),Y
 STA XX20
 LDA XX0
 CLC
 ADC #20
 STA V
 LDA XX0+1
 ADC #0
 STA V+1
 LDY #0
 STY CNT

.LL48

 STY XX17
 LDA (V),Y
 STA XX15
 INY
 LDA (V),Y
 STA XX15+2
 INY
 LDA (V),Y
 STA XX15+4
 INY
 LDA (V),Y
 STA T
 AND #31
 CMP XX4
 BCC LL49-3
 INY
 LDA (V),Y
 STA P
 AND #15
 TAX
 LDA XX2,X
 BNE LL49
 LDA P
 LSR A
 LSR A
 LSR A
 LSR A
 TAX
 LDA XX2,X
 BNE LL49
 INY
 LDA (V),Y
 STA P
 AND #15
 TAX
 LDA XX2,X
 BNE LL49
 LDA P
 LSR A
 LSR A
 LSR A
 LSR A
 TAX
 LDA XX2,X
 BNE LL49
 JMP LL50

.LL49

 LDA T
 STA XX15+1
 ASL A
 STA XX15+3
 ASL A
 STA XX15+5
 JSR LL51
 LDA XX1+2
 STA XX15+2
 EOR XX12+1
 BMI LL52
 CLC
 LDA XX12
 ADC XX1
 STA XX15
 LDA XX1+1
 ADC #0
 STA XX15+1
 JMP LL53

.LL52

 LDA XX1
 SEC
 SBC XX12
 STA XX15
 LDA XX1+1
 SBC #0
 STA XX15+1
 BCS LL53
 EOR #$FF
 STA XX15+1
 LDA #1
 SBC XX15
 STA XX15
 BCC P%+4
 INC XX15+1
 LDA XX15+2
 EOR #128
 STA XX15+2

.LL53

 LDA XX1+5
 STA XX15+5
 EOR XX12+3
 BMI LL54
 CLC
 LDA XX12+2
 ADC XX1+3
 STA XX15+3
 LDA XX1+4
 ADC #0
 STA XX15+4
 JMP LL55

.LL54

 LDA XX1+3
 SEC
 SBC XX12+2
 STA XX15+3
 LDA XX1+4
 SBC #0
 STA XX15+4
 BCS LL55
 EOR #255
 STA XX15+4
 LDA XX15+3
 EOR #255
 ADC #1
 STA XX15+3
 LDA XX15+5
 EOR #128
 STA XX15+5
 BCC LL55
 INC XX15+4

.LL55

 LDA XX12+5
 BMI LL56
 LDA XX12+4
 CLC
 ADC XX1+6
 STA T
 LDA XX1+7
 ADC #0
 STA U
 JMP LL57

.LL61

 LDX Q
 BEQ LL84
 LDX #0

.LL63

 LSR A
 INX
 CMP Q
 BCS LL63
 STX S
 JSR LL28
 LDX S
 LDA R

.LL64

 ASL A
 ROL U
 BMI LL84
 DEX
 BNE LL64
 STA R
 RTS

.LL84

 LDA #50
 STA R
 STA U
 RTS

.LL62

 LDA #128
 SEC
 SBC R
 STA XX3,X
 INX
 LDA #0
 SBC U
 STA XX3,X
 JMP LL66

.LL56

 LDA XX1+6
 SEC
 SBC XX12+4
 STA T
 LDA XX1+7
 SBC #0
 STA U
 BCC LL140
 BNE LL57
 LDA T
 CMP #4
 BCS LL57

.LL140

 LDA #0
 STA U
 LDA #4
 STA T

.LL57

 LDA U
 ORA XX15+1
 ORA XX15+4
 BEQ LL60
 LSR XX15+1
 ROR XX15
 LSR XX15+4
 ROR XX15+3
 LSR U
 ROR T
 JMP LL57

.LL60

 LDA T
 STA Q
 LDA XX15
 CMP Q
 BCC LL69
 JSR LL61
 JMP LL69+3

.LL69

 JSR LL28
 LDX CNT
 LDA XX15+2
 BMI LL62
 LDA R
 CLC
 ADC #128
 STA XX3,X
 INX
 LDA U
 ADC #0
 STA XX3,X

.LL66

 TXA
 PHA
 LDA #0
 STA U
 LDA T
 STA Q
 LDA XX15+3
 CMP Q
 BCC LL67
 JSR LL61
 JMP LL68

.LL70

 LDA #Y
 CLC
 ADC R
 STA XX3,X
 INX
 LDA #0
 ADC U
 STA XX3,X
 JMP LL50

.LL67

 JSR LL28

.LL68

 PLA
 TAX
 INX
 LDA XX15+5
 BMI LL70
 LDA #Y
 SEC
 SBC R
 STA XX3,X
 INX
 LDA #0
 SBC U
 STA XX3,X

.LL50

 CLC
 LDA CNT
 ADC #4
 STA CNT
 LDA XX17
 ADC #6
 TAY
 BCS LL72
 CMP XX20
 BCS LL72
 JMP LL48 

.LL72

 LDA XX1+31
 AND #32
 BEQ EE31
 LDA XX1+31
 ORA #8
 STA XX1+31
 JMP DOEXP

.EE31

 LDY #9
 LDA (XX0),Y
 STA XX20
 LDA #8
 ORA XX1+31
 STA XX1+31
 LDY #0
;STY LSNUM
 STY XX17
 BIT XX1+31
 BVC LL170
 LDA XX1+31
 AND #$BF
 STA XX1+31
 LDY #6
 LDA (XX0),Y
 TAY
 LDX XX3,Y
 STX XX15
 INX
 BEQ LL170
 LDX XX3+1,Y
 STX XX15+1
 INX
 BEQ LL170
 LDX XX3+2,Y
 STX XX15+2
 LDX XX3+3,Y
 STX XX15+3
 LDA #0
 STA XX15+4
 STA XX15+5
 STA XX12+1
 LDA XX1+6
 STA XX12
 LDA XX1+2
 BPL P%+4
 DEC XX15+4
 JSR CLIP
 BCS LL170
 JSR LSPUT

.LL170

 \
 \ Calculate new lines
 LDY #3
 CLC
 LDA (XX0),Y
 ADC XX0
 STA V
 LDY #16
 LDA (XX0),Y
 ADC XX0+1
 STA V+1
 LDY #5
 LDA (XX0),Y
 STA CNT

.LL75

 LDY #0
 LDA (V),Y
 CMP XX4
 BCC LL78 ;Priority
 INY
 LDA (V),Y
 STA P
 AND #15
 TAX
 LDA XX2,X
 BNE LL79 ;norm 1
 LDA P
 LSR A
 LSR A
 LSR A
 LSR A
 TAX
 LDA XX2,X
 BEQ LL78 ;norm 2

.LL79

 INY
 LDA (V),Y
 TAX
 LDA XX3,X
 STA XX15
 LDA XX3+1,X
 STA XX15+1
 LDA XX3+2,X
 STA XX15+2
 LDA XX3+3,X
 STA XX15+3
 INY
 LDA (V),Y
 TAX
 LDA XX3,X
 STA XX15+4
 LDA XX3+2,X
 STA XX12
 LDA XX3+3,X
 STA XX12+1
 LDA XX3+1,X
 STA XX15+5
 JSR CLIP2
 BCS LL78
 JSR LSPUT ;do line

.LL78

 LDA LSNUM
 CMP CNT
 BCS LL81
 LDA V
 CLC
 ADC #4
 STA V
 BCC P%+4
 INC V+1
 INC XX17
 LDY XX17
 CPY XX20
 BCC LL75

.LL81

 JMP LSCLR ;<3BS>**

.LL118

 \move XX15,XX15+2 to screen-grad.XX12+2
 LDA XX15+1
 BPL LL119
 STA S
 JSR LL120  ; X1<0
 TXA
 CLC
 ADC XX15+2
 STA XX15+2
 TYA
 ADC XX15+3
 STA XX15+3
 LDA #0
 STA XX15
 STA XX15+1
 TAX

.LL119

 BEQ LL134
 STA S
 DEC S
 JSR LL120 ; X1>255
 TXA
 CLC
 ADC XX15+2
 STA XX15+2
 TYA
 ADC XX15+3
 STA XX15+3
 LDX #$FF
 STX XX15
 INX
 STX XX15+1

.LL134

 LDA XX15+3
 BPL LL135
 STA S
 LDA XX15+2
 STA R   ; Y1<0
 JSR LL123
 TXA
 CLC
 ADC XX15
 STA XX15
 TYA
 ADC XX15+1
 STA XX15+1
 LDA #0
 STA XX15+2
 STA XX15+3

.LL135

;BNE LL139
 LDA XX15+2
 SEC
 SBC #Y*2
 STA R     ; Y1>191
 LDA XX15+3
 SBC #0
 STA S
 BCC LL136

.LL139

 JSR LL123
 TXA
 CLC
 ADC XX15
 STA XX15
 TYA
 ADC XX15+1
 STA XX15+1
 LDA #Y*2-1
 STA XX15+2
 LDA #0
 STA XX15+3

.LL136

 RTS
 \ YX = SR*M/256 - dedicated for CLIP

.LL120

 LDA XX15
 STA R
 \.LL120
 JSR LL129
 PHA
 LDX T
 BNE LL121

.LL122

 LDA #0
 TAX
 TAY
 LSR S
 ROR R
 ASL Q
 BCC LL126

.LL125

 TXA
 CLC
 ADC R
 TAX
 TYA
 ADC S
 TAY

.LL126

 LSR S
 ROR R
 ASL Q
 BCS LL125
 BNE LL126
 PLA
 BPL LL133
 RTS
 \ YX = SR*256/M (M = grad.)

.LL123

 JSR LL129
 PHA
 LDX T
 BNE LL122

.LL121

 LDA #255
 TAY
 ASL A
 TAX

.LL130

 ASL R
 ROL S
 LDA S
 BCS LL131
 CMP Q
 BCC LL132

.LL131

 SBC Q
 STA S
 LDA R
 SBC #0
 STA R
 SEC

.LL132

 TXA
 ROL A
 TAX
 TYA
 ROL A
 TAY
 BCS LL130
 PLA
 BMI LL128

.LL133

 TXA
 EOR #$FF
;CLC 
 ADC #1
 TAX
 TYA
 EOR #$FF
 ADC #0
 TAY

.LL128

 RTS

.LL129

 LDX XX12+2
 STX Q
 LDA S
 BPL LL127
 LDA #0
 SEC
 SBC R
 STA R
 LDA S
 PHA
 EOR #255
 ADC #0
 STA S
 PLA

.LL127

 EOR XX12+3
 RTS

.LL145 

.CLIP

 LDA #0
 STA SWAP
 LDA XX15+5

.CLIP2

 LDX #Y*2-1
 ORA XX12+1
 BNE LL107
 CPX XX12
 BCC LL107
 LDX #0

.LL107

 STX XX13
 LDA XX15+1
 ORA XX15+3
 BNE LL83
 LDA #Y*2-1
 CMP XX15+2
 BCC LL83
 LDA XX13
 BNE LL108

.LL146

 LDA XX15+2
 STA XX15+1
 LDA XX15+4
 STA XX15+2
 LDA XX12
 STA XX15+3
 CLC
 RTS

.LL109

 SEC
 RTS

.LL108

 LSR XX13

.LL83

 LDA XX13
 BPL LL115
 LDA XX15+1
 AND XX15+5
 BMI LL109
 LDA XX15+3
 AND XX12+1
 BMI LL109
 LDX XX15+1
 DEX
 TXA
 LDX XX15+5
 DEX
 STX XX12+2
 ORA XX12+2
 BPL LL109
 LDA XX15+2
 CMP #Y*2
 LDA XX15+3
 SBC #0
 STA XX12+2
 LDA XX12
 CMP #Y*2
 LDA XX12+1
 SBC #0
 ORA XX12+2
 BPL LL109

.LL115

 TYA
 PHA
 LDA XX15+4
 SEC
 SBC XX15
 STA XX12+2
 LDA XX15+5
 SBC XX15+1
 STA XX12+3
 LDA XX12
 SEC
 SBC XX15+2
 STA XX12+4
 LDA XX12+1
 SBC XX15+3
 STA XX12+5
 EOR XX12+3
 STA S
 LDA XX12+5
 BPL LL110
 LDA #0
 SEC
 SBC XX12+4
 STA XX12+4
 LDA #0
 SBC XX12+5
 STA XX12+5

.LL110

 LDA XX12+3
 BPL LL111
 SEC
 LDA #0
 SBC XX12+2
 STA XX12+2
 LDA #0
 SBC XX12+3
;GET grad

.LL111

 TAX
 BNE LL112
 LDX XX12+5
 BEQ LL113

.LL112

 LSR A
 ROR XX12+2
 LSR XX12+5
 ROR XX12+4
 JMP LL111

.LL113

 STX T
 LDA XX12+2
 CMP XX12+4
 BCC LL114
 STA Q
 LDA XX12+4
 JSR LL28
 \ Use Y/X grad.
 JMP LL116

.LL114

 LDA XX12+4
 STA Q
 LDA XX12+2
 JSR LL28
 \ Use X/Y grad.
 DEC T

.LL116

 LDA R
 STA XX12+2
 LDA S
 STA XX12+3
 LDA XX13
 BEQ LL138
 BPL LLX117

.LL138

 JSR LL118
 LDA XX13
 BPL LL124

.LL117

 LDA XX15+1
 ORA XX15+3
 BNE LL137
 LDA XX15+2
 CMP #Y*2
 BCS LL137

.LLX117

 LDX XX15
 LDA XX15+4
 STA XX15
 STX XX15+4
 LDA XX15+5
 LDX XX15+1
 STX XX15+5
 STA XX15+1
 LDX XX15+2
 LDA XX12
 STA XX15+2
 STX XX12
 LDA XX12+1
 LDX XX15+3
 STX XX12+1
 STA XX15+3
 JSR LL118
 DEC SWAP

.LL124

 PLA
 TAY
 JMP LL146

.LL137

 PLA
 TAY
 SEC
 RTS

.LSCLR

 LDY LSNUM

.LSC1

 CPY LSNUM2
 BCS LSC2
 LDA (XX19),Y
 INY
 STA XX15
 LDA (XX19),Y
 INY
 STA XX15+1
 LDA (XX19),Y
 INY
 STA XX15+2
 LDA (XX19),Y
 INY
 STA XX15+3
 JSR LOIN
 JMP LSC1

.LSC2

 LDA LSNUM
 LDY #0
 STA (XX19),Y

.LSC3

 RTS

.LSPUT

 LDY LSNUM
 CPY LSNUM2
 PHP
 LDX #3

.LSC4

 LDA XX15,X
 STA XX12,X
 DEX
 BPL LSC4
 JSR LOIN
 LDA (XX19),Y
 STA XX15
 LDA XX12
 STA (XX19),Y
 INY
 LDA (XX19),Y
 STA XX15+1
 LDA XX12+1
 STA (XX19),Y
 INY
 LDA (XX19),Y
 STA XX15+2
 LDA XX12+2
 STA (XX19),Y
 INY
 LDA (XX19),Y
 STA XX15+3
 LDA XX12+3
 STA (XX19),Y
 INY
 STY LSNUM
 PLP
 BCS LSC3
 JMP LOIN

; ******************************************************************************
;
; Save ELTG.bin
;
; ******************************************************************************

 PRINT "ELITE G"
 PRINT "Assembled at ", ~CODE_G%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_G%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_G%

 PRINT "S.ELTG ", ~CODE_G%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_G%
 SAVE "3-assembled-output/ELTG.bin", CODE_G%, P%, LOAD%

; ******************************************************************************
;
; ELITE H FILE
;
; Produces the binary file ELTH.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_H% = P%

 LOAD_H% = LOAD% + P% - CODE%

.MVEIT

 LDA INWK+31
 AND #$A0
 BNE MV30
 LDA MCNT
 EOR XSAV
 AND #15
 BNE MV3
 JSR TIDY

.MV3

 LDX TYPE
 BPL P%+5
 JMP MV40
 LDA INWK+32
 BPL MV30
 CPX #MSL
 BEQ MV26
 LDA MCNT
 EOR XSAV
 AND #7
 BNE MV30

.MV26

 JSR TACTICS

.MV30

 JSR SCAN
 LDA INWK+27
 ASL A
 ASL A
 STA Q
 LDA INWK+10
 AND #127
 JSR FMLTU
 STA R
 LDA INWK+10
 LDX #0
 JSR MVT1-2
 LDA INWK+12
 AND #127
 JSR FMLTU
 STA R
 LDA INWK+12
 LDX #3
 JSR MVT1-2
 LDA INWK+14
 AND #127
 JSR FMLTU
 STA R
 LDA INWK+14
 LDX #6
 JSR MVT1-2
 LDA INWK+27
 CLC
 ADC INWK+28
 BPL P%+4
 LDA #0
 LDY #15
 CMP (XX0),Y
 BCC P%+4
 LDA (XX0),Y
 STA INWK+27
 LDA #0
 STA INWK+28
 LDX ALP1
 LDA INWK
 EOR #$FF
 STA P
 LDA INWK+1
 JSR MLTU2-2
 STA P+2
 LDA ALP2+1
 EOR INWK+2
 LDX #3
 JSR MVT6
 STA K2+3
 LDA P+1
 STA K2+1
 EOR #$FF
 STA P
 LDA P+2
 STA K2+2 ; K2 = Y-aX
 LDX BET1
 JSR MLTU2-2
 STA P+2
 LDA K2+3
 EOR BET2
 LDX #6
 JSR MVT6
 STA INWK+8
 LDA P+1
 STA INWK+6
 EOR #$FF
 STA P
 LDA P+2
 STA INWK+7 ; Z = Z+bK2
 JSR MLTU2
 STA P+2
 LDA K2+3
 STA INWK+5
 EOR BET2
 EOR INWK+8
 BPL MV43
 LDA P+1
 ADC K2+1
 STA INWK+3
 LDA P+2
 ADC K2+2
 STA INWK+4
 JMP MV44

.MV43

 LDA K2+1
 SBC P+1
 STA INWK+3
 LDA K2+2
 SBC P+2
 STA INWK+4
 BCS MV44
 LDA #1
 SBC INWK+3
 STA INWK+3
 LDA #0
 SBC INWK+4
 STA INWK+4
 LDA INWK+5
 EOR #128
 STA INWK+5

.MV44 ; Y = K2-bZ 

 LDX ALP1
 LDA INWK+3
 EOR #$FF
 STA P
 LDA INWK+4
 JSR MLTU2-2
 STA P+2
 LDA ALP2
 EOR INWK+5
 LDX #0
 JSR MVT6
 STA INWK+2
 LDA P+2
 STA INWK+1
 LDA P+1
 STA INWK ; X = X+aY

.MV45

 LDA DELTA
 STA R
 LDA #128
 LDX #6
 JSR MVT1
 LDA TYPE
 AND #$81
 CMP #$81
 BNE P%+3
 RTS ;Z = Z-d
 LDY #9
 JSR MVS4
 LDY #15
 JSR MVS4
 LDY #21
 JSR MVS4
 LDA INWK+30
 AND #128
 STA RAT2
 LDA INWK+30
 AND #127
 BEQ MV8
 CMP #127
 SBC #0
 ORA RAT2
 STA INWK+30
 LDX #15
 LDY #9
 JSR MVS5
 LDX #17
 LDY #11
 JSR MVS5
 LDX #19
 LDY #13
 JSR MVS5

.MV8

 LDA INWK+29
 AND #128
 STA RAT2
 LDA INWK+29
 AND #127
 BEQ MV5
 CMP #127
 SBC #0
 ORA RAT2
 STA INWK+29
 LDX #15
 LDY #21
 JSR MVS5
 LDX #17
 LDY #23
 JSR MVS5
 LDX #19
 LDY #25
 JSR MVS5

.MV5

 LDA INWK+31
 AND #$A0
 BNE MVD1
 LDA INWK+31
 ORA #16
 STA INWK+31
 JMP SCAN

.MVD1

 LDA INWK+31
 AND #$EF
 STA INWK+31
 RTS
 AND #128

.MVT1

 ASL A
 STA S
 LDA #0
 ROR A
 STA T
 LSR S
 EOR INWK+2,X
 BMI MV10
 LDA R
 ADC INWK,X
 STA INWK,X
 LDA S
 ADC INWK+1,X
 STA INWK+1,X
 LDA INWK+2,X
 ADC #0
 ORA T
 STA INWK+2,X
 RTS

.MV10

 LDA INWK,X
 SEC
 SBC R
 STA INWK,X
 LDA INWK+1,X
 SBC S
 STA INWK+1,X
 LDA INWK+2,X
 AND #127
 SBC #0
 ORA #128
 EOR T
 STA INWK+2,X
 BCS MV11
 LDA #1
 SBC INWK,X
 STA INWK,X
 LDA #0
 SBC INWK+1,X
 STA INWK+1,X
 LDA #0
 SBC INWK+2,X
 AND #127
 ORA T
 STA INWK+2,X

.MV11

 RTS

.MVS4

 LDA ALPHA
 STA Q
 LDX INWK+2,Y
 STX R
 LDX INWK+3,Y
 STX S
 LDX INWK,Y
 STX P
 LDA INWK+1,Y
 EOR #128
 JSR MAD
 STA INWK+3,Y
 STX INWK+2,Y
 STXP ; Y = Y-aX
 LDX INWK,Y
 STX R
 LDX INWK+1,Y
 STX S
 LDA INWK+3,Y
 JSR MAD
 STA INWK+1,Y
 STX INWK,Y
 STXP ; X = X+aY
 LDA BETA
 STA Q
 LDX INWK+2,Y
 STX R
 LDX INWK+3,Y
 STX S
 LDX INWK+4,Y
 STX P
 LDA INWK+5,Y
 EOR #128
 JSR MAD
 STA INWK+3,Y
 STX INWK+2,Y
 STXP ; Y = Y-bZ
 LDX INWK+4,Y
 STX R
 LDX INWK+5,Y
 STX S
 LDA INWK+3,Y
 JSR MAD
 STA INWK+5,Y
 STX INWK+4,Y
 RTS ;Z = Z+bY

.MVT6

 TAY
 EOR INWK+2,X
 BMI MV50
 LDA P+1
 CLC
 ADC INWK,X
 STA P+1
 LDA P+2
 ADC INWK+1,X
 STA P+2
 TYA
 RTS

.MV50

 LDA INWK,X
 SEC
 SBC P+1
 STA P+1
 LDA INWK+1,X
 SBC P+2
 STA P+2
 BCC MV51
 TYA
 EOR #128
 RTS

.MV51

 LDA #1
 SBC P+1
 STA P+1
 LDA #0
 SBC P+2
 STA P+2
 TYA
 RTS

.MV40

 LDA ALPHA
 EOR #128
 STA Q
 LDA INWK
 STA P
 LDA INWK+1
 STA P+1
 LDA INWK+2
 JSR MULT3
 LDX #3
 JSR MVT3 ; K = Y-aX
 LDA K+1
 STA K2+1
 STA P
 LDA K+2
 STA K2+2
 STA P+1
 LDA BETA
 STA Q
 LDA K+3
 STA K2+3
 JSR MULT3
 LDX #6
 JSR MVT3
 LDA K+1
 STA P
 STA INWK+6
 LDA K+2
 STA P+1
 STA INWK+7
 LDA K+3
 STA INWK+8 ; Z = Z+bK2
 EOR #128
 JSR MULT3
 LDA K+3
 AND #128
 STA T
 EOR K2+3
 BMI MV1
 LDA K
 CLC
 ADC K2
 LDA K+1
 ADC K2+1
 STA INWK+3
 LDA K+2
 ADC K2+2
 STA INWK+4
 LDA K+3
 ADC K2+3
 JMP MV2

.MV1

 LDA K
 SEC
 SBC K2
 LDA K+1
 SBC K2+1
 STA INWK+3
 LDA K+2
 SBC K2+2
 STA INWK+4
 LDA K2+3
 AND #127
 STA P
 LDA K+3
 AND #127
 SBC P
 STA P
 BCS MV2
 LDA #1
 SBC INWK+3
 STA INWK+3
 LDA #0
 SBC INWK+4
 STA INWK+4
 LDA #0
 SBC P
 ORA #128

.MV2

 EOR T
 STA INWK+5 ; Y = K2-bZ
 LDA ALPHA
 STA Q
 LDA INWK+3
 STA P
 LDA INWK+4
 STA P+1
 LDA INWK+5
 JSR MULT3
 LDX #0
 JSR MVT3
 LDA K+1
 STA INWK
 LDA K+2
 STA INWK+1
 LDA K+3
 STA INWK+2 ; X = X+aY
 JMP MV45
 \....

.PLUT

 LDX VIEW
 BEQ PU2-1

.PU1

 DEX
 BNE PU2
 LDA INWK+2
 EOR #128
 STA INWK+2
 LDA INWK+8
 EOR #128
 STA INWK+8
 LDA INWK+10
 EOR #128
 STA INWK+10
 LDA INWK+14
 EOR #128
 STA INWK+14
 LDA INWK+16
 EOR #128
 STA INWK+16
 LDA INWK+20
 EOR #128
 STA INWK+20
 LDA INWK+22
 EOR #128
 STA INWK+22
 LDA INWK+26
 EOR #128
 STA INWK+26
 RTS

.PU2

 LDA #0
 CPX #2
 ROR A
 STA RAT2
 EOR #128
 STA RAT
 LDA INWK
 LDX INWK+6
 STA INWK+6
 STX INWK
 LDA INWK+1
 LDX INWK+7
 STA INWK+7
 STX INWK+1
 LDA INWK+2
 EOR RAT
 TAX
 LDA INWK+8
 EOR RAT2
 STA INWK+2
 STX INWK+8
 LDY #9
 JSR PUS1
 LDY #15
 JSR PUS1
 LDY #21

.PUS1

 LDA INWK,Y
 LDX INWK+4,Y
 STA INWK+4,Y
 STX INWK,Y
 LDA INWK+1,Y
 EOR RAT
 TAX
 LDA INWK+5,Y
 EOR RAT2
 STA INWK+1,Y
 STX INWK+5,Y

.LO2

 RTS

.LQ

 STX VIEW
 JSR TT66
 JSR SIGHT
 LDA BOMB
 BPL P%+5
 JSR BOMBOFF ; @@
 JMP NWSTARS

.LOOK1

 LDA #0
 LDY QQ11
 BNE LQ
 CPX VIEW
 BEQ LO2
 STX VIEW
 JSR TT66
 JSR FLIP
 LDA BOMB
 BPL P%+5
 JSR BOMBOFF ;@@
 JSR WPSHPS

.SIGHT

 LDY VIEW
 LDA LASER,Y
 BEQ LO2
 LDY #0
 CMP #POW
 BEQ SIG1
 INY
 CMP #(POW+128)
 BEQ SIG1
 INY
 CMP #Armlas
 BEQ SIG1
 INY

.SIG1

 LDA sightcol,Y
 STA COL
 LDA #128
 STA QQ19
 LDA #Y-24
 STA QQ19+1
 LDA #20
 STA QQ19+2
 JSR TT15
 LDA #10
 STA QQ19+2
 JMP TT15
 \.......

.sightcol

 EQUB BLUE
 EQUB RED
 EQUB WHITE
 EQUB WHITE

.beamcol

 EQUB VIOLET
 EQUB RED
 EQUB GREEN
 EQUB WHITE
;.TRIBTA
;EQUB 0
;EQUB 1
;EQUB 2
;EQUB 3
;EQUB 4 
;EQUB 5 
;EQUB 6 
;EQUB 6
;.TRIBMA
;EQUB 0
;EQUB 4
;EQUB $C
;EQUB $1C
;EQUB $3C
;EQUB $7C
;EQUB $FC
;EQUB $FC

.TT66

 STA QQ11

.TTX66

 JSR MT2
 LDA #0
 STA LSP
 LDA #128
 STA QQ17
 STA DTW2
 LDA #1
 STA XC
 STA YC
 JSR TTX66K
 LDA text
 BMI P%+5
 JSR FLFLLS
 LDA #0
 STA LAS2
 STA DLY
 STA de
 LDX QQ22+1
 BEQ OLDBOX
 JSR ee3

.OLDBOX 

 LDA #1
 STA YC
 LDA QQ11
 BNE tt66
 LDA #11
 STA XC
 LDA VIEW
 ORA #$60
 JSR TT27
 JSR TT162
 LDA #175
 JSR TT27

.tt66

 LDX #1
 STX XC
 STX YC
 DEX
 STX QQ17
 RTS

; ******************************************************************************
;
; Save ELTH.bin
;
; ******************************************************************************

 PRINT "ELITE H"
 PRINT "Assembled at ", ~CODE_H%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_H%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_H%

 PRINT "S.ELTH ", ~CODE_H%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_H%
 SAVE "3-assembled-output/ELTH.bin", CODE_H%, P%, LOAD%

; ******************************************************************************
;
; ELITE I FILE
;
; Produces the binary file ELTI.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_I% = P%

 LOAD_I% = LOAD% + P% - CODE%

.yetanotherrts 

.DEMON

 RTS ;<<

.ECMOF

 LDA #0
 STA ECMA
 STA ECMP
 JMP ECBLB ;@@

.SFRMIS

 LDX #MSL
 JSR SFS1-2
 BCC yetanotherrts
 LDA #$78
 JSR MESS
 LDY #50
 JMP SOHISS ; @@

.EXNO2

 LDA TALLYL
 CLC
 ADC KWL%-1,X
 STA TALLYL
 LDA TALLY
 ADC KWH%-1,X
 STA TALLY
 BCC davidscockup
 INC TALLY+1
 LDA #101
 JSR MESS

.davidscockup

 LDY #55
 BNE SOEXPL ; @@

.EXNO

 LDY #15
 BNE SOEXPL ; @@
 \...................

.BOOP

 LDY #99
 LDX #$FF
 BNE SOBEEP

.SOHISS

 BIT DNOIZ
 BMI SOUR

.SOHISS2 

 LDA $C030
 JSR DORND
 DEX
 NOP
 NOP
 BNE P%-3
 DEY
 BNE SOHISS2
 LDA $C030
 RTS

.EXNO3

 LDY #40

.SOEXPL

 BIT DNOIZ
 BMI SOUR
 LDX #50
 STX T3

.BEEPL4

 LDA $C030
 INC T3
 LDX T3
 DEX
 NOP
 NOP
 BNE P%-3
 JSR DORND
 DEX
 NOP
 BNE P%-2
 DEY
 BNE BEEPL4
 LDA $C030
 RTS

.BEEP

 LDY #30
 LDX #110

.SOBEEP

 BIT DNOIZ
 BMI SOUR
 STX T3

.BEEPL1

 LDA $C030
 LDX T3
 DEX
 BNE P%-1
 DEY
 BNE BEEPL1
 LDA $C030

.SOUR

 RTS

.SOBLIP

 BIT DNOIZ
 BMI SOUR
 STX T3

.BEEPL2

 LDA $C030
 DEC T3
 LDX T3
 DEX
 NOP
 BNE P%-2
 DEY
 BNE BEEPL2
 LDA $C030
 RTS

.LASNOISE

 LDY #11
 LDX #150

.SOBLOP

 BIT DNOIZ
 BMI SOUR
 STX T3

.BEEPL3

 LDA $C030
 INC T3
 INC T3
 LDX T3
 DEX
 BNE P%-1
 DEY
 BNE BEEPL3
 LDA $C030
 RTS

.LASNOISE2

 LDY #11
 LDX #130

.SOBOMB

 BIT DNOIZ
 BMI SOUR
 LDY #25

.SOHISS4

 LDA $C030
 JSR DORND
 AND #31
 ORA #$E0
 TAX
 DEX
 NOP
 BNE P%-2
 DEY
 BNE SOHISS4
 LDA $C030
 RTS

.CLICK

 BIT DNOIZ
 BMI SOUR2
 LDA $C030

.SOUR2

 RTS
 \............ 

.COLD

 \Page out KERNAL etc
 JSR HGR
 LDA #8
 STA SC+1
 LDX #2
 LDA #0
 STA SC
 TAY

.zerowksploop

 STA (SC),Y
 INY
 BNE zerowksploop
 INC SC+1
 DEX
 BNE zerowksploop

.zerowkl2

 STA $200,Y
 DEY
 BNE zerowkl2
 LDA #(NMIpissoff MOD 256)
 STA NMIV
 LDA #(NMIpissoff DIV 256)
 STA NMIV+1
 LDA #(CHPR2 MOD 256)
 STA CHRV
 LDA #(CHPR2 DIV 256)
 STA CHRV+1
 SEI

IF NOT(USA%)
 \UK CHECK
ENDIF

 RTS

.NMIpissoff

 CLI
 RTI

; ******************************************************************************
;
; Save ELTI.bin
;
; ******************************************************************************

 PRINT "ELITE I"
 PRINT "Assembled at ", ~CODE_I%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_I%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_I%

 PRINT "S.ELTI ", ~CODE_I%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_H%
 SAVE "3-assembled-output/ELTI.bin", CODE_I%, P%, LOAD%

; ******************************************************************************
;
; ELITE J FILE
;
; Produces the binary file ELTJ.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_J% = P%

 LOAD_J% = LOAD% + P% - CODE%

; DOS_RW1

.comnam

 \ (must be 30 characters long - pad with spaces)
 EQUS "COMMANDER                     " 

.rfile

 \ read a Commander file from a DOS disc into buffer
 TSX
 STX stkptr
 JSR findf
 LDA #5
 BCS rfile3 ; branch if file not found
 JSR gettsl ; get track/sector list of file
 JSR rsect ; read first sector of file
 LDY #0

.rfile2

 LDA buffer+4,Y
 STA comfil,Y ; copy buffer to commander file
 INY
 CPY #comsiz ;loop other way ## <2BS>
 BNE rfile2
 CLC

.rfile3

 RTS  ; C = 1 file not found, C = 0 file found and in buffer 

.wfile

 \ write a commander file from buffer to a DOS disc
 JSR MUTILATE
 TSX
 STX stkptr
 JSR findf
 BCC oldfil ; branch if file already exists 

.newfil

 \ save a new commander file
 JSR isfull ; check for at least two free sectors
 LDA #2
 BCS rfile3 ; branch if disc full
 JSR finde ; find an empty file entry
 LDA #3
 BCS rfile3 ; branch if cat full
 LDA tsltrk
 STA buffer,Y ; tsl track field
 LDA tslsct
 STA buffer+1,Y ; tsl sector field
 LDA #4
 STA buffer+2,Y ; file type = BINARY file
 LDA #2
 STA buffer+$21,Y ; sectors lo = 2
 LDA #0
 STA buffer+$22,Y ; sectors hi = 0
 TAX

.newfl2

 LDA comnam,X
 ORA #$80
 STA buffer+3,Y ; copy commander name to file name field
 INY
 INX
 CPX #30
 BNE newfl2
 JSR wsect ; write catalog sector to disc
 JSR isfull ; allocate two free sectors
 JSR wsect ; write VTOC

.newfl3

 LDA #0
 TAY

.newfl4

 STA buffer,Y ; init tsl
 INY
 BNE newfl4
 LDA filtrk
 STA buffer+12 ; track of commander file
 LDA filsct
 STA buffer+13 ; sector of commander file
 LDA tsltrk
 STA track
 LDA tslsct
 STA sector
 JSR wsect ; write tsl sector
 LDA filtrk
 STA track
 LDA filsct
 STA sector
 BPL oldfl2 ; always 

.oldfil

 \ update an existing commander file
 JSR gettsl ; get tsl of file

.oldfl2

 LDY #0

.oldfl3

 LDA comfil,Y
 STA buffer+4,Y ; copy commander file to buffer
 INY
 CPY #comsiz
 BNE oldfl3
 JMP wsect ; write first sector of commander file 

.findf

 \ find an existing file
 CLC
 BCC rentry ; always

.finde

 \ find a new entry
 SEC

.rentry

 ROR atemp0
 JSR rvtoc ; read VTOC

.rentr2

 LDA buffer+1 ; read track of next catalog
 STA track
 LDA buffer+2 ; read sector of next catalog
 STA sector
 JSR rsect ; read catalog sector
 LDY #$B ; point to first entry in sector

.rentr3

 LDA buffer,Y
 BIT atemp0
 BPL rentr4 ; branch if searching catalog for a file
 TAX
 BEQ rentr6 ; branch if found blank entry
 CMP #$FF ;INX ##
 BEQ rentr6 ; branch if found deleted entry
 BNE rentr8 ; branch if used entry

.rentr4

 TAX
 BEQ rentr9 ; branch if last catalog entry
 CMP #$FF
 BEQ rentr8 ; branch if deleted file
 TYA
 PHA
 LDX #0

.rentr5

 LDA buffer+3,Y
 AND #$7F
 CMP comnam,X
 BNE rentr7 ; branch if names don't match
 INY
 INX
 CPX #30
 BNE rentr5
 PLA
 TAY ; Y points to start of file entry

.rentr6

 CLC ; signifies file found
 RTS

.rentr7

 PLA
 TAY

.rentr8

 TYA
 CLC
 ADC #35
 TAY
 BNE rentr3 ; branch if not reached last entry
 LDA buffer+1
 BNE rentr2 ; branch if not last catalog sector

.rentr9

 SEC ; signifies file not found
 RTS 

.getsct

 \ allocate one free sector from VTOC - doesn't update VTOC on disc
 LDA #0
 STA ztemp0 ; init allocation flag
 BEQ getsc4 ; always

.getsc3

 LDA dirtrk

.getsc4

 CLC
 ADC fretrk ; add last allocated track to direction of allocation
 BEQ getsc5 ; branch if track 0
 CMP tracks
 BCC getsc7 ; branch if not last track+1
 LDA #$FF
 BNE getsc6 ; always - direction  =  backwards

.getsc5

 LDA ztemp0
 BNE getscB ; branch if no free sectors - disc full
 LDA #1 ; direction = forwards
 STA ztemp0

.getsc6

 STA dirtrk ; change direction
 CLC
 ADC #17

.getsc7

 STA fretrk
 ASL A
 ASL A
 TAY
 LDX #16
 LDA bitmap,Y
 BNE getsc8 ; branch if not all allocated
 INY
 LDX #8
 LDA bitmap,Y
 BEQ getsc3 ; branch if all allocated

.getsc8

 STX ztemp0
 LDX #0

.getsc9

 INX
 DEC ztemp0 ; sector = sector-1
 ROL A
 BCC getsc9 ; loop until got a free sector
 CLC ; allocate sector by clearing bit

.getscA

 ROR A ; shift bits back again
 DEX
 BNE getscA
 STA bitmap,Y ; update VTOC
 LDX fretrk ; next free track
 LDY ztemp0 ; next free sector
 CLC ; signifies one sector has been allocated
 RTS

.getscB

 SEC ; signifies disc full
 RTS 

.isfull

 \ search VTOC for tsl sector and commander file sector
 JSR rvtoc ; read VTOC
 JSR getsct ; find free sector for tsl
 BCS isful2 ; branch if disc full
 STX tsltrk
 STY tslsct
 JSR getsct ; find free sector for commander file
 STX filtrk
 STY filsct

.isful2

 RTS ; C = 0 = disc full, C = 1 = enough space 

.gettsl

 \ read a file's track sector list
 LDA buffer,Y ; get track of tsl
 STA track
 LDA buffer+1,Y ; get sector of tsl
 STA sector
 JSR rsect ; read tsl
 LDY #$C
 LDA buffer,Y ; get track of first sector of file
 STA track
 LDA buffer+1,Y ; get sector of first sector of file
 STA sector
 RTS 

.rvtoc

 \ read VTOC sector into buffer
 LDA #17
 STA track
 LDA #0
 STA sector

 \REM DOS_RW2 

.rsect

 \ read sector from disc into buffer
 CLC
 BCC wsect2 ; always

.wsect

 \ write sector from buffer to disc
 SEC

.wsect2

 \ drive = 1, track = ?track, sector = ?sector
 PHP
 LDA #$60
 STA slot16
 LDA #2
 STA recals ; init max number of arm recalibrations
 LDA #4
 STA seeks ; init max number of seeks
 LDA #$D8
 STA mtimeh ; init motor on time hi
 LDX slot16 ; get slot number*16 of controller card
 LDA Q7L,X ; prepare latch for input
 LDA Q6L,X ; strobe data latch for I/O
 LDY #8

.rwts2

 LDA Q6L,X ; read data
 PHA ; short delay
 PLA
 PHA
 PLA
 CMP $100
 CMP Q6L,X
 BNE rwts3 ; branch if data latch changed ie. disc is spinning
 DEY
 BNE rwts2

.rwts3

 PHP ; save result - Z = 0 = disc is spinning, Z = 1 = disc not spinning
 LDA mtron,X ; turn motor on - if disc was not spinning
 LDA drv1en,X ; enable drive 1
 PLP
 PHP
 BNE rwts5 ; branch if disc is spinning
 LDY #7

.rwts4

 JSR armwat ; wait for capacitor to discharge
 DEY
 BNE rwts4
 LDX slot16

.rwts5

 LDA track
 JSR seek
 PLP
 BNE trytrk ; branch if disc is spinning
 LDY mtimeh
 BPL trytrk ; branch if motor reached correct speed

.rwts6

 LDY #18 ; delay for motor to reach correct speed

.rwts7

 DEY
 BNE rwts7
 INC mtimel
 BNE rwts6
 INC mtimeh
 BNE rwts6

.trytrk

 PLP ; get read/write status
 PHP
 BCC trytr2 ; branch if read sector
 JSR prenib ; convert sector to 6 bit 'nibbles'

.trytr2

 LDY #48
 STY ztemp2

.trytr3

 LDX slot16
 JSR rdaddr ; find track address
 BCC rdrght ; branch if no error

.trytr4

 DEC ztemp2
 BPL trytr3 ; branch if not last try

.trytr5

 DEC recals
 BEQ drverr ; branch if last try
 LDA #4
 STA seeks
 LDA #$60
 STA curtrk
 LDA #0
 JSR seek ; reset head

.trytr6

 LDA track
 JSR seek ; seek to desired track
 JMP trytr2 

.rdrght

 LDY idfld+2
 CPY track
 BEQ rttrk ; branch if track does match track id
 DEC seeks
 BNE trytr6
 BEQ trytr5 ; always 

.prterr

 \ disc write protected
 LDA #1
 BPL drver2_copy

{
.drverr     ; Removed as it isn't used and clashes with drverr below
}

 \ disc I/O error
 LDA #4 ; I/O error

.drver2

 LDX stkptr
 TXS
 LDX slot16
 LDY mtroff,X ; turn motor off
 SEC ; signify error has occured
 RTS 

.rttrk

 LDY sector
 LDA scttab,Y
 CMP idfld+1
 BNE trytr4 ; branch if sector doesn't match sector id
 PLP
 BCS rttrk2 ; branch if write sector
 JSR read
 PHP
 BCS trytr4 ; branch if read error
 PLP
 JSR pstnib ; convert sector to 8 bit bytes
 JMP rttrk3

.rttrk2

 JSR write
 BCC rttrk3 ; branch if no error
 LDA #1

 BPL drver2

.drverr

 \ disc I/O error
 LDA #4 ; I/O error

;.drver2

.drver2_copy            ; Added as drver2 is repeated

 LDX stkptr
 TXS
 SEC
 BCS rttrk4

.rttrk3

 LDA #0
 CLC

.rttrk4

 LDX slot16
 LDY mtroff,X ; turn motor off
 RTS ; C = 0 = no error, C = 1 = error, A = error code 

.read

 \ read sector
 LDY #32

.read2

 DEY
 BEQ readE

.read3

 LDA Q6L,X
 BPL read3

.read4

 EOR #$D5
 BNE read2
 NOP

.read5

 LDA Q6L,X
 BPL read5
 CMP #$AA
 BNE read4
 LDY #$56

.read6

 LDA Q6L,X
 BPL read6
 CMP #$AD
 BNE read4
 LDA #0

.read7

 DEY
 STY ztemp0

.read8

 LDY Q6L,X
 BPL read8
 EOR rtable-$96,Y
 LDY ztemp0
 STA buffr2+256,Y
 BNE read7

.read9

 STY ztemp0

.readA

 LDY Q6L,X
 BPL readA
 EOR rtable-$96,Y
 LDY ztemp0
 STA buffr2,Y
 INY
 BNE read9

.readB

 LDY Q6L,X
 BPL readB
 CMP rtable-$96,Y
 BNE readE

.readC

 LDA Q6L,X
 BPL readC
 CMP #$DE
 BNE readE
 NOP

.readD

 LDA Q6L,X
 BPL readD
 CMP #$AA
 BEQ readF

.readE

 SEC
 RTS

.readF

 CLC
 RTS

.write

 \ write sector
 SEC
 STX ztemp1
 LDA Q6H,X
 LDA Q7L,X
 BMI write6
 LDA buffr2+256
 STA ztemp0
 LDA #$FF
 STA Q7H,X
 ORA Q6L,X
 PHA
 PLA
 NOP
 LDY #4

.write2

 PHA
 PLA
 JSR wbyte2
 DEY
 BNE write2
 LDA #$D5
 JSR wbyte
 LDA #$AA
 JSR wbyte
 LDA #$AD
 JSR wbyte
 TYA
 LDY #$56
 BNE write4

.write3

 LDA buffr2+256,Y

.write4

 EOR buffr2+255,Y
 TAX
 LDA wtable,X
 LDX ztemp1
 STA Q6H,X
 LDA Q6L,X
 DEY
 BNE write3
 LDA ztemp0
 NOP

.write5

 EOR buffr2,Y
 TAX
 LDA wtable,X
 LDX slot16
 STA Q6H,X
 LDA Q6L,X
 LDA buffr2,Y
 INY
 BNE write5
 TAX
 LDA wtable,X
 LDX ztemp1
 JSR wbyte3
 LDA #$DE
 JSR wbyte
 LDA #$AA
 JSR wbyte
 LDA #$EB
 JSR wbyte
 LDA #$FF
 JSR wbyte
 LDA Q7L,X

.write6

 LDA Q6L,X
 RTS

 \REM DOS_RW3 

.rdaddr

 \ read track address field
 LDY #$FC
 STY ztemp0

.rdadr2

 INY
 BNE rdadr3
 INC ztemp0
 BEQ rdadrD

.rdadr3

 LDA Q6L,X
 BPL rdadr3

.rdadr4

 CMP #$D5
 BNE rdadr2
 NOP

.rdadr5

 LDA Q6L,X
 BPL rdadr5
 CMP #$AA
 BNE rdadr4
 LDY #3

.rdadr6

 LDA Q6L,X
 BPL rdadr6
 CMP #$96
 BNE rdadr4
 LDA #0

.rdadr7

 STA ztemp1

.rdadr8

 LDA Q6L,X
 BPL rdadr8
 ROL A
 STA ztemp0

.rdadr9

 LDA Q6L,X
 BPL rdadr9
 AND ztemp0
 STA idfld,Y
 EOR ztemp1
 DEY
 BPL rdadr7
 TAY
 BNE rdadrD

.rdadrA

 LDA Q6L,X
 BPL rdadrA
 CMP #$DE
 BNE rdadrD
 NOP

.rdadrB

 LDA Q6L,X
 BPL rdadrB
 CMP #$AA
 BNE rdadrD

.rdadrC

 CLC
 RTS

.rdadrD

 SEC
 RTS 

.seek

 \ A = desired track
 STX ztemp0
 ASL A
 CMP curtrk
 BEQ step3 ; branch if head already over desired track
 STA ztemp1 ; save desired track*2
 LDA #0
 STA ztemp2

.seek2

 LDA curtrk
 STA ztemp3
 SEC
 SBC ztemp1
 BEQ seek7 ; branch if reached desired track
 BCS seek3 ; branch if step back
 EOR #$FF
 INC curtrk ; track = track+1
 BCC seek4 ; always

.seek3

 ADC #$FE
 DEC curtrk ; track = track-1

.seek4

 CMP ztemp2
 BCC seek5
 LDA ztemp2

.seek5

 CMP #12
 BCS seek6
 TAY

.seek6

 SEC
 JSR step
 LDA armtab,Y
 JSR armwat
 LDA ztemp3
 CLC
 JSR step2
 LDA armtb2,Y
 JSR armwat
 INC ztemp2
 BNE seek2 ; always

.seek7

 JSR armwat
 CLC 

.step

 \ step drive head
 LDA curtrk

.step2

 AND #3
 ROL A
 ORA ztemp0
 TAX
 LDA phsoff,X ; stepper motor phase 0-3 on/off
 LDX ztemp0

.step3

 RTS 

.armwat

 \ arm move delay
 LDX #17

.armwt2

 DEX
 BNE armwt2
 INC mtimel
 BNE armwt3
 INC mtimeh

.armwt3

 SEC
 SBC #1
 BNE armwat
 RTS 

.armtab

 EQUB 1
 EQUB $30
 EQUB $28
 EQUB $24
 EQUB $20
 EQUB $1E
 EQUB $1D
 EQUB $1C
 EQUB $1C
 EQUB $1C
 EQUB $1C
 EQUB $1C

.armtb2

 EQUB $70
 EQUB $2C
 EQUB $26
 EQUB $22
 EQUB $1F
 EQUB $1E
 EQUB $1D
 EQUB $1C
 EQUB $1C
 EQUB $1C
 EQUB $1C
 EQUB $1C 

.prenib

 \ comverts 256*8 bit bytes to 342*6 bit 'nibbles'
 LDX #0
 LDY #2

.prenb2

 DEY
 LDA buffer,Y
 LSR A
 ROL buffr2+256,X
 LSR A
 ROL buffr2+256,X
 STA buffr2,Y
 INX
 CPX #$56
 BCC prenb2
 LDX #0
 TYA
 BNE prenb2
 LDX #$55

.prenb3

 LDA buffr2+256,X
 AND #$3F
 STA buffr2+256,X
 DEX
 BPL prenb3
 RTS 

.pstnib

 \ convert 342*6 bit 'nibbles' to 256*8 bit bytes
 LDY #0

.pstnb2

 LDX #$56

.pstnb3

 DEX
 BMI pstnb2
 LDA buffr2,Y
 LSR buffr2+256,X
 ROL A
 LSR buffr2+256,X
 ROL A
 STA buffer,Y
 INY
 BNE pstnb3
 RTS 

.wbyte

 \ write one byte to disc
 CLC

.wbyte2

 PHA
 PLA

.wbyte3

 STA Q6H,X
 ORA Q6L,X
 RTS 

.scttab

 EQUD &090B0D00
 EQUD &01030507
 EQUD &080A0C0E
 EQUD &0F020406 

.rtable

 EQUD &99980100
 EQUD &049C0302
 EQUD &A1A00605
 EQUD &A5A4A3A2
 EQUD &A9A80807
 EQUD &0B0A09AA
 EQUD &B1B00D0C
 EQUD &11100F0E
 EQUD &14B81312
 EQUD &18171615
 EQUD &C1C01A19
 EQUD &C5C4C3C2
 EQUD &C9C8C7C6
 EQUD &1CCC1BCA
 EQUD &D1D01E1D
 EQUD &D5D41FD2
 EQUD &22D82120
 EQUD &26252423
 EQUD &E1E02827
 EQUD &29E4E3E2
 EQUD &2CE82B2A
 EQUD &302F2E2D
 EQUD &F1F03231
 EQUD &36353433
 EQUD &39F83837
 EQUD &3D3C3B3A
 EQUW $3F3E 

.MUTILATE

 LDA CHK3
 EOR RAND
 STA RAND
 STA comfil2
 EOR #$A5
 ORA #17
 EOR RAND+1
 STA RAND+1
 STA comfil2+1
 EOR RAND+2
 EOR #$F8
 STA RAND+2
 STA comfil2+2
 EOR RAND+3
 EOR #$12
 STA RAND+3
 STA comfil2+3

.MUTIL3

 LDY #comsiz-5

.MUTIL1

 JSR DORND2
 EOR comfil,Y
 STA comfil,Y
 DEY
 BPL MUTIL1
 RTS

.UNMUTILATE

 LDY #3

.MUTIL2

 LDA comfil2,Y
 STA RAND,Y
 DEY
 BPL MUTIL2
 BMI MUTIL3

; ******************************************************************************
;
; Save ELTJ.bin
;
; ******************************************************************************

 PRINT "ELITE J"
 PRINT "Assembled at ", ~CODE_J%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_J%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_J%

 PRINT "S.ELTJ ", ~CODE_J%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_J%
 SAVE "3-assembled-output/ELTJ.bin", CODE_J%, P%, LOAD%

; ******************************************************************************
;
; ELITE K FILE
;
; Produces the binary file ELTK.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_K% = P%

 LOAD_K% = LOAD% + P% - CODE%

 OSWRCH = $FFEE
 OSBYTE = $FFF4
 OSWORD = $FFF1
 OSFILE = $FFDD
 SCLI = $FFF7
 VIA = $FE40
 USVIA = VIA
 IRQ1V = $204
 VSCAN = 57
 WRCHV = $20E
 WORDV = $20C
 RDCHV = $210
 protlen = 0
 BULBCOL = $E0

 \  ...................... Scanners  .............................. 

.TWOS

 EQUD &08040201
 EQUW $2010
 EQUB $40

.TWOS2

 EQUD &988C8683
 EQUW $E0B0
 EQUB $C0

.TWFL

 EQUB $83
 EQUB $87
 EQUB $8F
 EQUB $9F
 EQUB $BF
 EQUB $FF
 EQUB $FF

.TWFR

 EQUB $FF
 EQUB $FE
 EQUB $FC
 EQUB $F8
 EQUB $F0
 EQUB $E0
 EQUB $C0

.CTWOS 

.cellocl

 EQUD &82028202
 EQUD &82028202
 EQUD &AA2AAA2A
 EQUD &AA2AAA2A
 EQUD &D252D252
 EQUD &D252D252
 \............. Line Draw .............. 

.SCTBL

 EQUW $8000
 EQUW $8000
 EQUW $8000
 EQUW $8000
 EQUW $A828
 EQUW $A828
 EQUW $A828
 EQUW $A828
 EQUW $D050
 EQUW $D050
 EQUW $D050
 EQUW $D050

.SCTBH

 EQUW $2020
 EQUW $2121
 EQUW $2222
 EQUW $2323
 EQUW $2020
 EQUW $2121
 EQUW $2222
 EQUW $2323
 EQUW $2020
 EQUW $2121
 EQUW $2222
 EQUW $2323
 EQUW $2020
 EQUW $2020
 EQUW $2020
 EQUW $2020   ;safety

.SCTBH2

 EQUW $3C3C
 EQUW $3D3D
 EQUW $3E3E
 EQUW $3F3F
 EQUW $3C3C
 EQUW $3D3D
 EQUW $3E3E
 EQUW $3F3F
 EQUW $3C3C
 EQUW $3D3D
 EQUW $3E3E
 EQUW $3F3F
 \ can loose this table by adding $1C00 to SCTBH references
 \.......
 \.grubbyline RTS

.LL30 

.LOIN

 STY YSAV
;LDA Y1
;CMP #Y*2
;BCS grubbyline
;LDA Y2
;CMP #Y*2
;BCS grubbyline
 \**
 LDA #128
 STA S
 ASL A
 STA SWAP
 LDA X2
 SBC X1
 BCS LI1
 EOR #$FF
 ADC #1
 SEC

.LI1

 STA P
 LDA Y2
 SBC Y1
 BCS LI2
 EOR #$FF
 ADC #1

.LI2

 STA Q
 CMP P
 BCC STPX
 JMP STPY

.STPX

 LDX X1
 CPX X2
 BCC LI3
 DEC SWAP
 LDA X2
 STA X1
 STX X2
 TAX
 LDA Y2
 LDY Y1
 STA Y1
 STY Y2

.LI3

 LDA Y1
 LSR A
 LSR A
 LSR A
 STA T1
 TAY
 LDA SCTBL,Y
 STA SC
 LDA Y1
 AND #7
 STA T2
 ASL A
 ASL A
 ADC SCTBH,Y
 STA SC+1 ;SC = address of leftmost byte in correct row
 LDY SCTBX1,X
 LDA TWOS,Y
 STA R
 LDY SCTBX2,X
 LDX Q
 BNE LIlog7
 TXA
 BEQ LIlog6

.LIlog7

 LDA logL,X
 LDX P
 SEC
 SBC logL,X
 LDX Q
 LDA log,X
 LDX P
 SBC log,X
 BCC P%+6
 LDA #$FF
 BNE LIlog6
 TAX
 LDA alogh,X

.LIlog6

 STA Q
 SEC
 LDX P
 INX
 LDA Y2
 SBC Y1
 BCS DOWN
 \...
 LDA SWAP
 BNE LI6
 DEX

.LIL2

 LDA R
 EOR (SC),Y
 STA (SC),Y

.LI6

 ASL R
 BPL LI7
 LDA #1
 STA R
 INY

.LI7

 LDA S
 ADC Q
 STA S
 BCC LIC2
 DEC T2
 BMI LI20
 LDA SC+1
 SBC #4
 STA SC+1

.LIC2

 DEX
 BNE LIL2
 LDY YSAV
 RTS

.LI20

 LDA #7
 STA T2
 STX T
 LDX T1
 DEX
 STX T1
 LDA SCTBL,X
 STA SC
 LDA SCTBH2,X
 LDX T
 STA SC+1
 JMP LIC2
 \.....

.DOWN

 LDA T2
 EOR #7
 STA T2
 LDA SWAP
 BEQ LI9
 DEX

.LIL3

 LDA R
 EOR (SC),Y
 STA (SC),Y

.LI9

 ASL R
 BPL LI10
 LDA #1
 STA R
 INY

.LI10

 LDA S
 ADC Q
 STA S
 BCC LIC3
 DEC T2
 BMI LI21
 LDA SC+1
 ADC #3
 STA SC+1

.LIC3

 DEX
 BNE LIL3
 LDY YSAV
 RTS

.LI21

 LDA #7
 STA T2
 STX T
 LDX T1
 INX
 STX T1
 LDA SCTBL,X
 STA SC
 LDA SCTBH,X
 STA SC+1
 LDX T
 JMP LIC3
 \.....

.STPY

 LDY Y1
 TYA
 LDX X1
 CPY Y2
 BCS LI15
 DEC SWAP
 LDA X2
 STA X1
 STX X2
 TAX
 LDA Y2
 STA Y1
 STY Y2
 TAY

.LI15

 LSR A
 LSR A
 LSR A
 STA T1
 TAY
 LDA SCTBL,Y
 STA SC
 LDA Y1
 AND #7
 STA T2
 ASL A
 ASL A
 ADC SCTBH,Y
 STA SC+1
 LDY SCTBX1,X
 LDA TWOS,Y
 STA R
 LDY SCTBX2,X
 LDX P
 BEQ LIfudge
 LDA logL,X
 LDX Q
 SEC
 SBC logL,X
 LDX P
 LDA log,X
 LDX Q
 SBC log,X
 BCC P%+6
 LDA #$FF
 BNE LIlog2
 TAX
 LDA alogh,X

.LIlog2

 STA P

.LIfudge

 SEC
 LDX Q
 INX
 LDA X2
 SBC X1
 BCC LFT
 \....
 CLC
 LDA SWAP
 BEQ LI17
 DEX

.LIL5

 LDA R
 EOR (SC),Y
 STA (SC),Y

.LI17

 DEC T2
 BMI LI22
 LDA SC+1
 SBC #3
 STA SC+1
 CLC

.LI16

 LDA S
 ADC P
 STA S
 BCC LIC5
 ASL R
 BPL LIC5
 LDA #1
 STA R
 INY

.LIC5

 DEX
 BNE LIL5
 LDY YSAV
 RTS

.LI22

 LDA #7
 STA T2
 STX T
 LDX T1
 DEX
 STX T1
 LDA SCTBL,X
 STA SC
 LDA SCTBH2,X
 LDX T
 STA SC+1
 JMP LI16
 \.....

.LFT

 LDA SWAP
 BEQ LI18
 DEX

.LIL6

 LDA R
 EOR (SC),Y
 STA (SC),Y

.LI18

 DEC T2
 BMI LI23
 LDA SC+1
 SBC #3
 STA SC+1
 CLC

.LI19

 LDA S
 ADC P
 STA S
 BCC LIC6
 LSR R
 BCC LIC6
 LDA #64
 STA R
 DEY
 CLC

.LIC6

 DEX
 BNE LIL6
 LDY YSAV

.HL6

 RTS

.LI23

 LDA #7
 STA T2
 STX T
 LDX T1
 DEX
 STX T1
 LDA SCTBL,X
 STA SC
 LDA SCTBH2,X
 LDX T
 STA SC+1
 JMP LI19
 \...................................

.MSBARS

 JSR P%+3
 INC Y1
 \ ............HLOIN.......... 

.HLOIN

 STY YSAV
 LDA X1
 AND #$FE
 STA X1
 TAX
 LDA X2
 AND #$FE
 STA X2
 CMP X1
 BEQ HL6
 BCS HL5
 STX X2
 TAX

.HL5

 LDA Y1
 LSR A
 LSR A
 LSR A
 TAY
 LDA SCTBL,Y
 STA SC
 LDA Y1
 AND #7
 ASL A
 ASL A
 ADC SCTBH,Y
 STA SC+1
 LDA SCTBX2,X
 AND #1
 ORA COL
 TAY
 LDA MASKT,Y
 STA T1
 LDA MASKT+1,Y
 STA T2

.HL1

 LDY X2
 LDA SCTBX2-2,Y
 LDY SCTBX1,X
 SEC
 SBC SCTBX2,X
 STAR ;R = no bytes apart
 LDA TWFR,Y
 AND T1
 LDY SCTBX2,X
 LDX R
 BEQ HL3
 STA T4
 LDA (SC),Y
 AND #$7F
 EOR T4
 STA (SC),Y
 INY
 DEX
 BEQ HL4

.HLL1

 LDA (SC),Y
 AND #$7F
 EOR T2
 STA (SC),Y
 INY
 DEX
 BEQ HL8
 LDA (SC),Y
 AND #$7F
 EOR T1
 STA (SC),Y
 INY
 DEX
 BNE HLL1

.HL4

 LDA T2

.HL2

 LDX X2
 LDY SCTBX1-2,X
 CPY #6
 AND TWFL,Y
 LDY SCTBX2-2,X
 STA T4
 LDA (SC),Y
 AND #$7F
 EOR T4
 STA (SC),Y
 BCC HL7
 LDA #$81
 AND T1
 INY
 STA T4
 LDA (SC),Y
 AND #$7F
 EOR T4
 STA (SC),Y

.HL7

 LDY YSAV
 RTS

.HL8

 LDA T1

.HL3

 LDX T2
 STX T1
 JMP HL2
 \.....

.MASKT

 EQUD 0
 EQUD &552A55
 EQUD &2A552A
 EQUD &7F7F7F
 EQUD &D5AAD5
 EQUD &AAD5AA
 EQUD &AAAAAA

.VLOIN

 STY YSAV
 LDA Y1
 CMP Y2
 BCS VLO1
 LDY Y2
 STA Y2
 TYA

.VLO1

 LDX X1
 JSR CPIX
 LDA Y1
 SEC
 SBC Y2
 BEQ VLO5
 TAX
 INX
 JMP VLO4

.VLOL1

 LDA R
 EOR (SC),Y
 STA (SC),Y
 LDA T3
 BEQ VLO4
 INY
 EOR (SC),Y
 STA (SC),Y
 DEY

.VLO4

 DEC T2
 BMI VLO2
 LDA SC+1
 SEC
 SBC #4
 STA SC+1

.VLO3

 DEX
 BNE VLOL1

.VLO5

 LDY YSAV
 RTS

.VLO2

 LDA #7
 STA T2
 STX T
 LDX T1
 DEX
 STX T1
 LDA SCTBL,X
 STA SC
 LDA SCTBH2,X
 LDX T
 STA SC+1
 JMP VLO3
 \.....

.CPIX

 STA Y1
 LSR A
 LSR A
 LSR A
 STA T1
 TAY
 LDA SCTBL,Y
 STA SC
 LDA Y1
 AND #7
 STA T2
 ASL A
 ASL A
 ADC SCTBH,Y
 STA SC+1
 LDY SCTBX1,X
 LDA #0
 CPY #6
 BNE P%+4
 LDA #$81
 STA T3
 LDA TWOS2,Y
 STA R
 LDA SCTBX2,X
 AND #1
 ORA COL
 TAY
 LDA MASKT+1,Y
 AND T3
 STA T3
 LDA MASKT,Y
 AND R
 STA R
 LDY SCTBX2,X
 EOR (SC),Y
 STA (SC),Y
 LDA T3
 BEQ CPR1
 INY
 EOR (SC),Y
 STA (SC),Y
 DEY

.CPR1

 RTS
 \...................

 \...........

.ECBLB2

 LDA #32
 STA ECMA
;LDY #sfxecm
;JSR NOISE ; @@

.ECBLB

 LDA #(ECBT MOD 256)
 LDX #56
 BNE BULB

.SPBLB

 LDA #(SPBT MOD 256)
 LDX #192

.BULB

 STA P
 LDA #(SPBT DIV 256)
 STA P+1
 LDA #22
 STA YC
 JMP letter2

.ECBT

 EQUW $7F7F
 EQUB $07

.SPBT

 EQUD &7F077F7F
 EQUD &7F7F707F

.MSBAR

 TYA
 PHA
 JSR MSBAR2
 PLA
 STA mscol-1,X

.MSBAR2

 LDA mscol-1,X
 BEQ coolkey
 STA COL
 LDA msloc-1,X
 STA X1
 CLC
 ADC #6
 STA X2
 TXA
 PHA
 LDA #184
 STA Y1
 JSR MSBARS
 JSR MSBARS
 PLA
 TAX
 TYA
 LDY #0
 RTS

.msloc

 EQUB $28
 EQUB $20
 EQUB $18
 EQUB $10
 \....

.newosrdch

 JSR $FFFF
 CMP #128
 BCC P%+6

.badkey

 LDA #7
 CLC
 RTS
 CMP #32
 BCS coolkey
 CMP #13
 BEQ coolkey
 CMP #21
 BNE badkey

.coolkey

 CLC
 RTS
 \ADD AX = AP+SR  Should be in ELITEC (?)

 \..........Bay View.......... 

.WSCAN

IF _IB_DISK

 PHA
 TXA
 PHA
 TYA
 PHA
 LDY #$0F
 LDX #0

.LA087

 DEX
 BNE LA087
 DEY
 BNE LA087
 PLA
 TAY
 PLA
 TAX
 PLA

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 BIT $C019
 BPL WSCAN

.WSCL1

 BIT $C019
 BMI WSCL1

ENDIF

 RTS

 \ ............. Character Print ..................... 

.CHPR2

 CMP #123
 BCS whosentthisshit
 CMP #13
 BCC whosentthisshit
 BNE CHPR
 LDA #12
 JSR CHPR
 LDA #13

.whosentthisshit

 CLC
 RTS  ; tape CHPR

.R5

 JSR BEEP
 JMP RR4

.clss

 BIT text
 BPL clss1
 JSR cleartext
 LDA K3
 JMP RRafter

.clss1

 JSR cleargrap
 LDA K3
 JMP RRafter

.RR5

 \text chpr
 BIT UPTOG

IF _IB_DISK

 BMI RR7

ELIF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES OR _SOURCE_DISK_CODE_FILES

 BPL RR7

ENDIF

 CMP #$5B
 BCC RR7
 SBC #$20

.RR7

 ORA #128
 PHA
 LDA cellocl,Y
 STA SC
 TYA
 AND #7
 LSR A
 CLC
 ADC #4
 STA SC+1
 TXA
 TAY
 PLA
 STA (SC),Y
 JMP RR6

;.TT67
.TT67_copy     ; Renamed as there are two TT67s

 LDA #12

.CHPR

 STA K3
 STY YSAV2
 STX XSAV2
 LDY QQ17
 CPY #$FF
 BEQ RR4

.RRafter

 CMP #7
 BEQ R5
 CMP #32
 BCS RR1
 CMP #10
 BEQ RRX1

.RRX2

 LDX #1
 STX XC

.RRX1

 CMP #13
 BEQ RR4
 INC YC
 BNE RR4

.RR1

 LDX XC
 CPX #31
 BCC RRa
 JSR RRX2
 LDX XC ; David@@

.RRa

 LDY YC
 CPY #24
 BCS clss
 BIT text
 BMI RR5
 PHA
 LDA XC
 ASL A
 ASL A
 ASL A
 ADC #13
 SBC XC
 TAX  ;7*XC+12
 PLA
 JSR letter

.RR6

 INC XC

.RR4

 LDY YSAV2
 LDX XSAV2
 LDA K3
 CLC
 RTS ;must exit CHPR with C = 0
 \.....

.letter

 \plot character A at X,YC*8
 LDY #((FONT DIV 256)-1)
 ASL A
 ASL A
 BCC P%+4
 LDY #((FONT DIV 256)+1)
 ASL A
 BCC RR9
 INY

.RR9

;CLC 
;ADC #(FONT MOD 256)
 STA P
;BCC P%+3
;INY 
 STY P+1

.letter2

 LDY YC
 LDA SCTBL,Y
 STA SC
 LDA SCTBH,Y
 STA SC+1
 LDY SCTBX1,X
 STY P+2
 LDY SCTBX2,X
 STY T1
 LDY #0

.RRL1

 LDA #0
 STA T3
 LDA (P),Y
 LDX P+2

.RRL2

 CMP #128
 ROL T3
 DEX
 BMI RR8
 ASL A
 JMP RRL2

.RR8

 AND #127
 CLC
 STY T2
 LDY T1
 EOR (SC),Y
 STA (SC),Y
 INY
 LDA T3
 EOR (SC),Y
 STA (SC),Y
 LDY T2
 LDA SC+1
 ADC #4
 STA SC+1
 INY
 CPY #8
 BNE RRL1
 RTS
 \
 \.....TTX66K......
 \

.TTX66K

 LDA QQ11
 BEQ wantgrap
 CMP #13
 BEQ wantgrap
 AND #$C0
 BNE wantgrap
 JSR cleartext
 JMP TEXT

.cleartext

 LDY #0
 LDX #4
 STY SC
 STX SC+1
 LDA #160

.cleartextl

 STA (SC),Y
 INY
 BNE cleartextl
 INC SC+1
 DEX
 BNE cleartextl
 RTS
 \...........
 \....

.wantgrap

 JSR cleargrap
 JSR BOX
 JSR HGR
 RTS
 \........

.BOX

 LDX #0
 STX X1
 STX Y1
 DEX
 STX X2
 LDA #BLUE
 STA COL
 JSR HLOIN
 LDA #$AA
 STA SCBASE+1
 LDA #$AA
 STA SCBASE+37
 RTS
 \....
 \.......

.cleargrap

 LDY #16

.cleargl

 JSR clearrow
 DEY
 BPL cleargl
 INY
 STY XC
 STY YC
 RTS
 \....

.ZES1k

 LDY #0
 STY SC

.ZES2k

 LDA #0
 STX SC+1

.ZEL1k

 STA (SC),Y
 DEY
 BNE ZEL1k
 RTS

.ZESNEW

 LDA #0

.ZESNEWL

 STA (SC),Y
 INY
 BNE ZESNEWL
 RTS

IF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES

;.SETXC
;
;STA XC

 RTS  ;JMPPUTBACK

ELIF _IB_DISK OR _SOURCE_DISK_CODE_FILES

.SETXC

 STA XC

ENDIF

 RTS  ;JMPPUTBACK

IF _SOURCE_DISK_BUILD OR _SOURCE_DISK_ELT_FILES

;.SETYC
;
;STA YC

ELIF _IB_DISK OR _SOURCE_DISK_CODE_FILES

.SETYC

 STA YC

 RTS  ;JMPPUTBACK

ENDIF

.mvblockK

 LDY #0

.mvbllop

 LDA (V),Y
 STA (SC),Y
 DEY
 BNE mvbllop
 INC V+1
 INC SC+1
 DEX
 BNE mvbllop
 RTS  ;remember ELITEK has different SC!  (NO LONGER) 

.CLYNS

 LDA #0
 STA DLY
 STA de

.CLYNS2

 JSR CLYS1 ; @@
 LDA #$FF
 STA DTW2
 LDA #128
 STA QQ17
 LDA text
 BPL CLY1
 LDA #32
 LDX #64

.CLYL1

 JSR CHPR
 DEX
 BNE CLYL1

.CLYS1

 LDA #21
 STA YC
 LDA #1
 STA XC
 RTS
 \...

.CLY1

 LDY #15
 STY YC
 LDA #1
 STA XC
 JSR clearrow
 INY

.clearrow

 LDA #8
 STA T2
 LDX SCTBL,Y
 STX SC
 LDX SCTBH,Y
 TYA
 PHA

.cleargl2

 STX SC+1
 LDA #$A0
 LDY #37

.cleargl3

 STA (SC),Y
 LDA #0
 DEY
 BNE cleargl3
 LDA #$C0
 STA (SC),Y
 INY
 ASL A
 STA (SC),Y
 INX
 INX
 INX
 INX
 DEC T2
 BNE cleargl2
 PLA
 TAY

.SCR1

 RTS
 \................

.SCAN

;LDA QQ11
;BNE SCR1
 LDA INWK+31
 AND #16
 BEQ SCR1
 LDX TYPE
 BMI SCR1
 LDA scacol,X
 STA COL
 LDA INWK+1
 ORA INWK+4
 ORA INWK+7
 AND #$C0
 BNE SCR1
 LDA INWK+1
 CLC
 LDX INWK+2
 BPL SC2
 EOR #$FF
 ADC #1
 CLC

.SC2

 ADC #125
 AND #$FE
 STA X1
 TAX
 DEX
 DEX
 LDA INWK+7
 LSR A
 LSR A
 CLC
 LDY INWK+8
 BPL SC3
 EOR #$FF
 SEC

.SC3

 ADC #91 ;83
 EOR #$FF
 STA Y2
 LDA INWK+4
 LSR A
 CLC
 LDY INWK+5
 BMI SCD6
 EOR #$FF
 SEC

.SCD6

 ADC Y2
;BPL ld246
 CMP #146 ;194
 BCS P%+4
 LDA #146
 CMP #191 ;199
 BCC P%+4

.ld246

 LDA #190 ;198
 JSR CPIX
 JMP VLOIN
 \.......

.HGR

 LDA $C054
 LDA $C052
 LDA $C057
 LDA $C050
 LSR text
 RTS

.TEXT

 LDA $C054
 LDA $C051
 SEC
 ROR text
 RTS

.F%

IF _IB_DISK

 EQUB $83, $6F, $63, $6F, $75

ENDIF

; ******************************************************************************
;
; Save ELTK.bin
;
; ******************************************************************************

 PRINT "ELITE K"
 PRINT "Assembled at ", ~CODE_K%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_K%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_K%

 PRINT "S.ELTK ", ~CODE_K%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_J%
 SAVE "3-assembled-output/ELTK.bin", CODE_K%, P%, LOAD%

 PRINT "Addresses for the scramble routines in elite-checksum.py"
 PRINT "B% = ", ~CODE%
 PRINT "G% = ", ~G%
 PRINT "NA2% = ", ~NA2%

; ******************************************************************************
;
; ELITE SHIP BLUEPRINTS FILE
;
; Produces the binary file SHIPS.bin that gets loaded by elite-bcfs.asm.
;
; ******************************************************************************

 CODE_SHIPS% = D%

 LOAD_SHIPS% = LOAD% + D% - CODE%

 ORG D%

; ******************************************************************************
;
;       Name: XX21
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprints lookup table
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.XX21

 EQUW SHIP_MISSILE      ; MSL  =  1 = Missile
 EQUW SHIP_CORIOLIS     ; SST  =  2 = Coriolis space station
 EQUW SHIP_ESCAPE_POD   ; ESC  =  3 = Escape pod
 EQUW SHIP_PLATE        ; PLT  =  4 = Alloy plate
 EQUW SHIP_CANISTER     ; OIL  =  5 = Cargo canister
 EQUW SHIP_BOULDER      ;         6 = Boulder
 EQUW SHIP_ASTEROID     ; AST  =  7 = Asteroid
 EQUW SHIP_SPLINTER     ; SPL  =  8 = Splinter
 EQUW SHIP_SHUTTLE      ; SHU  =  9 = Shuttle
 EQUW SHIP_TRANSPORTER  ;        10 = Transporter
 EQUW SHIP_COBRA_MK_3   ; CYL  = 11 = Cobra Mk III
 EQUW SHIP_PYTHON       ;        12 = Python
 EQUW SHIP_BOA          ;        13 = Boa
 EQUW SHIP_ANACONDA     ; ANA  = 14 = Anaconda
 EQUW SHIP_ROCK_HERMIT  ; HER  = 15 = Rock hermit (asteroid)
 EQUW SHIP_VIPER        ; COPS = 16 = Viper
 EQUW SHIP_SIDEWINDER   ; SH3  = 17 = Sidewinder
 EQUW SHIP_MAMBA        ;        18 = Mamba
 EQUW SHIP_KRAIT        ; KRA  = 19 = Krait
 EQUW SHIP_ADDER        ; ADA  = 20 = Adder
 EQUW SHIP_GECKO        ;        21 = Gecko
 EQUW SHIP_COBRA_MK_1   ;        22 = Cobra Mk I
 EQUW SHIP_WORM         ; WRM  = 23 = Worm
 EQUW SHIP_COBRA_MK_3_P ; CYL2 = 24 = Cobra Mk III (pirate)
 EQUW SHIP_ASP_MK_2     ; ASP  = 25 = Asp Mk II
 EQUW SHIP_PYTHON_P     ;        26 = Python (pirate)
 EQUW SHIP_FER_DE_LANCE ;        27 = Fer-de-lance
 EQUW SHIP_MORAY        ;        28 = Moray
 EQUW SHIP_THARGOID     ; THG  = 29 = Thargoid
 EQUW SHIP_THARGON      ; TGL  = 30 = Thargon
 EQUW SHIP_CONSTRICTOR  ; CON  = 31 = Constrictor
 EQUW SHIP_DODO         ; DOD  = 33 = Dodecahedron ("Dodo") space station

; ******************************************************************************
;
;       Name: E%
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprints default NEWB flags
;  Deep dive: Ship blueprints
;             Advanced tactics with the NEWB flags
;
; ------------------------------------------------------------------------------
;
; When spawning a new ship, the bits from this table are applied to the new
; ship's NEWB flags in byte #36 (i.e. a set bit in this table will set that bit
; in the NEWB flags). In other words, if a ship blueprint is set to one of the
; following, then all spawned ships of that type will be too: trader, bounty
; hunter, hostile, pirate, innocent, cop.
;
; The NEWB flags are as follows:
;
;   * Bit 0: Trader flag (0 = not a trader, 1 = trader)
;   * Bit 1: Bounty hunter flag (0 = not a bounty hunter, 1 = bounty hunter)
;   * Bit 2: Hostile flag (0 = not hostile, 1 = hostile)
;   * Bit 3: Pirate flag (0 = not a pirate, 1 = pirate)
;   * Bit 4: Docking flag (0 = not docking, 1 = docking)
;   * Bit 5: Innocent bystander (0 = normal, 1 = innocent bystander)
;   * Bit 6: Cop flag (0 = not a cop, 1 = cop)
;   * Bit 7: For spawned ships: ship been scooped or has docked
;             For blueprints: this ship type has an escape pod fitted
;
; See the deep dive on "Advanced tactics with the NEWB flags" for details of
; how this works.
;
; ******************************************************************************

.E%

 EQUB %00000000         ; Missile
 EQUB %00000000         ; Coriolis space station
 EQUB %00000001         ; Escape pod                                      Trader
 EQUB %00000000         ; Alloy plate
 EQUB %00000000         ; Cargo canister
 EQUB %00000000         ; Boulder
 EQUB %00000000         ; Asteroid
 EQUB %00000000         ; Splinter
 EQUB %00100001         ; Shuttle                               Trader, innocent
 EQUB %01100001         ; Transporter                      Trader, innocent, cop
 EQUB %10100000         ; Cobra Mk III                      Innocent, escape pod
 EQUB %10100000         ; Python                            Innocent, escape pod
 EQUB %10100000         ; Boa                               Innocent, escape pod
 EQUB %10100001         ; Anaconda                  Trader, innocent, escape pod
 EQUB %10100001         ; Rock hermit (asteroid)    Trader, innocent, escape pod
 EQUB %11000010         ; Viper                   Bounty hunter, cop, escape pod
 EQUB %00001100         ; Sidewinder                             Hostile, pirate
 EQUB %10001100         ; Mamba                      Hostile, pirate, escape pod
 EQUB %10001100         ; Krait                      Hostile, pirate, escape pod
 EQUB %10001100         ; Adder                      Hostile, pirate, escape pod
 EQUB %00001100         ; Gecko                                  Hostile, pirate
 EQUB %10001100         ; Cobra Mk I                 Hostile, pirate, escape pod
 EQUB %00000101         ; Worm                                   Hostile, trader
 EQUB %10001100         ; Cobra Mk III (pirate)      Hostile, pirate, escape pod
 EQUB %10001100         ; Asp Mk II                  Hostile, pirate, escape pod
 EQUB %10001100         ; Python (pirate)            Hostile, pirate, escape pod
 EQUB %10000010         ; Fer-de-lance                 Bounty hunter, escape pod
 EQUB %00001100         ; Moray                                  Hostile, pirate
 EQUB %00001100         ; Thargoid                               Hostile, pirate
 EQUB %00000100         ; Thargon                                        Hostile
 EQUB %00000100         ; Constrictor                                    Hostile

 EQUB 0                 ; This byte appears to be unused

; ******************************************************************************
;
;       Name: KWL%
;       Type: Variable
;   Category: Status
;    Summary: Fractional number of kills awarded for destroying each type of
;             ship
;
; ------------------------------------------------------------------------------
;
; This figure contains the fractional part of the points that are added to the
; combat rank in TALLY when destroying a ship of this type. This is different to
; the original BBC Micro versions, where you always get a single combat point
; for everything you kill; in the Master version, it's more sophisticated.
;
; The integral part is stored in the KWH% table.
;
; Each fraction is stored as the numerator in a fraction with a denominator of
; 256, so 149 represents 149 / 256 = 0.58203125 points.
;
; ******************************************************************************

.KWL%

 EQUB 149               ; Missile                               0.58203125
 EQUB 0                 ; Coriolis space station                0.0
 EQUB 16                ; Escape pod                            0.0625
 EQUB 10                ; Alloy plate                           0.0390625
 EQUB 10                ; Cargo canister                        0.0390625
 EQUB 6                 ; Boulder                               0.0234375
 EQUB 8                 ; Asteroid                              0.03125
 EQUB 10                ; Splinter                              0.0390625
 EQUB 16                ; Shuttle                               0.0625
 EQUB 17                ; Transporter                           0.06640625
 EQUB 234               ; Cobra Mk III                          0.9140625
 EQUB 170               ; Python                                0.6640625
 EQUB 213               ; Boa                                   0.83203125
 EQUB 0                 ; Anaconda                              1.0
 EQUB 85                ; Rock hermit (asteroid)                0.33203125
 EQUB 26                ; Viper                                 0.1015625
 EQUB 85                ; Sidewinder                            0.33203125
 EQUB 128               ; Mamba                                 0.5
 EQUB 85                ; Krait                                 0.33203125
 EQUB 90                ; Adder                                 0.3515625
 EQUB 85                ; Gecko                                 0.33203125
 EQUB 170               ; Cobra Mk I                            0.6640625
 EQUB 50                ; Worm                                  0.1953125
 EQUB 42                ; Cobra Mk III (pirate)                 1.1640625
 EQUB 21                ; Asp Mk II                             1.08203125
 EQUB 42                ; Python (pirate)                       1.1640625
 EQUB 64                ; Fer-de-lance                          1.25
 EQUB 192               ; Moray                                 0.75
 EQUB 170               ; Thargoid                              2.6640625
 EQUB 33                ; Thargon                               0.12890625
 EQUB 85                ; Constrictor                           5.33203125
 EQUB 0                 ; Dodecahedron ("Dodo") space station   0.0

; ******************************************************************************
;
;       Name: KWH%
;       Type: Variable
;   Category: Status
;    Summary: Integer number of kills awarded for destroying each type of ship
;
; ------------------------------------------------------------------------------
;
; This figure contains the integer part of the points that are added to the
; combat rank in TALLY when destroying a ship of this type. This is different to
; the original BBC Micro versions, where you always get a single combat point
; for everything you kill; in the Master version, it's more sophisticated.
;
; The fractional part is stored in the KWL% table.
;
; ******************************************************************************

.KWH%

 EQUB 0                 ; Missile                               0.58203125
 EQUB 0                 ; Coriolis space station                0.0
 EQUB 0                 ; Escape pod                            0.0625
 EQUB 0                 ; Alloy plate                           0.0390625
 EQUB 0                 ; Cargo canister                        0.0390625
 EQUB 0                 ; Boulder                               0.0234375
 EQUB 0                 ; Asteroid                              0.03125
 EQUB 0                 ; Splinter                              0.0390625
 EQUB 0                 ; Shuttle                               0.0625
 EQUB 0                 ; Transporter                           0.06640625
 EQUB 0                 ; Cobra Mk III                          0.9140625
 EQUB 0                 ; Python                                0.6640625
 EQUB 0                 ; Boa                                   0.83203125
 EQUB 1                 ; Anaconda                              1.0
 EQUB 0                 ; Rock hermit (asteroid)                0.33203125
 EQUB 0                 ; Viper                                 0.1015625
 EQUB 0                 ; Sidewinder                            0.33203125
 EQUB 0                 ; Mamba                                 0.5
 EQUB 0                 ; Krait                                 0.33203125
 EQUB 0                 ; Adder                                 0.3515625
 EQUB 0                 ; Gecko                                 0.33203125
 EQUB 0                 ; Cobra Mk I                            0.6640625
 EQUB 0                 ; Worm                                  0.1953125
 EQUB 1                 ; Cobra Mk III (pirate)                 1.1640625
 EQUB 1                 ; Asp Mk II                             1.08203125
 EQUB 1                 ; Python (pirate)                       1.1640625
 EQUB 1                 ; Fer-de-lance                          1.25
 EQUB 0                 ; Moray                                 0.75
 EQUB 2                 ; Thargoid                              2.6640625
 EQUB 0                 ; Thargon                               0.12890625
 EQUB 5                 ; Constrictor                           5.33203125
 EQUB 0                 ; Dodecahedron ("Dodo") space station   0.0

; ******************************************************************************
;
;       Name: VERTEX
;       Type: Macro
;   Category: Drawing ships
;    Summary: Macro definition for adding vertices to ship blueprints
;  Deep dive: Ship blueprints
;
; ------------------------------------------------------------------------------
;
; The following macro is used to build the ship blueprints:
;
;   VERTEX x, y, z, face1, face2, face3, face4, visibility
;
; See the deep dive on "Ship blueprints" for details of how vertices are stored
; in the ship blueprints, and the deep dive on "Drawing ships" for information
; on how vertices are used to draw 3D wireframe ships.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   x                   The vertex's x-coordinate
;
;   y                   The vertex's y-coordinate
;
;   z                   The vertex's z-coordinate
;
;   face1               The number of face 1 associated with this vertex
;
;   face2               The number of face 2 associated with this vertex
;
;   face3               The number of face 3 associated with this vertex
;
;   face4               The number of face 4 associated with this vertex
;
;   visibility          The visibility distance, beyond which the vertex is not
;                       shown
;
; ******************************************************************************

MACRO VERTEX x, y, z, face1, face2, face3, face4, visibility

 IF x < 0
  s_x = 1 << 7
 ELSE
  s_x = 0
 ENDIF

 IF y < 0
  s_y = 1 << 6
 ELSE
  s_y = 0
 ENDIF

 IF z < 0
  s_z = 1 << 5
 ELSE
  s_z = 0
 ENDIF

 s = s_x + s_y + s_z + visibility
 f1 = face1 + (face2 << 4)
 f2 = face3 + (face4 << 4)
 ax = ABS(x)
 ay = ABS(y)
 az = ABS(z)

 EQUB ax, ay, az, s, f1, f2

ENDMACRO

; ******************************************************************************
;
;       Name: EDGE
;       Type: Macro
;   Category: Drawing ships
;    Summary: Macro definition for adding edges to ship blueprints
;  Deep dive: Ship blueprints
;
; ------------------------------------------------------------------------------
;
; The following macro is used to build the ship blueprints:
;
;   EDGE vertex1, vertex2, face1, face2, visibility
;
; See the deep dive on "Ship blueprints" for details of how edges are stored
; in the ship blueprints, and the deep dive on "Drawing ships" for information
; on how edges are used to draw 3D wireframe ships.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   vertex1             The number of the vertex at the start of the edge
;
;   vertex1             The number of the vertex at the end of the edge
;
;   face1               The number of face 1 associated with this edge
;
;   face2               The number of face 2 associated with this edge
;
;   visibility          The visibility distance, beyond which the edge is not
;                       shown
;
; ******************************************************************************

MACRO EDGE vertex1, vertex2, face1, face2, visibility

 f = face1 + (face2 << 4)
 EQUB visibility, f, vertex1 << 2, vertex2 << 2

ENDMACRO

; ******************************************************************************
;
;       Name: FACE
;       Type: Macro
;   Category: Drawing ships
;    Summary: Macro definition for adding faces to ship blueprints
;  Deep dive: Ship blueprints
;
; ------------------------------------------------------------------------------
;
; The following macro is used to build the ship blueprints:
;
;   FACE normal_x, normal_y, normal_z, visibility
;
; See the deep dive on "Ship blueprints" for details of how faces are stored
; in the ship blueprints, and the deep dive on "Drawing ships" for information
; on how faces are used to draw 3D wireframe ships.
;
; ------------------------------------------------------------------------------
;
; Arguments:
;
;   normal_x            The face normal's x-coordinate
;
;   normal_y            The face normal's y-coordinate
;
;   normal_z            The face normal's z-coordinate
;
;   visibility          The visibility distance, beyond which the edge is always
;                       shown
;
; ******************************************************************************

MACRO FACE normal_x, normal_y, normal_z, visibility

 IF normal_x < 0
  s_x = 1 << 7
 ELSE
  s_x = 0
 ENDIF

 IF normal_y < 0
  s_y = 1 << 6
 ELSE
  s_y = 0
 ENDIF

 IF normal_z < 0
  s_z = 1 << 5
 ELSE
  s_z = 0
 ENDIF

 s = s_x + s_y + s_z + visibility
 ax = ABS(normal_x)
 ay = ABS(normal_y)
 az = ABS(normal_z)

 EQUB s, ax, ay, az

ENDMACRO

; ******************************************************************************
;
;       Name: SHIP_MISSILE
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a missile
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_MISSILE

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 40 * 40           ; Targetable area          = 40 * 40

 EQUB LO(SHIP_MISSILE_EDGES - SHIP_MISSILE)        ; Edges data offset (low)
 EQUB LO(SHIP_MISSILE_FACES - SHIP_MISSILE)        ; Faces data offset (low)

 EQUB 85                ; Max. edge count          = (85 - 1) / 4 = 21
 EQUB 0                 ; Gun vertex               = 0
 EQUB 10                ; Explosion count          = 1, as (4 * n) + 6 = 10
 EQUB 102               ; Number of vertices       = 102 / 6 = 17
 EQUB 24                ; Number of edges          = 24
 EQUW 0                 ; Bounty                   = 0
 EQUB 36                ; Number of faces          = 36 / 4 = 9
 EQUB 14                ; Visibility distance      = 14
 EQUB 2                 ; Max. energy              = 2
 EQUB 44                ; Max. speed               = 44

 EQUB HI(SHIP_MISSILE_EDGES - SHIP_MISSILE)        ; Edges data offset (high)
 EQUB HI(SHIP_MISSILE_FACES - SHIP_MISSILE)        ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_MISSILE_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,   68,     0,      1,    2,     3,         31    ; Vertex 0
 VERTEX    8,   -8,   36,     1,      2,    4,     5,         31    ; Vertex 1
 VERTEX    8,    8,   36,     2,      3,    4,     7,         31    ; Vertex 2
 VERTEX   -8,    8,   36,     0,      3,    6,     7,         31    ; Vertex 3
 VERTEX   -8,   -8,   36,     0,      1,    5,     6,         31    ; Vertex 4
 VERTEX    8,    8,  -44,     4,      7,    8,     8,         31    ; Vertex 5
 VERTEX    8,   -8,  -44,     4,      5,    8,     8,         31    ; Vertex 6
 VERTEX   -8,   -8,  -44,     5,      6,    8,     8,         31    ; Vertex 7
 VERTEX   -8,    8,  -44,     6,      7,    8,     8,         31    ; Vertex 8
 VERTEX   12,   12,  -44,     4,      7,    8,     8,          8    ; Vertex 9
 VERTEX   12,  -12,  -44,     4,      5,    8,     8,          8    ; Vertex 10
 VERTEX  -12,  -12,  -44,     5,      6,    8,     8,          8    ; Vertex 11
 VERTEX  -12,   12,  -44,     6,      7,    8,     8,          8    ; Vertex 12
 VERTEX   -8,    8,  -12,     6,      7,    7,     7,          8    ; Vertex 13
 VERTEX   -8,   -8,  -12,     5,      6,    6,     6,          8    ; Vertex 14
 VERTEX    8,    8,  -12,     4,      7,    7,     7,          8    ; Vertex 15
 VERTEX    8,   -8,  -12,     4,      5,    5,     5,          8    ; Vertex 16

.SHIP_MISSILE_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     1,     2,         31    ; Edge 0
 EDGE       0,       2,     2,     3,         31    ; Edge 1
 EDGE       0,       3,     0,     3,         31    ; Edge 2
 EDGE       0,       4,     0,     1,         31    ; Edge 3
 EDGE       1,       2,     4,     2,         31    ; Edge 4
 EDGE       1,       4,     1,     5,         31    ; Edge 5
 EDGE       3,       4,     0,     6,         31    ; Edge 6
 EDGE       2,       3,     3,     7,         31    ; Edge 7
 EDGE       2,       5,     4,     7,         31    ; Edge 8
 EDGE       1,       6,     4,     5,         31    ; Edge 9
 EDGE       4,       7,     5,     6,         31    ; Edge 10
 EDGE       3,       8,     6,     7,         31    ; Edge 11
 EDGE       7,       8,     6,     8,         31    ; Edge 12
 EDGE       5,       8,     7,     8,         31    ; Edge 13
 EDGE       5,       6,     4,     8,         31    ; Edge 14
 EDGE       6,       7,     5,     8,         31    ; Edge 15
 EDGE       6,      10,     5,     8,          8    ; Edge 16
 EDGE       5,       9,     7,     8,          8    ; Edge 17
 EDGE       8,      12,     7,     8,          8    ; Edge 18
 EDGE       7,      11,     5,     8,          8    ; Edge 19
 EDGE       9,      15,     4,     7,          8    ; Edge 20
 EDGE      10,      16,     4,     5,          8    ; Edge 21
 EDGE      12,      13,     6,     7,          8    ; Edge 22
 EDGE      11,      14,     5,     6,          8    ; Edge 23

.SHIP_MISSILE_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE      -64,        0,       16,         31    ; Face 0
 FACE        0,      -64,       16,         31    ; Face 1
 FACE       64,        0,       16,         31    ; Face 2
 FACE        0,       64,       16,         31    ; Face 3
 FACE       32,        0,        0,         31    ; Face 4
 FACE        0,      -32,        0,         31    ; Face 5
 FACE      -32,        0,        0,         31    ; Face 6
 FACE        0,       32,        0,         31    ; Face 7
 FACE        0,        0,     -176,         31    ; Face 8

; ******************************************************************************
;
;       Name: SHIP_CORIOLIS
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Coriolis space station
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_CORIOLIS

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 160 * 160         ; Targetable area          = 160 * 160

 EQUB LO(SHIP_CORIOLIS_EDGES - SHIP_CORIOLIS)      ; Edges data offset (low)
 EQUB LO(SHIP_CORIOLIS_FACES - SHIP_CORIOLIS)      ; Faces data offset (low)

 EQUB 89                ; Max. edge count          = (89 - 1) / 4 = 22
 EQUB 0                 ; Gun vertex               = 0
 EQUB 54                ; Explosion count          = 12, as (4 * n) + 6 = 54
 EQUB 96                ; Number of vertices       = 96 / 6 = 16
 EQUB 28                ; Number of edges          = 28
 EQUW 0                 ; Bounty                   = 0
 EQUB 56                ; Number of faces          = 56 / 4 = 14
 EQUB 120               ; Visibility distance      = 120
 EQUB 240               ; Max. energy              = 240
 EQUB 0                 ; Max. speed               = 0

 EQUB HI(SHIP_CORIOLIS_EDGES - SHIP_CORIOLIS)      ; Edges data offset (high)
 EQUB HI(SHIP_CORIOLIS_FACES - SHIP_CORIOLIS)      ; Faces data offset (high)

 EQUB 0                 ; Normals are scaled by    = 2^0 = 1
 EQUB %00000110         ; Laser power              = 0
                        ; Missiles                 = 6

.SHIP_CORIOLIS_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  160,    0,  160,     0,      1,    2,     6,         31    ; Vertex 0
 VERTEX    0,  160,  160,     0,      2,    3,     8,         31    ; Vertex 1
 VERTEX -160,    0,  160,     0,      3,    4,     7,         31    ; Vertex 2
 VERTEX    0, -160,  160,     0,      1,    4,     5,         31    ; Vertex 3
 VERTEX  160, -160,    0,     1,      5,    6,    10,         31    ; Vertex 4
 VERTEX  160,  160,    0,     2,      6,    8,    11,         31    ; Vertex 5
 VERTEX -160,  160,    0,     3,      7,    8,    12,         31    ; Vertex 6
 VERTEX -160, -160,    0,     4,      5,    7,     9,         31    ; Vertex 7
 VERTEX  160,    0, -160,     6,     10,   11,    13,         31    ; Vertex 8
 VERTEX    0,  160, -160,     8,     11,   12,    13,         31    ; Vertex 9
 VERTEX -160,    0, -160,     7,      9,   12,    13,         31    ; Vertex 10
 VERTEX    0, -160, -160,     5,      9,   10,    13,         31    ; Vertex 11
 VERTEX   10,  -30,  160,     0,      0,    0,     0,         30    ; Vertex 12
 VERTEX   10,   30,  160,     0,      0,    0,     0,         30    ; Vertex 13
 VERTEX  -10,   30,  160,     0,      0,    0,     0,         30    ; Vertex 14
 VERTEX  -10,  -30,  160,     0,      0,    0,     0,         30    ; Vertex 15

.SHIP_CORIOLIS_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       3,     0,     1,         31    ; Edge 0
 EDGE       0,       1,     0,     2,         31    ; Edge 1
 EDGE       1,       2,     0,     3,         31    ; Edge 2
 EDGE       2,       3,     0,     4,         31    ; Edge 3
 EDGE       3,       4,     1,     5,         31    ; Edge 4
 EDGE       0,       4,     1,     6,         31    ; Edge 5
 EDGE       0,       5,     2,     6,         31    ; Edge 6
 EDGE       5,       1,     2,     8,         31    ; Edge 7
 EDGE       1,       6,     3,     8,         31    ; Edge 8
 EDGE       2,       6,     3,     7,         31    ; Edge 9
 EDGE       2,       7,     4,     7,         31    ; Edge 10
 EDGE       3,       7,     4,     5,         31    ; Edge 11
 EDGE       8,      11,    10,    13,         31    ; Edge 12
 EDGE       8,       9,    11,    13,         31    ; Edge 13
 EDGE       9,      10,    12,    13,         31    ; Edge 14
 EDGE      10,      11,     9,    13,         31    ; Edge 15
 EDGE       4,      11,     5,    10,         31    ; Edge 16
 EDGE       4,       8,     6,    10,         31    ; Edge 17
 EDGE       5,       8,     6,    11,         31    ; Edge 18
 EDGE       5,       9,     8,    11,         31    ; Edge 19
 EDGE       6,       9,     8,    12,         31    ; Edge 20
 EDGE       6,      10,     7,    12,         31    ; Edge 21
 EDGE       7,      10,     7,     9,         31    ; Edge 22
 EDGE       7,      11,     5,     9,         31    ; Edge 23
 EDGE      12,      13,     0,     0,         30    ; Edge 24
 EDGE      13,      14,     0,     0,         30    ; Edge 25
 EDGE      14,      15,     0,     0,         30    ; Edge 26
 EDGE      15,      12,     0,     0,         30    ; Edge 27

.SHIP_CORIOLIS_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,        0,      160,         31    ; Face 0
 FACE      107,     -107,      107,         31    ; Face 1
 FACE      107,      107,      107,         31    ; Face 2
 FACE     -107,      107,      107,         31    ; Face 3
 FACE     -107,     -107,      107,         31    ; Face 4
 FACE        0,     -160,        0,         31    ; Face 5
 FACE      160,        0,        0,         31    ; Face 6
 FACE     -160,        0,        0,         31    ; Face 7
 FACE        0,      160,        0,         31    ; Face 8
 FACE     -107,     -107,     -107,         31    ; Face 9
 FACE      107,     -107,     -107,         31    ; Face 10
 FACE      107,      107,     -107,         31    ; Face 11
 FACE     -107,      107,     -107,         31    ; Face 12
 FACE        0,        0,     -160,         31    ; Face 13

; ******************************************************************************
;
;       Name: SHIP_ESCAPE_POD
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for an escape pod
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_ESCAPE_POD

 EQUB 0 + (2 << 4)      ; Max. canisters on demise = 0
                        ; Market item when scooped = 2 + 1 = 3 (slaves)
 EQUW 16 * 16           ; Targetable area          = 16 * 16

 EQUB LO(SHIP_ESCAPE_POD_EDGES - SHIP_ESCAPE_POD)  ; Edges data offset (low)
 EQUB LO(SHIP_ESCAPE_POD_FACES - SHIP_ESCAPE_POD)  ; Faces data offset (low)

 EQUB 29                ; Max. edge count          = (29 - 1) / 4 = 7
 EQUB 0                 ; Gun vertex               = 0
 EQUB 22                ; Explosion count          = 4, as (4 * n) + 6 = 22
 EQUB 24                ; Number of vertices       = 24 / 6 = 4
 EQUB 6                 ; Number of edges          = 6
 EQUW 0                 ; Bounty                   = 0
 EQUB 16                ; Number of faces          = 16 / 4 = 4
 EQUB 8                 ; Visibility distance      = 8
 EQUB 17                ; Max. energy              = 17
 EQUB 8                 ; Max. speed               = 8

 EQUB HI(SHIP_ESCAPE_POD_EDGES - SHIP_ESCAPE_POD)  ; Edges data offset (high)
 EQUB HI(SHIP_ESCAPE_POD_FACES - SHIP_ESCAPE_POD)  ; Faces data offset (high)

 EQUB 4                 ; Normals are scaled by    =  2^4 = 16
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_ESCAPE_POD_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   -7,    0,   36,     2,      1,    3,     3,         31    ; Vertex 0
 VERTEX   -7,  -14,  -12,     2,      0,    3,     3,         31    ; Vertex 1
 VERTEX   -7,   14,  -12,     1,      0,    3,     3,         31    ; Vertex 2
 VERTEX   21,    0,    0,     1,      0,    2,     2,         31    ; Vertex 3

.SHIP_ESCAPE_POD_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     3,     2,         31    ; Edge 0
 EDGE       1,       2,     3,     0,         31    ; Edge 1
 EDGE       2,       3,     1,     0,         31    ; Edge 2
 EDGE       3,       0,     2,     1,         31    ; Edge 3
 EDGE       0,       2,     3,     1,         31    ; Edge 4
 EDGE       3,       1,     2,     0,         31    ; Edge 5

.SHIP_ESCAPE_POD_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE       52,        0,     -122,         31    ; Face 0
 FACE       39,      103,       30,         31    ; Face 1
 FACE       39,     -103,       30,         31    ; Face 2
 FACE     -112,        0,        0,         31    ; Face 3

; ******************************************************************************
;
;       Name: SHIP_PLATE
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for an alloy plate
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_PLATE

 EQUB 0 + (8 << 4)      ; Max. canisters on demise = 0
                        ; Market item when scooped = 8 + 1 = 9 (Alloys)
 EQUW 10 * 10           ; Targetable area          = 10 * 10

 EQUB LO(SHIP_PLATE_EDGES - SHIP_PLATE)            ; Edges data offset (low)
 EQUB LO(SHIP_PLATE_FACES - SHIP_PLATE)            ; Faces data offset (low)

 EQUB 21                ; Max. edge count          = (21 - 1) / 4 = 5
 EQUB 0                 ; Gun vertex               = 0
 EQUB 10                ; Explosion count          = 1, as (4 * n) + 6 = 10
 EQUB 24                ; Number of vertices       = 24 / 6 = 4
 EQUB 4                 ; Number of edges          = 4
 EQUW 0                 ; Bounty                   = 0
 EQUB 4                 ; Number of faces          = 4 / 4 = 1
 EQUB 5                 ; Visibility distance      = 5
 EQUB 16                ; Max. energy              = 16
 EQUB 16                ; Max. speed               = 16

 EQUB HI(SHIP_PLATE_EDGES - SHIP_PLATE)            ; Edges data offset (high)
 EQUB HI(SHIP_PLATE_FACES - SHIP_PLATE)            ; Faces data offset (high)

 EQUB 3                 ; Normals are scaled by    = 2^3 = 8
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_PLATE_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -15,  -22,   -9,    15,     15,   15,    15,         31    ; Vertex 0
 VERTEX  -15,   38,   -9,    15,     15,   15,    15,         31    ; Vertex 1
 VERTEX   19,   32,   11,    15,     15,   15,    15,         20    ; Vertex 2
 VERTEX   10,  -46,    6,    15,     15,   15,    15,         20    ; Vertex 3

.SHIP_PLATE_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,    15,    15,         31    ; Edge 0
 EDGE       1,       2,    15,    15,         16    ; Edge 1
 EDGE       2,       3,    15,    15,         20    ; Edge 2
 EDGE       3,       0,    15,    15,         16    ; Edge 3

.SHIP_PLATE_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,        0,        0,          0    ; Face 0

; ******************************************************************************
;
;       Name: SHIP_CANISTER
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a cargo canister
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_CANISTER

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 20 * 20           ; Targetable area          = 20 * 20

 EQUB LO(SHIP_CANISTER_EDGES - SHIP_CANISTER)      ; Edges data offset (low)
 EQUB LO(SHIP_CANISTER_FACES - SHIP_CANISTER)      ; Faces data offset (low)

 EQUB 53                ; Max. edge count          = (53 - 1) / 4 = 13
 EQUB 0                 ; Gun vertex               = 0
 EQUB 18                ; Explosion count          = 3, as (4 * n) + 6 = 18
 EQUB 60                ; Number of vertices       = 60 / 6 = 10
 EQUB 15                ; Number of edges          = 15
 EQUW 0                 ; Bounty                   = 0
 EQUB 28                ; Number of faces          = 28 / 4 = 7
 EQUB 12                ; Visibility distance      = 12
 EQUB 17                ; Max. energy              = 17
 EQUB 15                ; Max. speed               = 15

 EQUB HI(SHIP_CANISTER_EDGES - SHIP_CANISTER)      ; Edges data offset (high)
 EQUB HI(SHIP_CANISTER_FACES - SHIP_CANISTER)      ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_CANISTER_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   24,   16,    0,     0,      1,    5,     5,         31    ; Vertex 0
 VERTEX   24,    5,   15,     0,      1,    2,     2,         31    ; Vertex 1
 VERTEX   24,  -13,    9,     0,      2,    3,     3,         31    ; Vertex 2
 VERTEX   24,  -13,   -9,     0,      3,    4,     4,         31    ; Vertex 3
 VERTEX   24,    5,  -15,     0,      4,    5,     5,         31    ; Vertex 4
 VERTEX  -24,   16,    0,     1,      5,    6,     6,         31    ; Vertex 5
 VERTEX  -24,    5,   15,     1,      2,    6,     6,         31    ; Vertex 6
 VERTEX  -24,  -13,    9,     2,      3,    6,     6,         31    ; Vertex 7
 VERTEX  -24,  -13,   -9,     3,      4,    6,     6,         31    ; Vertex 8
 VERTEX  -24,    5,  -15,     4,      5,    6,     6,         31    ; Vertex 9

.SHIP_CANISTER_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     0,     1,         31    ; Edge 0
 EDGE       1,       2,     0,     2,         31    ; Edge 1
 EDGE       2,       3,     0,     3,         31    ; Edge 2
 EDGE       3,       4,     0,     4,         31    ; Edge 3
 EDGE       0,       4,     0,     5,         31    ; Edge 4
 EDGE       0,       5,     1,     5,         31    ; Edge 5
 EDGE       1,       6,     1,     2,         31    ; Edge 6
 EDGE       2,       7,     2,     3,         31    ; Edge 7
 EDGE       3,       8,     3,     4,         31    ; Edge 8
 EDGE       4,       9,     4,     5,         31    ; Edge 9
 EDGE       5,       6,     1,     6,         31    ; Edge 10
 EDGE       6,       7,     2,     6,         31    ; Edge 11
 EDGE       7,       8,     3,     6,         31    ; Edge 12
 EDGE       8,       9,     4,     6,         31    ; Edge 13
 EDGE       9,       5,     5,     6,         31    ; Edge 14

.SHIP_CANISTER_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE       96,        0,        0,         31    ; Face 0
 FACE        0,       41,       30,         31    ; Face 1
 FACE        0,      -18,       48,         31    ; Face 2
 FACE        0,      -51,        0,         31    ; Face 3
 FACE        0,      -18,      -48,         31    ; Face 4
 FACE        0,       41,      -30,         31    ; Face 5
 FACE      -96,        0,        0,         31    ; Face 6

; ******************************************************************************
;
;       Name: SHIP_BOULDER
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a boulder
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_BOULDER

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 30 * 30           ; Targetable area          = 30 * 30

 EQUB LO(SHIP_BOULDER_EDGES - SHIP_BOULDER)        ; Edges data offset (low)
 EQUB LO(SHIP_BOULDER_FACES - SHIP_BOULDER)        ; Faces data offset (low)

 EQUB 49                ; Max. edge count          = (49 - 1) / 4 = 12
 EQUB 0                 ; Gun vertex               = 0
 EQUB 14                ; Explosion count          = 2, as (4 * n) + 6 = 14
 EQUB 42                ; Number of vertices       = 42 / 6 = 7
 EQUB 15                ; Number of edges          = 15
 EQUW 1                 ; Bounty                   = 1
 EQUB 40                ; Number of faces          = 40 / 4 = 10
 EQUB 20                ; Visibility distance      = 20
 EQUB 20                ; Max. energy              = 20
 EQUB 30                ; Max. speed               = 30

 EQUB HI(SHIP_BOULDER_EDGES - SHIP_BOULDER)        ; Edges data offset (high)
 EQUB HI(SHIP_BOULDER_FACES - SHIP_BOULDER)        ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_BOULDER_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -18,   37,  -11,     1,      0,    9,     5,         31    ; Vertex 0
 VERTEX   30,    7,   12,     2,      1,    6,     5,         31    ; Vertex 1
 VERTEX   28,   -7,  -12,     3,      2,    7,     6,         31    ; Vertex 2
 VERTEX    2,    0,  -39,     4,      3,    8,     7,         31    ; Vertex 3
 VERTEX  -28,   34,  -30,     4,      0,    9,     8,         31    ; Vertex 4
 VERTEX    5,  -10,   13,    15,     15,   15,    15,         31    ; Vertex 5
 VERTEX   20,   17,  -30,    15,     15,   15,    15,         31    ; Vertex 6

.SHIP_BOULDER_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     5,     1,         31    ; Edge 0
 EDGE       1,       2,     6,     2,         31    ; Edge 1
 EDGE       2,       3,     7,     3,         31    ; Edge 2
 EDGE       3,       4,     8,     4,         31    ; Edge 3
 EDGE       4,       0,     9,     0,         31    ; Edge 4
 EDGE       0,       5,     1,     0,         31    ; Edge 5
 EDGE       1,       5,     2,     1,         31    ; Edge 6
 EDGE       2,       5,     3,     2,         31    ; Edge 7
 EDGE       3,       5,     4,     3,         31    ; Edge 8
 EDGE       4,       5,     4,     0,         31    ; Edge 9
 EDGE       0,       6,     9,     5,         31    ; Edge 10
 EDGE       1,       6,     6,     5,         31    ; Edge 11
 EDGE       2,       6,     7,     6,         31    ; Edge 12
 EDGE       3,       6,     8,     7,         31    ; Edge 13
 EDGE       4,       6,     9,     8,         31    ; Edge 14

.SHIP_BOULDER_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE      -15,       -3,        8,         31    ; Face 0
 FACE       -7,       12,       30,         31    ; Face 1
 FACE       32,      -47,       24,         31    ; Face 2
 FACE       -3,      -39,       -7,         31    ; Face 3
 FACE       -5,       -4,       -1,         31    ; Face 4
 FACE       49,       84,        8,         31    ; Face 5
 FACE      112,       21,      -21,         31    ; Face 6
 FACE       76,      -35,      -82,         31    ; Face 7
 FACE       22,       56,     -137,         31    ; Face 8
 FACE       40,      110,      -38,         31    ; Face 9

; ******************************************************************************
;
;       Name: SHIP_ASTEROID
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for an asteroid
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_ASTEROID

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 80 * 80           ; Targetable area          = 80 * 80

 EQUB LO(SHIP_ASTEROID_EDGES - SHIP_ASTEROID)      ; Edges data offset (low)
 EQUB LO(SHIP_ASTEROID_FACES - SHIP_ASTEROID)      ; Faces data offset (low)

 EQUB 69                ; Max. edge count          = (69 - 1) / 4 = 17
 EQUB 0                 ; Gun vertex               = 0
 EQUB 34                ; Explosion count          = 7, as (4 * n) + 6 = 34
 EQUB 54                ; Number of vertices       = 54 / 6 = 9
 EQUB 21                ; Number of edges          = 21
 EQUW 5                 ; Bounty                   = 5
 EQUB 56                ; Number of faces          = 56 / 4 = 14
 EQUB 50                ; Visibility distance      = 50
 EQUB 60                ; Max. energy              = 60
 EQUB 30                ; Max. speed               = 30

 EQUB HI(SHIP_ASTEROID_EDGES - SHIP_ASTEROID)      ; Edges data offset (high)
 EQUB HI(SHIP_ASTEROID_FACES - SHIP_ASTEROID)      ; Faces data offset (high)

 EQUB 1                 ; Normals are scaled by    = 2^1 = 2
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_ASTEROID_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,   80,    0,    15,     15,   15,    15,         31    ; Vertex 0
 VERTEX  -80,  -10,    0,    15,     15,   15,    15,         31    ; Vertex 1
 VERTEX    0,  -80,    0,    15,     15,   15,    15,         31    ; Vertex 2
 VERTEX   70,  -40,    0,    15,     15,   15,    15,         31    ; Vertex 3
 VERTEX   60,   50,    0,     5,      6,   12,    13,         31    ; Vertex 4
 VERTEX   50,    0,   60,    15,     15,   15,    15,         31    ; Vertex 5
 VERTEX  -40,    0,   70,     0,      1,    2,     3,         31    ; Vertex 6
 VERTEX    0,   30,  -75,    15,     15,   15,    15,         31    ; Vertex 7
 VERTEX    0,  -50,  -60,     8,      9,   10,    11,         31    ; Vertex 8

.SHIP_ASTEROID_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     2,     7,         31    ; Edge 0
 EDGE       0,       4,     6,    13,         31    ; Edge 1
 EDGE       3,       4,     5,    12,         31    ; Edge 2
 EDGE       2,       3,     4,    11,         31    ; Edge 3
 EDGE       1,       2,     3,    10,         31    ; Edge 4
 EDGE       1,       6,     2,     3,         31    ; Edge 5
 EDGE       2,       6,     1,     3,         31    ; Edge 6
 EDGE       2,       5,     1,     4,         31    ; Edge 7
 EDGE       5,       6,     0,     1,         31    ; Edge 8
 EDGE       0,       5,     0,     6,         31    ; Edge 9
 EDGE       3,       5,     4,     5,         31    ; Edge 10
 EDGE       0,       6,     0,     2,         31    ; Edge 11
 EDGE       4,       5,     5,     6,         31    ; Edge 12
 EDGE       1,       8,     8,    10,         31    ; Edge 13
 EDGE       1,       7,     7,     8,         31    ; Edge 14
 EDGE       0,       7,     7,    13,         31    ; Edge 15
 EDGE       4,       7,    12,    13,         31    ; Edge 16
 EDGE       3,       7,     9,    12,         31    ; Edge 17
 EDGE       3,       8,     9,    11,         31    ; Edge 18
 EDGE       2,       8,    10,    11,         31    ; Edge 19
 EDGE       7,       8,     8,     9,         31    ; Edge 20

.SHIP_ASTEROID_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        9,       66,       81,         31    ; Face 0
 FACE        9,      -66,       81,         31    ; Face 1
 FACE      -72,       64,       31,         31    ; Face 2
 FACE      -64,      -73,       47,         31    ; Face 3
 FACE       45,      -79,       65,         31    ; Face 4
 FACE      135,       15,       35,         31    ; Face 5
 FACE       38,       76,       70,         31    ; Face 6
 FACE      -66,       59,      -39,         31    ; Face 7
 FACE      -67,      -15,      -80,         31    ; Face 8
 FACE       66,      -14,      -75,         31    ; Face 9
 FACE      -70,      -80,      -40,         31    ; Face 10
 FACE       58,     -102,      -51,         31    ; Face 11
 FACE       81,        9,      -67,         31    ; Face 12
 FACE       47,       94,      -63,         31    ; Face 13

; ******************************************************************************
;
;       Name: SHIP_SPLINTER
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a splinter
;  Deep dive: Ship blueprints
;
; ------------------------------------------------------------------------------
;
; The ship blueprint for the splinter reuses the edges data from the escape pod,
; so the edges data offset is negative.
;
; ******************************************************************************

.SHIP_SPLINTER

 EQUB 0 + (11 << 4)     ; Max. canisters on demise = 0
                        ; Market item when scooped = 11 + 1 = 12 (Minerals)
 EQUW 16 * 16           ; Targetable area          = 16 * 16

 EQUB LO(SHIP_ESCAPE_POD_EDGES - SHIP_SPLINTER)    ; Edges from escape pod
 EQUB LO(SHIP_SPLINTER_FACES - SHIP_SPLINTER) + 24 ; Faces data offset (low)

 EQUB 29                ; Max. edge count          = (29 - 1) / 4 = 7
 EQUB 0                 ; Gun vertex               = 0
 EQUB 22                ; Explosion count          = 4, as (4 * n) + 6 = 22
 EQUB 24                ; Number of vertices       = 24 / 6 = 4
 EQUB 6                 ; Number of edges          = 6
 EQUW 0                 ; Bounty                   = 0
 EQUB 16                ; Number of faces          = 16 / 4 = 4
 EQUB 8                 ; Visibility distance      = 8
 EQUB 20                ; Max. energy              = 20
 EQUB 10                ; Max. speed               = 10

 EQUB HI(SHIP_ESCAPE_POD_EDGES - SHIP_SPLINTER)    ; Edges from escape pod
 EQUB HI(SHIP_SPLINTER_FACES - SHIP_SPLINTER)      ; Faces data offset (low)

 EQUB 5                 ; Normals are scaled by    = 2^5 = 32
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_SPLINTER_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -24,  -25,   16,     2,      1,    3,     3,         31    ; Vertex 0
 VERTEX    0,   12,  -10,     2,      0,    3,     3,         31    ; Vertex 1
 VERTEX   11,   -6,    2,     1,      0,    3,     3,         31    ; Vertex 2
 VERTEX   12,   42,    7,     1,      0,    2,     2,         31    ; Vertex 3

.SHIP_SPLINTER_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE       35,        0,        4,         31    ; Face 0
 FACE        3,        4,        8,         31    ; Face 1
 FACE        1,        8,       12,         31    ; Face 2
 FACE       18,       12,        0,         31    ; Face 3

; ******************************************************************************
;
;       Name: SHIP_SHUTTLE
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Shuttle
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_SHUTTLE

 EQUB 15                ; Max. canisters on demise = 15
 EQUW 50 * 50           ; Targetable area          = 50 * 50

 EQUB LO(SHIP_SHUTTLE_EDGES - SHIP_SHUTTLE)        ; Edges data offset (low)
 EQUB LO(SHIP_SHUTTLE_FACES - SHIP_SHUTTLE)        ; Faces data offset (low)

 EQUB 113               ; Max. edge count          = (113 - 1) / 4 = 28
 EQUB 0                 ; Gun vertex               = 0
 EQUB 38                ; Explosion count          = 8, as (4 * n) + 6 = 38
 EQUB 114               ; Number of vertices       = 114 / 6 = 19
 EQUB 30                ; Number of edges          = 30
 EQUW 0                 ; Bounty                   = 0
 EQUB 52                ; Number of faces          = 52 / 4 = 13
 EQUB 22                ; Visibility distance      = 22
 EQUB 32                ; Max. energy              = 32
 EQUB 8                 ; Max. speed               = 8

 EQUB HI(SHIP_SHUTTLE_EDGES - SHIP_SHUTTLE)        ; Edges data offset (high)
 EQUB HI(SHIP_SHUTTLE_FACES - SHIP_SHUTTLE)        ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_SHUTTLE_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,  -17,   23,    15,     15,   15,    15,         31    ; Vertex 0
 VERTEX  -17,    0,   23,    15,     15,   15,    15,         31    ; Vertex 1
 VERTEX    0,   18,   23,    15,     15,   15,    15,         31    ; Vertex 2
 VERTEX   18,    0,   23,    15,     15,   15,    15,         31    ; Vertex 3
 VERTEX  -20,  -20,  -27,     2,      1,    9,     3,         31    ; Vertex 4
 VERTEX  -20,   20,  -27,     4,      3,    9,     5,         31    ; Vertex 5
 VERTEX   20,   20,  -27,     6,      5,    9,     7,         31    ; Vertex 6
 VERTEX   20,  -20,  -27,     7,      1,    9,     8,         31    ; Vertex 7
 VERTEX    5,    0,  -27,     9,      9,    9,     9,         16    ; Vertex 8
 VERTEX    0,   -2,  -27,     9,      9,    9,     9,         16    ; Vertex 9
 VERTEX   -5,    0,  -27,     9,      9,    9,     9,          9    ; Vertex 10
 VERTEX    0,    3,  -27,     9,      9,    9,     9,          9    ; Vertex 11
 VERTEX    0,   -9,   35,    10,      0,   12,    11,         16    ; Vertex 12
 VERTEX    3,   -1,   31,    15,     15,    2,     0,          7    ; Vertex 13
 VERTEX    4,   11,   25,     1,      0,    4,    15,          8    ; Vertex 14
 VERTEX   11,    4,   25,     1,     10,   15,     3,          8    ; Vertex 15
 VERTEX   -3,   -1,   31,    11,      6,    3,     2,          7    ; Vertex 16
 VERTEX   -3,   11,   25,     8,     15,    0,    12,          8    ; Vertex 17
 VERTEX  -10,    4,   25,    15,      4,    8,     1,          8    ; Vertex 18

.SHIP_SHUTTLE_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     2,     0,         31    ; Edge 0
 EDGE       1,       2,    10,     4,         31    ; Edge 1
 EDGE       2,       3,    11,     6,         31    ; Edge 2
 EDGE       0,       3,    12,     8,         31    ; Edge 3
 EDGE       0,       7,     8,     1,         31    ; Edge 4
 EDGE       0,       4,     2,     1,         24    ; Edge 5
 EDGE       1,       4,     3,     2,         31    ; Edge 6
 EDGE       1,       5,     4,     3,         24    ; Edge 7
 EDGE       2,       5,     5,     4,         31    ; Edge 8
 EDGE       2,       6,     6,     5,         12    ; Edge 9
 EDGE       3,       6,     7,     6,         31    ; Edge 10
 EDGE       3,       7,     8,     7,         24    ; Edge 11
 EDGE       4,       5,     9,     3,         31    ; Edge 12
 EDGE       5,       6,     9,     5,         31    ; Edge 13
 EDGE       6,       7,     9,     7,         31    ; Edge 14
 EDGE       4,       7,     9,     1,         31    ; Edge 15
 EDGE       0,      12,    12,     0,         16    ; Edge 16
 EDGE       1,      12,    10,     0,         16    ; Edge 17
 EDGE       2,      12,    11,    10,         16    ; Edge 18
 EDGE       3,      12,    12,    11,         16    ; Edge 19
 EDGE       8,       9,     9,     9,         16    ; Edge 20
 EDGE       9,      10,     9,     9,          7    ; Edge 21
 EDGE      10,      11,     9,     9,          9    ; Edge 22
 EDGE       8,      11,     9,     9,          7    ; Edge 23
 EDGE      13,      14,    11,    11,          5    ; Edge 24
 EDGE      14,      15,    11,    11,          8    ; Edge 25
 EDGE      13,      15,    11,    11,          7    ; Edge 26
 EDGE      16,      17,    10,    10,          5    ; Edge 27
 EDGE      17,      18,    10,    10,          8    ; Edge 28
 EDGE      16,      18,    10,    10,          7    ; Edge 29

.SHIP_SHUTTLE_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE      -55,      -55,       40,         31    ; Face 0
 FACE        0,      -74,        4,         31    ; Face 1
 FACE      -51,      -51,       23,         31    ; Face 2
 FACE      -74,        0,        4,         31    ; Face 3
 FACE      -51,       51,       23,         31    ; Face 4
 FACE        0,       74,        4,         31    ; Face 5
 FACE       51,       51,       23,         31    ; Face 6
 FACE       74,        0,        4,         31    ; Face 7
 FACE       51,      -51,       23,         31    ; Face 8
 FACE        0,        0,     -107,         31    ; Face 9
 FACE      -41,       41,       90,         31    ; Face 10
 FACE       41,       41,       90,         31    ; Face 11
 FACE       55,      -55,       40,         31    ; Face 12

; ******************************************************************************
;
;       Name: SHIP_TRANSPORTER
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Transporter
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_TRANSPORTER

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 50 * 50           ; Targetable area          = 50 * 50

 EQUB LO(SHIP_TRANSPORTER_EDGES - SHIP_TRANSPORTER)   ; Edges data offset (low)
 EQUB LO(SHIP_TRANSPORTER_FACES - SHIP_TRANSPORTER)   ; Faces data offset (low)

 EQUB 149               ; Max. edge count          = (149 - 1) / 4 = 37
 EQUB 48                ; Gun vertex               = 48 / 4 = 12
 EQUB 26                ; Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 222               ; Number of vertices       = 222 / 6 = 37
 EQUB 46                ; Number of edges          = 46
 EQUW 0                 ; Bounty                   = 0
 EQUB 56                ; Number of faces          = 56 / 4 = 14
 EQUB 16                ; Visibility distance      = 16
 EQUB 32                ; Max. energy              = 32
 EQUB 10                ; Max. speed               = 10

 EQUB HI(SHIP_TRANSPORTER_EDGES - SHIP_TRANSPORTER)   ; Edges data offset (high)
 EQUB HI(SHIP_TRANSPORTER_FACES - SHIP_TRANSPORTER)   ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_TRANSPORTER_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,   10,  -26,     6,      0,    7,     7,         31    ; Vertex 0
 VERTEX  -25,    4,  -26,     1,      0,    7,     7,         31    ; Vertex 1
 VERTEX  -28,   -3,  -26,     1,      0,    2,     2,         31    ; Vertex 2
 VERTEX  -25,   -8,  -26,     2,      0,    3,     3,         31    ; Vertex 3
 VERTEX   26,   -8,  -26,     3,      0,    4,     4,         31    ; Vertex 4
 VERTEX   29,   -3,  -26,     4,      0,    5,     5,         31    ; Vertex 5
 VERTEX   26,    4,  -26,     5,      0,    6,     6,         31    ; Vertex 6
 VERTEX    0,    6,   12,    15,     15,   15,    15,         19    ; Vertex 7
 VERTEX  -30,   -1,   12,     7,      1,    9,     8,         31    ; Vertex 8
 VERTEX  -33,   -8,   12,     2,      1,    9,     3,         31    ; Vertex 9
 VERTEX   33,   -8,   12,     4,      3,   10,     5,         31    ; Vertex 10
 VERTEX   30,   -1,   12,     6,      5,   11,    10,         31    ; Vertex 11
 VERTEX  -11,   -2,   30,     9,      8,   13,    12,         31    ; Vertex 12
 VERTEX  -13,   -8,   30,     9,      3,   13,    13,         31    ; Vertex 13
 VERTEX   14,   -8,   30,    10,      3,   13,    13,         31    ; Vertex 14
 VERTEX   11,   -2,   30,    11,     10,   13,    12,         31    ; Vertex 15
 VERTEX   -5,    6,    2,     7,      7,    7,     7,          7    ; Vertex 16
 VERTEX  -18,    3,    2,     7,      7,    7,     7,          7    ; Vertex 17
 VERTEX   -5,    7,   -7,     7,      7,    7,     7,          7    ; Vertex 18
 VERTEX  -18,    4,   -7,     7,      7,    7,     7,          7    ; Vertex 19
 VERTEX  -11,    6,  -14,     7,      7,    7,     7,          7    ; Vertex 20
 VERTEX  -11,    5,   -7,     7,      7,    7,     7,          7    ; Vertex 21
 VERTEX    5,    7,  -14,     6,      6,    6,     6,          7    ; Vertex 22
 VERTEX   18,    4,  -14,     6,      6,    6,     6,          7    ; Vertex 23
 VERTEX   11,    5,   -7,     6,      6,    6,     6,          7    ; Vertex 24
 VERTEX    5,    6,   -3,     6,      6,    6,     6,          7    ; Vertex 25
 VERTEX   18,    3,   -3,     6,      6,    6,     6,          7    ; Vertex 26
 VERTEX   11,    4,    8,     6,      6,    6,     6,          7    ; Vertex 27
 VERTEX   11,    5,   -3,     6,      6,    6,     6,          7    ; Vertex 28
 VERTEX  -16,   -8,  -13,     3,      3,    3,     3,          6    ; Vertex 29
 VERTEX  -16,   -8,   16,     3,      3,    3,     3,          6    ; Vertex 30
 VERTEX   17,   -8,  -13,     3,      3,    3,     3,          6    ; Vertex 31
 VERTEX   17,   -8,   16,     3,      3,    3,     3,          6    ; Vertex 32
 VERTEX  -13,   -3,  -26,     0,      0,    0,     0,          8    ; Vertex 33
 VERTEX   13,   -3,  -26,     0,      0,    0,     0,          8    ; Vertex 34
 VERTEX    9,    3,  -26,     0,      0,    0,     0,          5    ; Vertex 35
 VERTEX   -8,    3,  -26,     0,      0,    0,     0,          5    ; Vertex 36

.SHIP_TRANSPORTER_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     7,     0,         31    ; Edge 0
 EDGE       1,       2,     1,     0,         31    ; Edge 1
 EDGE       2,       3,     2,     0,         31    ; Edge 2
 EDGE       3,       4,     3,     0,         31    ; Edge 3
 EDGE       4,       5,     4,     0,         31    ; Edge 4
 EDGE       5,       6,     5,     0,         31    ; Edge 5
 EDGE       0,       6,     6,     0,         31    ; Edge 6
 EDGE       0,       7,     7,     6,         16    ; Edge 7
 EDGE       1,       8,     7,     1,         31    ; Edge 8
 EDGE       2,       9,     2,     1,         11    ; Edge 9
 EDGE       3,       9,     3,     2,         31    ; Edge 10
 EDGE       4,      10,     4,     3,         31    ; Edge 11
 EDGE       5,      10,     5,     4,         11    ; Edge 12
 EDGE       6,      11,     6,     5,         31    ; Edge 13
 EDGE       7,       8,     8,     7,         17    ; Edge 14
 EDGE       8,       9,     9,     1,         17    ; Edge 15
 EDGE      10,      11,    10,     5,         17    ; Edge 16
 EDGE       7,      11,    11,     6,         17    ; Edge 17
 EDGE       7,      15,    12,    11,         19    ; Edge 18
 EDGE       7,      12,    12,     8,         19    ; Edge 19
 EDGE       8,      12,     9,     8,         16    ; Edge 20
 EDGE       9,      13,     9,     3,         31    ; Edge 21
 EDGE      10,      14,    10,     3,         31    ; Edge 22
 EDGE      11,      15,    11,    10,         16    ; Edge 23
 EDGE      12,      13,    13,     9,         31    ; Edge 24
 EDGE      13,      14,    13,     3,         31    ; Edge 25
 EDGE      14,      15,    13,    10,         31    ; Edge 26
 EDGE      12,      15,    13,    12,         31    ; Edge 27
 EDGE      16,      17,     7,     7,          7    ; Edge 28
 EDGE      18,      19,     7,     7,          7    ; Edge 29
 EDGE      19,      20,     7,     7,          7    ; Edge 30
 EDGE      18,      20,     7,     7,          7    ; Edge 31
 EDGE      20,      21,     7,     7,          7    ; Edge 32
 EDGE      22,      23,     6,     6,          7    ; Edge 33
 EDGE      23,      24,     6,     6,          7    ; Edge 34
 EDGE      24,      22,     6,     6,          7    ; Edge 35
 EDGE      25,      26,     6,     6,          7    ; Edge 36
 EDGE      26,      27,     6,     6,          7    ; Edge 37
 EDGE      25,      27,     6,     6,          7    ; Edge 38
 EDGE      27,      28,     6,     6,          7    ; Edge 39
 EDGE      29,      30,     3,     3,          6    ; Edge 40
 EDGE      31,      32,     3,     3,          6    ; Edge 41
 EDGE      33,      34,     0,     0,          8    ; Edge 42
 EDGE      34,      35,     0,     0,          5    ; Edge 43
 EDGE      35,      36,     0,     0,          5    ; Edge 44
 EDGE      36,      33,     0,     0,          5    ; Edge 45

.SHIP_TRANSPORTER_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,        0,     -103,         31    ; Face 0
 FACE     -111,       48,       -7,         31    ; Face 1
 FACE     -105,      -63,      -21,         31    ; Face 2
 FACE        0,      -34,        0,         31    ; Face 3
 FACE      105,      -63,      -21,         31    ; Face 4
 FACE      111,       48,       -7,         31    ; Face 5
 FACE        8,       32,        3,         31    ; Face 6
 FACE       -8,       32,        3,         31    ; Face 7
 FACE       -8,       34,       11,         19    ; Face 8
 FACE      -75,       32,       79,         31    ; Face 9
 FACE       75,       32,       79,         31    ; Face 10
 FACE        8,       34,       11,         19    ; Face 11
 FACE        0,       38,       17,         31    ; Face 12
 FACE        0,        0,      121,         31    ; Face 13

; ******************************************************************************
;
;       Name: SHIP_COBRA_MK_3
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Cobra Mk III
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_COBRA_MK_3

 EQUB 3                 ; Max. canisters on demise = 3
 EQUW 95 * 95           ; Targetable area          = 95 * 95

 EQUB LO(SHIP_COBRA_MK_3_EDGES - SHIP_COBRA_MK_3)  ; Edges data offset (low)
 EQUB LO(SHIP_COBRA_MK_3_FACES - SHIP_COBRA_MK_3)  ; Faces data offset (low)

 EQUB 157               ; Max. edge count          = (157 - 1) / 4 = 39
 EQUB 84                ; Gun vertex               = 84 / 4 = 21
 EQUB 42                ; Explosion count          = 9, as (4 * n) + 6 = 42
 EQUB 168               ; Number of vertices       = 168 / 6 = 28
 EQUB 38                ; Number of edges          = 38
 EQUW 0                 ; Bounty                   = 0
 EQUB 52                ; Number of faces          = 52 / 4 = 13
 EQUB 50                ; Visibility distance      = 50
 EQUB 150               ; Max. energy              = 150
 EQUB 28                ; Max. speed               = 28

 EQUB HI(SHIP_COBRA_MK_3_EDGES - SHIP_COBRA_MK_3)  ; Edges data offset (low)
 EQUB HI(SHIP_COBRA_MK_3_FACES - SHIP_COBRA_MK_3)  ; Faces data offset (low)

 EQUB 1                 ; Normals are scaled by    = 2^1 = 2
 EQUB %00010011         ; Laser power              = 2
                        ; Missiles                 = 3

.SHIP_COBRA_MK_3_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   32,    0,   76,    15,     15,   15,    15,         31    ; Vertex 0
 VERTEX  -32,    0,   76,    15,     15,   15,    15,         31    ; Vertex 1
 VERTEX    0,   26,   24,    15,     15,   15,    15,         31    ; Vertex 2
 VERTEX -120,   -3,   -8,     3,      7,   10,    10,         31    ; Vertex 3
 VERTEX  120,   -3,   -8,     4,      8,   12,    12,         31    ; Vertex 4
 VERTEX  -88,   16,  -40,    15,     15,   15,    15,         31    ; Vertex 5
 VERTEX   88,   16,  -40,    15,     15,   15,    15,         31    ; Vertex 6
 VERTEX  128,   -8,  -40,     8,      9,   12,    12,         31    ; Vertex 7
 VERTEX -128,   -8,  -40,     7,      9,   10,    10,         31    ; Vertex 8
 VERTEX    0,   26,  -40,     5,      6,    9,     9,         31    ; Vertex 9
 VERTEX  -32,  -24,  -40,     9,     10,   11,    11,         31    ; Vertex 10
 VERTEX   32,  -24,  -40,     9,     11,   12,    12,         31    ; Vertex 11
 VERTEX  -36,    8,  -40,     9,      9,    9,     9,         20    ; Vertex 12
 VERTEX   -8,   12,  -40,     9,      9,    9,     9,         20    ; Vertex 13
 VERTEX    8,   12,  -40,     9,      9,    9,     9,         20    ; Vertex 14
 VERTEX   36,    8,  -40,     9,      9,    9,     9,         20    ; Vertex 15
 VERTEX   36,  -12,  -40,     9,      9,    9,     9,         20    ; Vertex 16
 VERTEX    8,  -16,  -40,     9,      9,    9,     9,         20    ; Vertex 17
 VERTEX   -8,  -16,  -40,     9,      9,    9,     9,         20    ; Vertex 18
 VERTEX  -36,  -12,  -40,     9,      9,    9,     9,         20    ; Vertex 19
 VERTEX    0,    0,   76,     0,     11,   11,    11,          6    ; Vertex 20
 VERTEX    0,    0,   90,     0,     11,   11,    11,         31    ; Vertex 21
 VERTEX  -80,   -6,  -40,     9,      9,    9,     9,          8    ; Vertex 22
 VERTEX  -80,    6,  -40,     9,      9,    9,     9,          8    ; Vertex 23
 VERTEX  -88,    0,  -40,     9,      9,    9,     9,          6    ; Vertex 24
 VERTEX   80,    6,  -40,     9,      9,    9,     9,          8    ; Vertex 25
 VERTEX   88,    0,  -40,     9,      9,    9,     9,          6    ; Vertex 26
 VERTEX   80,   -6,  -40,     9,      9,    9,     9,          8    ; Vertex 27

.SHIP_COBRA_MK_3_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     0,    11,         31    ; Edge 0
 EDGE       0,       4,     4,    12,         31    ; Edge 1
 EDGE       1,       3,     3,    10,         31    ; Edge 2
 EDGE       3,       8,     7,    10,         31    ; Edge 3
 EDGE       4,       7,     8,    12,         31    ; Edge 4
 EDGE       6,       7,     8,     9,         31    ; Edge 5
 EDGE       6,       9,     6,     9,         31    ; Edge 6
 EDGE       5,       9,     5,     9,         31    ; Edge 7
 EDGE       5,       8,     7,     9,         31    ; Edge 8
 EDGE       2,       5,     1,     5,         31    ; Edge 9
 EDGE       2,       6,     2,     6,         31    ; Edge 10
 EDGE       3,       5,     3,     7,         31    ; Edge 11
 EDGE       4,       6,     4,     8,         31    ; Edge 12
 EDGE       1,       2,     0,     1,         31    ; Edge 13
 EDGE       0,       2,     0,     2,         31    ; Edge 14
 EDGE       8,      10,     9,    10,         31    ; Edge 15
 EDGE      10,      11,     9,    11,         31    ; Edge 16
 EDGE       7,      11,     9,    12,         31    ; Edge 17
 EDGE       1,      10,    10,    11,         31    ; Edge 18
 EDGE       0,      11,    11,    12,         31    ; Edge 19
 EDGE       1,       5,     1,     3,         29    ; Edge 20
 EDGE       0,       6,     2,     4,         29    ; Edge 21
 EDGE      20,      21,     0,    11,          6    ; Edge 22
 EDGE      12,      13,     9,     9,         20    ; Edge 23
 EDGE      18,      19,     9,     9,         20    ; Edge 24
 EDGE      14,      15,     9,     9,         20    ; Edge 25
 EDGE      16,      17,     9,     9,         20    ; Edge 26
 EDGE      15,      16,     9,     9,         19    ; Edge 27
 EDGE      14,      17,     9,     9,         17    ; Edge 28
 EDGE      13,      18,     9,     9,         19    ; Edge 29
 EDGE      12,      19,     9,     9,         19    ; Edge 30
 EDGE       2,       9,     5,     6,         30    ; Edge 31
 EDGE      22,      24,     9,     9,          6    ; Edge 32
 EDGE      23,      24,     9,     9,          6    ; Edge 33
 EDGE      22,      23,     9,     9,          8    ; Edge 34
 EDGE      25,      26,     9,     9,          6    ; Edge 35
 EDGE      26,      27,     9,     9,          6    ; Edge 36
 EDGE      25,      27,     9,     9,          8    ; Edge 37

.SHIP_COBRA_MK_3_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       62,       31,         31    ; Face 0
 FACE      -18,       55,       16,         31    ; Face 1
 FACE       18,       55,       16,         31    ; Face 2
 FACE      -16,       52,       14,         31    ; Face 3
 FACE       16,       52,       14,         31    ; Face 4
 FACE      -14,       47,        0,         31    ; Face 5
 FACE       14,       47,        0,         31    ; Face 6
 FACE      -61,      102,        0,         31    ; Face 7
 FACE       61,      102,        0,         31    ; Face 8
 FACE        0,        0,      -80,         31    ; Face 9
 FACE       -7,      -42,        9,         31    ; Face 10
 FACE        0,      -30,        6,         31    ; Face 11
 FACE        7,      -42,        9,         31    ; Face 12

; ******************************************************************************
;
;       Name: SHIP_PYTHON
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Python
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_PYTHON

 EQUB 5                 ; Max. canisters on demise = 5
 EQUW 80 * 80           ; Targetable area          = 80 * 80

 EQUB LO(SHIP_PYTHON_EDGES - SHIP_PYTHON)          ; Edges data offset (low)
 EQUB LO(SHIP_PYTHON_FACES - SHIP_PYTHON)          ; Faces data offset (low)

 EQUB 89                ; Max. edge count          = (89 - 1) / 4 = 22
 EQUB 0                 ; Gun vertex               = 0
 EQUB 42                ; Explosion count          = 9, as (4 * n) + 6 = 42
 EQUB 66                ; Number of vertices       = 66 / 6 = 11
 EQUB 26                ; Number of edges          = 26
 EQUW 0                 ; Bounty                   = 0
 EQUB 52                ; Number of faces          = 52 / 4 = 13
 EQUB 40                ; Visibility distance      = 40
 EQUB 250               ; Max. energy              = 250
 EQUB 20                ; Max. speed               = 20

 EQUB HI(SHIP_PYTHON_EDGES - SHIP_PYTHON)          ; Edges data offset (high)
 EQUB HI(SHIP_PYTHON_FACES - SHIP_PYTHON)          ; Faces data offset (high)

 EQUB 0                 ; Normals are scaled by    = 2^0 = 1
 EQUB %00011011         ; Laser power              = 3
                        ; Missiles                 = 3

.SHIP_PYTHON_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,  224,     0,      1,    2,     3,         31    ; Vertex 0
 VERTEX    0,   48,   48,     0,      1,    4,     5,         31    ; Vertex 1
 VERTEX   96,    0,  -16,    15,     15,   15,    15,         31    ; Vertex 2
 VERTEX  -96,    0,  -16,    15,     15,   15,    15,         31    ; Vertex 3
 VERTEX    0,   48,  -32,     4,      5,    8,     9,         31    ; Vertex 4
 VERTEX    0,   24, -112,     9,      8,   12,    12,         31    ; Vertex 5
 VERTEX  -48,    0, -112,     8,     11,   12,    12,         31    ; Vertex 6
 VERTEX   48,    0, -112,     9,     10,   12,    12,         31    ; Vertex 7
 VERTEX    0,  -48,   48,     2,      3,    6,     7,         31    ; Vertex 8
 VERTEX    0,  -48,  -32,     6,      7,   10,    11,         31    ; Vertex 9
 VERTEX    0,  -24, -112,    10,     11,   12,    12,         31    ; Vertex 10

.SHIP_PYTHON_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       8,     2,     3,         31    ; Edge 0
 EDGE       0,       3,     0,     2,         31    ; Edge 1
 EDGE       0,       2,     1,     3,         31    ; Edge 2
 EDGE       0,       1,     0,     1,         31    ; Edge 3
 EDGE       2,       4,     9,     5,         31    ; Edge 4
 EDGE       1,       2,     1,     5,         31    ; Edge 5
 EDGE       2,       8,     7,     3,         31    ; Edge 6
 EDGE       1,       3,     0,     4,         31    ; Edge 7
 EDGE       3,       8,     2,     6,         31    ; Edge 8
 EDGE       2,       9,     7,    10,         31    ; Edge 9
 EDGE       3,       4,     4,     8,         31    ; Edge 10
 EDGE       3,       9,     6,    11,         31    ; Edge 11
 EDGE       3,       5,     8,     8,          7    ; Edge 12
 EDGE       3,      10,    11,    11,          7    ; Edge 13
 EDGE       2,       5,     9,     9,          7    ; Edge 14
 EDGE       2,      10,    10,    10,          7    ; Edge 15
 EDGE       2,       7,     9,    10,         31    ; Edge 16
 EDGE       3,       6,     8,    11,         31    ; Edge 17
 EDGE       5,       6,     8,    12,         31    ; Edge 18
 EDGE       5,       7,     9,    12,         31    ; Edge 19
 EDGE       7,      10,    12,    10,         31    ; Edge 20
 EDGE       6,      10,    11,    12,         31    ; Edge 21
 EDGE       4,       5,     8,     9,         31    ; Edge 22
 EDGE       9,      10,    10,    11,         31    ; Edge 23
 EDGE       1,       4,     4,     5,         31    ; Edge 24
 EDGE       8,       9,     6,     7,         31    ; Edge 25

.SHIP_PYTHON_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE      -27,       40,       11,        31    ; Face 0
 FACE       27,       40,       11,        31    ; Face 1
 FACE      -27,      -40,       11,        31    ; Face 2
 FACE       27,      -40,       11,        31    ; Face 3
 FACE      -19,       38,        0,        31    ; Face 4
 FACE       19,       38,        0,        31    ; Face 5
 FACE      -19,      -38,        0,        31    ; Face 6
 FACE       19,      -38,        0,        31    ; Face 7
 FACE      -25,       37,      -11,        31    ; Face 8
 FACE       25,       37,      -11,        31    ; Face 9
 FACE       25,      -37,      -11,        31    ; Face 10
 FACE      -25,      -37,      -11,        31    ; Face 11
 FACE        0,        0,     -112,        31    ; Face 12

; ******************************************************************************
;
;       Name: SHIP_BOA
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Boa
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_BOA

 EQUB 5                 ; Max. canisters on demise = 5
 EQUW 70 * 70           ; Targetable area          = 70 * 70

 EQUB LO(SHIP_BOA_EDGES - SHIP_BOA)                ; Edges data offset (low)
 EQUB LO(SHIP_BOA_FACES - SHIP_BOA)                ; Faces data offset (low)

 EQUB 93                ; Max. edge count          = (93 - 1) / 4 = 23
 EQUB 0                 ; Gun vertex               = 0
 EQUB 38                ; Explosion count          = 8, as (4 * n) + 6 = 38
 EQUB 78                ; Number of vertices       = 78 / 6 = 13
 EQUB 24                ; Number of edges          = 24
 EQUW 0                 ; Bounty                   = 0
 EQUB 52                ; Number of faces          = 52 / 4 = 13
 EQUB 40                ; Visibility distance      = 40
 EQUB 250               ; Max. energy              = 250
 EQUB 24                ; Max. speed               = 24

 EQUB HI(SHIP_BOA_EDGES - SHIP_BOA)                ; Edges data offset (high)
 EQUB HI(SHIP_BOA_FACES - SHIP_BOA)                ; Faces data offset (high)

 EQUB 0                 ; Normals are scaled by    = 2^0 = 1
 EQUB %00011100         ; Laser power              = 3
                        ; Missiles                 = 4

.SHIP_BOA_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,   93,    15,     15,   15,    15,         31    ; Vertex 0
 VERTEX    0,   40,  -87,     2,      0,    3,     3,         24    ; Vertex 1
 VERTEX   38,  -25,  -99,     1,      0,    4,     4,         24    ; Vertex 2
 VERTEX  -38,  -25,  -99,     2,      1,    5,     5,         24    ; Vertex 3
 VERTEX  -38,   40,  -59,     3,      2,    9,     6,         31    ; Vertex 4
 VERTEX   38,   40,  -59,     3,      0,   11,     6,         31    ; Vertex 5
 VERTEX   62,    0,  -67,     4,      0,   11,     8,         31    ; Vertex 6
 VERTEX   24,  -65,  -79,     4,      1,   10,     8,         31    ; Vertex 7
 VERTEX  -24,  -65,  -79,     5,      1,   10,     7,         31    ; Vertex 8
 VERTEX  -62,    0,  -67,     5,      2,    9,     7,         31    ; Vertex 9
 VERTEX    0,    7, -107,     2,      0,   10,    10,         22    ; Vertex 10
 VERTEX   13,   -9, -107,     1,      0,   10,    10,         22    ; Vertex 11
 VERTEX  -13,   -9, -107,     2,      1,   12,    12,         22    ; Vertex 12

.SHIP_BOA_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       5,    11,     6,         31    ; Edge 0
 EDGE       0,       7,    10,     8,         31    ; Edge 1
 EDGE       0,       9,     9,     7,         31    ; Edge 2
 EDGE       0,       4,     9,     6,         29    ; Edge 3
 EDGE       0,       6,    11,     8,         29    ; Edge 4
 EDGE       0,       8,    10,     7,         29    ; Edge 5
 EDGE       4,       5,     6,     3,         31    ; Edge 6
 EDGE       5,       6,    11,     0,         31    ; Edge 7
 EDGE       6,       7,     8,     4,         31    ; Edge 8
 EDGE       7,       8,    10,     1,         31    ; Edge 9
 EDGE       8,       9,     7,     5,         31    ; Edge 10
 EDGE       4,       9,     9,     2,         31    ; Edge 11
 EDGE       1,       4,     3,     2,         24    ; Edge 12
 EDGE       1,       5,     3,     0,         24    ; Edge 13
 EDGE       3,       9,     5,     2,         24    ; Edge 14
 EDGE       3,       8,     5,     1,         24    ; Edge 15
 EDGE       2,       6,     4,     0,         24    ; Edge 16
 EDGE       2,       7,     4,     1,         24    ; Edge 17
 EDGE       1,      10,     2,     0,         22    ; Edge 18
 EDGE       2,      11,     1,     0,         22    ; Edge 19
 EDGE       3,      12,     2,     1,         22    ; Edge 20
 EDGE      10,      11,    12,     0,         14    ; Edge 21
 EDGE      11,      12,    12,     1,         14    ; Edge 22
 EDGE      12,      10,    12,     2,         14    ; Edge 23

.SHIP_BOA_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE       43,       37,      -60,         31    ; Face 0
 FACE        0,      -45,      -89,         31    ; Face 1
 FACE      -43,       37,      -60,         31    ; Face 2
 FACE        0,       40,        0,         31    ; Face 3
 FACE       62,      -32,      -20,         31    ; Face 4
 FACE      -62,      -32,      -20,         31    ; Face 5
 FACE        0,       23,        6,         31    ; Face 6
 FACE      -23,      -15,        9,         31    ; Face 7
 FACE       23,      -15,        9,         31    ; Face 8
 FACE      -26,       13,       10,         31    ; Face 9
 FACE        0,      -31,       12,         31    ; Face 10
 FACE       26,       13,       10,         31    ; Face 11
 FACE        0,        0,     -107,         14    ; Face 12

; ******************************************************************************
;
;       Name: SHIP_ANACONDA
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for an Anaconda
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_ANACONDA

 EQUB 7                 ; Max. canisters on demise = 7
 EQUW 100 * 100         ; Targetable area          = 100 * 100

 EQUB LO(SHIP_ANACONDA_EDGES - SHIP_ANACONDA)      ; Edges data offset (low)
 EQUB LO(SHIP_ANACONDA_FACES - SHIP_ANACONDA)      ; Faces data offset (low)

 EQUB 93                ; Max. edge count          = (93 - 1) / 4 = 23
 EQUB 48                ; Gun vertex               = 48 / 4 = 12
 EQUB 46                ; Explosion count          = 10, as (4 * n) + 6 = 46
 EQUB 90                ; Number of vertices       = 90 / 6 = 15
 EQUB 25                ; Number of edges          = 25
 EQUW 0                 ; Bounty                   = 0
 EQUB 48                ; Number of faces          = 48 / 4 = 12
 EQUB 36                ; Visibility distance      = 36
 EQUB 252               ; Max. energy              = 252
 EQUB 14                ; Max. speed               = 14

 EQUB HI(SHIP_ANACONDA_EDGES - SHIP_ANACONDA)      ; Edges data offset (high)
 EQUB HI(SHIP_ANACONDA_FACES - SHIP_ANACONDA)      ; Faces data offset (high)

 EQUB 1                 ; Normals are scaled by    = 2^1 = 2
 EQUB %00111111         ; Laser power              = 7
                        ; Missiles                 = 7

.SHIP_ANACONDA_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    7,  -58,     1,      0,    5,     5,         30    ; Vertex 0
 VERTEX  -43,  -13,  -37,     1,      0,    2,     2,         30    ; Vertex 1
 VERTEX  -26,  -47,   -3,     2,      0,    3,     3,         30    ; Vertex 2
 VERTEX   26,  -47,   -3,     3,      0,    4,     4,         30    ; Vertex 3
 VERTEX   43,  -13,  -37,     4,      0,    5,     5,         30    ; Vertex 4
 VERTEX    0,   48,  -49,     5,      1,    6,     6,         30    ; Vertex 5
 VERTEX  -69,   15,  -15,     2,      1,    7,     7,         30    ; Vertex 6
 VERTEX  -43,  -39,   40,     3,      2,    8,     8,         31    ; Vertex 7
 VERTEX   43,  -39,   40,     4,      3,    9,     9,         31    ; Vertex 8
 VERTEX   69,   15,  -15,     5,      4,   10,    10,         30    ; Vertex 9
 VERTEX  -43,   53,  -23,    15,     15,   15,    15,         31    ; Vertex 10
 VERTEX  -69,   -1,   32,     7,      2,    8,     8,         31    ; Vertex 11
 VERTEX    0,    0,  254,    15,     15,   15,    15,         31    ; Vertex 12
 VERTEX   69,   -1,   32,     9,      4,   10,    10,         31    ; Vertex 13
 VERTEX   43,   53,  -23,    15,     15,   15,    15,         31    ; Vertex 14

.SHIP_ANACONDA_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     1,     0,         30    ; Edge 0
 EDGE       1,       2,     2,     0,         30    ; Edge 1
 EDGE       2,       3,     3,     0,         30    ; Edge 2
 EDGE       3,       4,     4,     0,         30    ; Edge 3
 EDGE       0,       4,     5,     0,         30    ; Edge 4
 EDGE       0,       5,     5,     1,         29    ; Edge 5
 EDGE       1,       6,     2,     1,         29    ; Edge 6
 EDGE       2,       7,     3,     2,         29    ; Edge 7
 EDGE       3,       8,     4,     3,         29    ; Edge 8
 EDGE       4,       9,     5,     4,         29    ; Edge 9
 EDGE       5,      10,     6,     1,         30    ; Edge 10
 EDGE       6,      10,     7,     1,         30    ; Edge 11
 EDGE       6,      11,     7,     2,         30    ; Edge 12
 EDGE       7,      11,     8,     2,         30    ; Edge 13
 EDGE       7,      12,     8,     3,         31    ; Edge 14
 EDGE       8,      12,     9,     3,         31    ; Edge 15
 EDGE       8,      13,     9,     4,         30    ; Edge 16
 EDGE       9,      13,    10,     4,         30    ; Edge 17
 EDGE       9,      14,    10,     5,         30    ; Edge 18
 EDGE       5,      14,     6,     5,         30    ; Edge 19
 EDGE      10,      14,    11,     6,         30    ; Edge 20
 EDGE      10,      12,    11,     7,         31    ; Edge 21
 EDGE      11,      12,     8,     7,         31    ; Edge 22
 EDGE      12,      13,    10,     9,         31    ; Edge 23
 EDGE      12,      14,    11,    10,         31    ; Edge 24

.SHIP_ANACONDA_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,      -51,      -49,         30    ; Face 0
 FACE      -51,       18,      -87,         30    ; Face 1
 FACE      -77,      -57,      -19,         30    ; Face 2
 FACE        0,      -90,       16,         31    ; Face 3
 FACE       77,      -57,      -19,         30    ; Face 4
 FACE       51,       18,      -87,         30    ; Face 5
 FACE        0,      111,      -20,         30    ; Face 6
 FACE      -97,       72,       24,         31    ; Face 7
 FACE     -108,      -68,       34,         31    ; Face 8
 FACE      108,      -68,       34,         31    ; Face 9
 FACE       97,       72,       24,         31    ; Face 10
 FACE        0,       94,       18,         31    ; Face 11

; ******************************************************************************
;
;       Name: SHIP_ROCK_HERMIT
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a rock hermit (asteroid)
;  Deep dive: Ship blueprints
;
; ------------------------------------------------------------------------------
;
; The ship blueprint for the rock hermit reuses the edges and faces data from
; the asteroid, so the edges and faces data offsets are negative.
;
; ******************************************************************************

.SHIP_ROCK_HERMIT

 EQUB 7                 ; Max. canisters on demise = 7
 EQUW 80 * 80           ; Targetable area          = 80 * 80

 EQUB LO(SHIP_ASTEROID_EDGES - SHIP_ROCK_HERMIT)   ; Edges from asteroid
 EQUB LO(SHIP_ASTEROID_FACES - SHIP_ROCK_HERMIT)   ; Faces from asteroid

 EQUB 69                ; Max. edge count          = (69 - 1) / 4 = 17
 EQUB 0                 ; Gun vertex               = 0
 EQUB 50                ; Explosion count          = 11, as (4 * n) + 6 = 50
 EQUB 54                ; Number of vertices       = 54 / 6 = 9
 EQUB 21                ; Number of edges          = 21
 EQUW 0                 ; Bounty                   = 0
 EQUB 56                ; Number of faces          = 56 / 4 = 14
 EQUB 50                ; Visibility distance      = 50
 EQUB 180               ; Max. energy              = 180
 EQUB 30                ; Max. speed               = 30

 EQUB HI(SHIP_ASTEROID_EDGES - SHIP_ROCK_HERMIT)   ; Edges from asteroid
 EQUB HI(SHIP_ASTEROID_FACES - SHIP_ROCK_HERMIT)   ; Faces from asteroid

 EQUB 1                 ; Normals are scaled by    = 2^1 = 2
 EQUB %00000010         ; Laser power              = 0
                        ; Missiles                 = 2

.SHIP_ROCK_HERMIT_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,   80,    0,    15,     15,   15,    15,         31    ; Vertex 0
 VERTEX  -80,  -10,    0,    15,     15,   15,    15,         31    ; Vertex 1
 VERTEX    0,  -80,    0,    15,     15,   15,    15,         31    ; Vertex 2
 VERTEX   70,  -40,    0,    15,     15,   15,    15,         31    ; Vertex 3
 VERTEX   60,   50,    0,     5,      6,   12,    13,         31    ; Vertex 4
 VERTEX   50,    0,   60,    15,     15,   15,    15,         31    ; Vertex 5
 VERTEX  -40,    0,   70,     0,      1,    2,     3,         31    ; Vertex 6
 VERTEX    0,   30,  -75,    15,     15,   15,    15,         31    ; Vertex 7
 VERTEX    0,  -50,  -60,     8,      9,   10,    11,         31    ; Vertex 8

; ******************************************************************************
;
;       Name: SHIP_VIPER
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Viper
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_VIPER

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 75 * 75           ; Targetable area          = 75 * 75

 EQUB LO(SHIP_VIPER_EDGES - SHIP_VIPER)            ; Edges data offset (low)
 EQUB LO(SHIP_VIPER_FACES - SHIP_VIPER)            ; Faces data offset (low)

 EQUB 81                ; Max. edge count          = (81 - 1) / 4 = 20
 EQUB 0                 ; Gun vertex               = 0
 EQUB 42                ; Explosion count          = 9, as (4 * n) + 6 = 42
 EQUB 90                ; Number of vertices       = 90 / 6 = 15
 EQUB 20                ; Number of edges          = 20
 EQUW 0                 ; Bounty                   = 0
 EQUB 28                ; Number of faces          = 28 / 4 = 7
 EQUB 23                ; Visibility distance      = 23
 EQUB 140               ; Max. energy              = 140
 EQUB 32                ; Max. speed               = 32

 EQUB HI(SHIP_VIPER_EDGES - SHIP_VIPER)            ; Edges data offset (high)
 EQUB HI(SHIP_VIPER_FACES - SHIP_VIPER)            ; Faces data offset (high)

 EQUB 1                 ; Normals are scaled by    = 2^1 = 2
 EQUB %00010001         ; Laser power              = 2
                        ; Missiles                 = 1

.SHIP_VIPER_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,   72,     1,      2,    3,     4,         31    ; Vertex 0
 VERTEX    0,   16,   24,     0,      1,    2,     2,         30    ; Vertex 1
 VERTEX    0,  -16,   24,     3,      4,    5,     5,         30    ; Vertex 2
 VERTEX   48,    0,  -24,     2,      4,    6,     6,         31    ; Vertex 3
 VERTEX  -48,    0,  -24,     1,      3,    6,     6,         31    ; Vertex 4
 VERTEX   24,  -16,  -24,     4,      5,    6,     6,         30    ; Vertex 5
 VERTEX  -24,  -16,  -24,     5,      3,    6,     6,         30    ; Vertex 6
 VERTEX   24,   16,  -24,     0,      2,    6,     6,         31    ; Vertex 7
 VERTEX  -24,   16,  -24,     0,      1,    6,     6,         31    ; Vertex 8
 VERTEX  -32,    0,  -24,     6,      6,    6,     6,         19    ; Vertex 9
 VERTEX   32,    0,  -24,     6,      6,    6,     6,         19    ; Vertex 10
 VERTEX    8,    8,  -24,     6,      6,    6,     6,         19    ; Vertex 11
 VERTEX   -8,    8,  -24,     6,      6,    6,     6,         19    ; Vertex 12
 VERTEX   -8,   -8,  -24,     6,      6,    6,     6,         18    ; Vertex 13
 VERTEX    8,   -8,  -24,     6,      6,    6,     6,         18    ; Vertex 14

.SHIP_VIPER_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       3,     2,     4,         31    ; Edge 0
 EDGE       0,       1,     1,     2,         30    ; Edge 1
 EDGE       0,       2,     3,     4,         30    ; Edge 2
 EDGE       0,       4,     1,     3,         31    ; Edge 3
 EDGE       1,       7,     0,     2,         30    ; Edge 4
 EDGE       1,       8,     0,     1,         30    ; Edge 5
 EDGE       2,       5,     4,     5,         30    ; Edge 6
 EDGE       2,       6,     3,     5,         30    ; Edge 7
 EDGE       7,       8,     0,     6,         31    ; Edge 8
 EDGE       5,       6,     5,     6,         30    ; Edge 9
 EDGE       4,       8,     1,     6,         31    ; Edge 10
 EDGE       4,       6,     3,     6,         30    ; Edge 11
 EDGE       3,       7,     2,     6,         31    ; Edge 12
 EDGE       3,       5,     6,     4,         30    ; Edge 13
 EDGE       9,      12,     6,     6,         19    ; Edge 14
 EDGE       9,      13,     6,     6,         18    ; Edge 15
 EDGE      10,      11,     6,     6,         19    ; Edge 16
 EDGE      10,      14,     6,     6,         18    ; Edge 17
 EDGE      11,      14,     6,     6,         16    ; Edge 18
 EDGE      12,      13,     6,     6,         16    ; Edge 19

.SHIP_VIPER_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       32,        0,         31    ; Face 0
 FACE      -22,       33,       11,         31    ; Face 1
 FACE       22,       33,       11,         31    ; Face 2
 FACE      -22,      -33,       11,         31    ; Face 3
 FACE       22,      -33,       11,         31    ; Face 4
 FACE        0,      -32,        0,         31    ; Face 5
 FACE        0,        0,      -48,         31    ; Face 6

; ******************************************************************************
;
;       Name: SHIP_SIDEWINDER
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Sidewinder
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_SIDEWINDER

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 65 * 65           ; Targetable area          = 65 * 65

 EQUB LO(SHIP_SIDEWINDER_EDGES - SHIP_SIDEWINDER)  ; Edges data offset (low)
 EQUB LO(SHIP_SIDEWINDER_FACES - SHIP_SIDEWINDER)  ; Faces data offset (low)

 EQUB 65                ; Max. edge count          = (65 - 1) / 4 = 16
 EQUB 0                 ; Gun vertex               = 0
 EQUB 30                ; Explosion count          = 6, as (4 * n) + 6 = 30
 EQUB 60                ; Number of vertices       = 60 / 6 = 10
 EQUB 15                ; Number of edges          = 15
 EQUW 50                ; Bounty                   = 50
 EQUB 28                ; Number of faces          = 28 / 4 = 7
 EQUB 20                ; Visibility distance      = 20
 EQUB 70                ; Max. energy              = 70
 EQUB 37                ; Max. speed               = 37

 EQUB HI(SHIP_SIDEWINDER_EDGES - SHIP_SIDEWINDER)  ; Edges data offset (high)
 EQUB HI(SHIP_SIDEWINDER_FACES - SHIP_SIDEWINDER)  ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00010000         ; Laser power              = 2
                        ; Missiles                 = 0

.SHIP_SIDEWINDER_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -32,    0,   36,     0,      1,    4,     5,         31    ; Vertex 0
 VERTEX   32,    0,   36,     0,      2,    5,     6,         31    ; Vertex 1
 VERTEX   64,    0,  -28,     2,      3,    6,     6,         31    ; Vertex 2
 VERTEX  -64,    0,  -28,     1,      3,    4,     4,         31    ; Vertex 3
 VERTEX    0,   16,  -28,     0,      1,    2,     3,         31    ; Vertex 4
 VERTEX    0,  -16,  -28,     3,      4,    5,     6,         31    ; Vertex 5
 VERTEX  -12,    6,  -28,     3,      3,    3,     3,         15    ; Vertex 6
 VERTEX   12,    6,  -28,     3,      3,    3,     3,         15    ; Vertex 7
 VERTEX   12,   -6,  -28,     3,      3,    3,     3,         12    ; Vertex 8
 VERTEX  -12,   -6,  -28,     3,      3,    3,     3,         12    ; Vertex 9

.SHIP_SIDEWINDER_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     0,     5,         31    ; Edge 0
 EDGE       1,       2,     2,     6,         31    ; Edge 1
 EDGE       1,       4,     0,     2,         31    ; Edge 2
 EDGE       0,       4,     0,     1,         31    ; Edge 3
 EDGE       0,       3,     1,     4,         31    ; Edge 4
 EDGE       3,       4,     1,     3,         31    ; Edge 5
 EDGE       2,       4,     2,     3,         31    ; Edge 6
 EDGE       3,       5,     3,     4,         31    ; Edge 7
 EDGE       2,       5,     3,     6,         31    ; Edge 8
 EDGE       1,       5,     5,     6,         31    ; Edge 9
 EDGE       0,       5,     4,     5,         31    ; Edge 10
 EDGE       6,       7,     3,     3,         15    ; Edge 11
 EDGE       7,       8,     3,     3,         12    ; Edge 12
 EDGE       6,       9,     3,     3,         12    ; Edge 13
 EDGE       8,       9,     3,     3,         12    ; Edge 14

.SHIP_SIDEWINDER_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       32,        8,         31    ; Face 0
 FACE      -12,       47,        6,         31    ; Face 1
 FACE       12,       47,        6,         31    ; Face 2
 FACE        0,        0,     -112,         31    ; Face 3
 FACE      -12,      -47,        6,         31    ; Face 4
 FACE        0,      -32,        8,         31    ; Face 5
 FACE       12,      -47,        6,         31    ; Face 6

; ******************************************************************************
;
;       Name: SHIP_MAMBA
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Mamba
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_MAMBA

 EQUB 1                 ; Max. canisters on demise = 1
 EQUW 70 * 70           ; Targetable area          = 70 * 70

 EQUB LO(SHIP_MAMBA_EDGES - SHIP_MAMBA)            ; Edges data offset (low)
 EQUB LO(SHIP_MAMBA_FACES - SHIP_MAMBA)            ; Faces data offset (low)

 EQUB 97                ; Max. edge count          = (97 - 1) / 4 = 24
 EQUB 0                 ; Gun vertex               = 0
 EQUB 34                ; Explosion count          = 7, as (4 * n) + 6 = 34
 EQUB 150               ; Number of vertices       = 150 / 6 = 25
 EQUB 28                ; Number of edges          = 28
 EQUW 150               ; Bounty                   = 150
 EQUB 20                ; Number of faces          = 20 / 4 = 5
 EQUB 25                ; Visibility distance      = 25
 EQUB 90                ; Max. energy              = 90
 EQUB 30                ; Max. speed               = 30

 EQUB HI(SHIP_MAMBA_EDGES - SHIP_MAMBA)            ; Edges data offset (high)
 EQUB HI(SHIP_MAMBA_FACES - SHIP_MAMBA)            ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00010010         ; Laser power              = 2
                        ; Missiles                 = 2

.SHIP_MAMBA_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,   64,     0,      1,    2,     3,         31    ; Vertex 0
 VERTEX  -64,   -8,  -32,     0,      2,    4,     4,         31    ; Vertex 1
 VERTEX  -32,    8,  -32,     1,      2,    4,     4,         30    ; Vertex 2
 VERTEX   32,    8,  -32,     1,      3,    4,     4,         30    ; Vertex 3
 VERTEX   64,   -8,  -32,     0,      3,    4,     4,         31    ; Vertex 4
 VERTEX   -4,    4,   16,     1,      1,    1,     1,         14    ; Vertex 5
 VERTEX    4,    4,   16,     1,      1,    1,     1,         14    ; Vertex 6
 VERTEX    8,    3,   28,     1,      1,    1,     1,         13    ; Vertex 7
 VERTEX   -8,    3,   28,     1,      1,    1,     1,         13    ; Vertex 8
 VERTEX  -20,   -4,   16,     0,      0,    0,     0,         20    ; Vertex 9
 VERTEX   20,   -4,   16,     0,      0,    0,     0,         20    ; Vertex 10
 VERTEX  -24,   -7,  -20,     0,      0,    0,     0,         20    ; Vertex 11
 VERTEX  -16,   -7,  -20,     0,      0,    0,     0,         16    ; Vertex 12
 VERTEX   16,   -7,  -20,     0,      0,    0,     0,         16    ; Vertex 13
 VERTEX   24,   -7,  -20,     0,      0,    0,     0,         20    ; Vertex 14
 VERTEX   -8,    4,  -32,     4,      4,    4,     4,         13    ; Vertex 15
 VERTEX    8,    4,  -32,     4,      4,    4,     4,         13    ; Vertex 16
 VERTEX    8,   -4,  -32,     4,      4,    4,     4,         14    ; Vertex 17
 VERTEX   -8,   -4,  -32,     4,      4,    4,     4,         14    ; Vertex 18
 VERTEX  -32,    4,  -32,     4,      4,    4,     4,          7    ; Vertex 19
 VERTEX   32,    4,  -32,     4,      4,    4,     4,          7    ; Vertex 20
 VERTEX   36,   -4,  -32,     4,      4,    4,     4,          7    ; Vertex 21
 VERTEX  -36,   -4,  -32,     4,      4,    4,     4,          7    ; Vertex 22
 VERTEX  -38,    0,  -32,     4,      4,    4,     4,          5    ; Vertex 23
 VERTEX   38,    0,  -32,     4,      4,    4,     4,          5    ; Vertex 24

.SHIP_MAMBA_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     0,     2,         31    ; Edge 0
 EDGE       0,       4,     0,     3,         31    ; Edge 1
 EDGE       1,       4,     0,     4,         31    ; Edge 2
 EDGE       1,       2,     2,     4,         30    ; Edge 3
 EDGE       2,       3,     1,     4,         30    ; Edge 4
 EDGE       3,       4,     3,     4,         30    ; Edge 5
 EDGE       5,       6,     1,     1,         14    ; Edge 6
 EDGE       6,       7,     1,     1,         12    ; Edge 7
 EDGE       7,       8,     1,     1,         13    ; Edge 8
 EDGE       5,       8,     1,     1,         12    ; Edge 9
 EDGE       9,      11,     0,     0,         20    ; Edge 10
 EDGE       9,      12,     0,     0,         16    ; Edge 11
 EDGE      10,      13,     0,     0,         16    ; Edge 12
 EDGE      10,      14,     0,     0,         20    ; Edge 13
 EDGE      13,      14,     0,     0,         14    ; Edge 14
 EDGE      11,      12,     0,     0,         14    ; Edge 15
 EDGE      15,      16,     4,     4,         13    ; Edge 16
 EDGE      17,      18,     4,     4,         14    ; Edge 17
 EDGE      15,      18,     4,     4,         12    ; Edge 18
 EDGE      16,      17,     4,     4,         12    ; Edge 19
 EDGE      20,      21,     4,     4,          7    ; Edge 20
 EDGE      20,      24,     4,     4,          5    ; Edge 21
 EDGE      21,      24,     4,     4,          5    ; Edge 22
 EDGE      19,      22,     4,     4,          7    ; Edge 23
 EDGE      19,      23,     4,     4,          5    ; Edge 24
 EDGE      22,      23,     4,     4,          5    ; Edge 25
 EDGE       0,       2,     1,     2,         30    ; Edge 26
 EDGE       0,       3,     1,     3,         30    ; Edge 27

.SHIP_MAMBA_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,      -24,        2,         30    ; Face 0
 FACE        0,       24,        2,         30    ; Face 1
 FACE      -32,       64,       16,         30    ; Face 2
 FACE       32,       64,       16,         30    ; Face 3
 FACE        0,        0,     -127,         30    ; Face 4

; ******************************************************************************
;
;       Name: SHIP_KRAIT
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Krait
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_KRAIT

 EQUB 1                 ; Max. canisters on demise = 1
 EQUW 60 * 60           ; Targetable area          = 60 * 60

 EQUB LO(SHIP_KRAIT_EDGES - SHIP_KRAIT)            ; Edges data offset (low)
 EQUB LO(SHIP_KRAIT_FACES - SHIP_KRAIT)            ; Faces data offset (low)

 EQUB 89                ; Max. edge count          = (89 - 1) / 4 = 22
 EQUB 0                 ; Gun vertex               = 0
 EQUB 18                ; Explosion count          = 3, as (4 * n) + 6 = 18
 EQUB 102               ; Number of vertices       = 102 / 6 = 17
 EQUB 21                ; Number of edges          = 21
 EQUW 100               ; Bounty                   = 100
 EQUB 24                ; Number of faces          = 24 / 4 = 6
 EQUB 20                ; Visibility distance      = 20
 EQUB 80                ; Max. energy              = 80
 EQUB 30                ; Max. speed               = 30

 EQUB HI(SHIP_KRAIT_EDGES - SHIP_KRAIT)            ; Edges data offset (high)
 EQUB HI(SHIP_KRAIT_FACES - SHIP_KRAIT)            ; Faces data offset (high)

 EQUB 1                 ; Normals are scaled by    = 2^1 = 2
 EQUB %00010000         ; Laser power              = 2
                        ; Missiles                 = 0

.SHIP_KRAIT_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,   96,     1,      0,    3,     2,         31    ; Vertex 0
 VERTEX    0,   18,  -48,     3,      0,    5,     4,         31    ; Vertex 1
 VERTEX    0,  -18,  -48,     2,      1,    5,     4,         31    ; Vertex 2
 VERTEX   90,    0,   -3,     1,      0,    4,     4,         31    ; Vertex 3
 VERTEX  -90,    0,   -3,     3,      2,    5,     5,         31    ; Vertex 4
 VERTEX   90,    0,   87,     1,      0,    1,     1,         30    ; Vertex 5
 VERTEX  -90,    0,   87,     3,      2,    3,     3,         30    ; Vertex 6
 VERTEX    0,    5,   53,     0,      0,    3,     3,          9    ; Vertex 7
 VERTEX    0,    7,   38,     0,      0,    3,     3,          6    ; Vertex 8
 VERTEX  -18,    7,   19,     3,      3,    3,     3,          9    ; Vertex 9
 VERTEX   18,    7,   19,     0,      0,    0,     0,          9    ; Vertex 10
 VERTEX   18,   11,  -39,     4,      4,    4,     4,          8    ; Vertex 11
 VERTEX   18,  -11,  -39,     4,      4,    4,     4,          8    ; Vertex 12
 VERTEX   36,    0,  -30,     4,      4,    4,     4,          8    ; Vertex 13
 VERTEX  -18,   11,  -39,     5,      5,    5,     5,          8    ; Vertex 14
 VERTEX  -18,  -11,  -39,     5,      5,    5,     5,          8    ; Vertex 15
 VERTEX  -36,    0,  -30,     5,      5,    5,     5,          8    ; Vertex 16

.SHIP_KRAIT_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     3,     0,         31    ; Edge 0
 EDGE       0,       2,     2,     1,         31    ; Edge 1
 EDGE       0,       3,     1,     0,         31    ; Edge 2
 EDGE       0,       4,     3,     2,         31    ; Edge 3
 EDGE       1,       4,     5,     3,         31    ; Edge 4
 EDGE       4,       2,     5,     2,         31    ; Edge 5
 EDGE       2,       3,     4,     1,         31    ; Edge 6
 EDGE       3,       1,     4,     0,         31    ; Edge 7
 EDGE       3,       5,     1,     0,         30    ; Edge 8
 EDGE       4,       6,     3,     2,         30    ; Edge 9
 EDGE       1,       2,     5,     4,          8    ; Edge 10
 EDGE       7,      10,     0,     0,          9    ; Edge 11
 EDGE       8,      10,     0,     0,          6    ; Edge 12
 EDGE       7,       9,     3,     3,          9    ; Edge 13
 EDGE       8,       9,     3,     3,          6    ; Edge 14
 EDGE      11,      13,     4,     4,          8    ; Edge 15
 EDGE      13,      12,     4,     4,          8    ; Edge 16
 EDGE      12,      11,     4,     4,          7    ; Edge 17
 EDGE      14,      15,     5,     5,          7    ; Edge 18
 EDGE      15,      16,     5,     5,          8    ; Edge 19
 EDGE      16,      14,     5,     5,          8    ; Edge 20

.SHIP_KRAIT_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        3,       24,        3,         31    ; Face 0
 FACE        3,      -24,        3,         31    ; Face 1
 FACE       -3,      -24,        3,         31    ; Face 2
 FACE       -3,       24,        3,         31    ; Face 3
 FACE       38,        0,      -77,         31    ; Face 4
 FACE      -38,        0,      -77,         31    ; Face 5

; ******************************************************************************
;
;       Name: SHIP_ADDER
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for an Adder
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_ADDER

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 50 * 50           ; Targetable area          = 50 * 50

 EQUB LO(SHIP_ADDER_EDGES - SHIP_ADDER)            ; Edges data offset (low)
 EQUB LO(SHIP_ADDER_FACES - SHIP_ADDER)            ; Faces data offset (low)

 EQUB 101               ; Max. edge count          = (101 - 1) / 4 = 25
 EQUB 0                 ; Gun vertex               = 0
 EQUB 22                ; Explosion count          = 4, as (4 * n) + 6 = 22
 EQUB 108               ; Number of vertices       = 108 / 6 = 18
 EQUB 29                ; Number of edges          = 29
 EQUW 40                ; Bounty                   = 40
 EQUB 60                ; Number of faces          = 60 / 4 = 15
 EQUB 20                ; Visibility distance      = 20
 EQUB 85                ; Max. energy              = 85
 EQUB 24                ; Max. speed               = 24

 EQUB HI(SHIP_ADDER_EDGES - SHIP_ADDER)            ; Edges data offset (high)
 EQUB HI(SHIP_ADDER_FACES - SHIP_ADDER)            ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00010000         ; Laser power              = 2
                        ; Missiles                 = 0

.SHIP_ADDER_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -18,    0,   40,     1,      0,   12,    11,         31    ; Vertex 0
 VERTEX   18,    0,   40,     1,      0,    3,     2,         31    ; Vertex 1
 VERTEX   30,    0,  -24,     3,      2,    5,     4,         31    ; Vertex 2
 VERTEX   30,    0,  -40,     5,      4,    6,     6,         31    ; Vertex 3
 VERTEX   18,   -7,  -40,     6,      5,   14,     7,         31    ; Vertex 4
 VERTEX  -18,   -7,  -40,     8,      7,   14,    10,         31    ; Vertex 5
 VERTEX  -30,    0,  -40,     9,      8,   10,    10,         31    ; Vertex 6
 VERTEX  -30,    0,  -24,    10,      9,   12,    11,         31    ; Vertex 7
 VERTEX  -18,    7,  -40,     8,      7,   13,     9,         31    ; Vertex 8
 VERTEX   18,    7,  -40,     6,      4,   13,     7,         31    ; Vertex 9
 VERTEX  -18,    7,   13,     9,      0,   13,    11,         31    ; Vertex 10
 VERTEX   18,    7,   13,     2,      0,   13,     4,         31    ; Vertex 11
 VERTEX  -18,   -7,   13,    10,      1,   14,    12,         31    ; Vertex 12
 VERTEX   18,   -7,   13,     3,      1,   14,     5,         31    ; Vertex 13
 VERTEX  -11,    3,   29,     0,      0,    0,     0,          5    ; Vertex 14
 VERTEX   11,    3,   29,     0,      0,    0,     0,          5    ; Vertex 15
 VERTEX   11,    4,   24,     0,      0,    0,     0,          4    ; Vertex 16
 VERTEX  -11,    4,   24,     0,      0,    0,     0,          4    ; Vertex 17

.SHIP_ADDER_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     1,     0,         31    ; Edge 0
 EDGE       1,       2,     3,     2,          7    ; Edge 1
 EDGE       2,       3,     5,     4,         31    ; Edge 2
 EDGE       3,       4,     6,     5,         31    ; Edge 3
 EDGE       4,       5,    14,     7,         31    ; Edge 4
 EDGE       5,       6,    10,     8,         31    ; Edge 5
 EDGE       6,       7,    10,     9,         31    ; Edge 6
 EDGE       7,       0,    12,    11,          7    ; Edge 7
 EDGE       3,       9,     6,     4,         31    ; Edge 8
 EDGE       9,       8,    13,     7,         31    ; Edge 9
 EDGE       8,       6,     9,     8,         31    ; Edge 10
 EDGE       0,      10,    11,     0,         31    ; Edge 11
 EDGE       7,      10,    11,     9,         31    ; Edge 12
 EDGE       1,      11,     2,     0,         31    ; Edge 13
 EDGE       2,      11,     4,     2,         31    ; Edge 14
 EDGE       0,      12,    12,     1,         31    ; Edge 15
 EDGE       7,      12,    12,    10,         31    ; Edge 16
 EDGE       1,      13,     3,     1,         31    ; Edge 17
 EDGE       2,      13,     5,     3,         31    ; Edge 18
 EDGE      10,      11,    13,     0,         31    ; Edge 19
 EDGE      12,      13,    14,     1,         31    ; Edge 20
 EDGE       8,      10,    13,     9,         31    ; Edge 21
 EDGE       9,      11,    13,     4,         31    ; Edge 22
 EDGE       5,      12,    14,    10,         31    ; Edge 23
 EDGE       4,      13,    14,     5,         31    ; Edge 24
 EDGE      14,      15,     0,     0,          5    ; Edge 25
 EDGE      15,      16,     0,     0,          3    ; Edge 26
 EDGE      16,      17,     0,     0,          4    ; Edge 27
 EDGE      17,      14,     0,     0,          3    ; Edge 28

.SHIP_ADDER_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       39,       10,         31    ; Face 0
 FACE        0,      -39,       10,         31    ; Face 1
 FACE       69,       50,       13,         31    ; Face 2
 FACE       69,      -50,       13,         31    ; Face 3
 FACE       30,       52,        0,         31    ; Face 4
 FACE       30,      -52,        0,         31    ; Face 5
 FACE        0,        0,     -160,         31    ; Face 6
 FACE        0,        0,     -160,         31    ; Face 7
 FACE        0,        0,     -160,         31    ; Face 8
 FACE      -30,       52,        0,         31    ; Face 9
 FACE      -30,      -52,        0,         31    ; Face 10
 FACE      -69,       50,       13,         31    ; Face 11
 FACE      -69,      -50,       13,         31    ; Face 12
 FACE        0,       28,        0,         31    ; Face 13
 FACE        0,      -28,        0,         31    ; Face 14

; ******************************************************************************
;
;       Name: SHIP_GECKO
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Gecko
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_GECKO

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 99 * 99           ; Targetable area          = 99 * 99

 EQUB LO(SHIP_GECKO_EDGES - SHIP_GECKO)            ; Edges data offset (low)
 EQUB LO(SHIP_GECKO_FACES - SHIP_GECKO)            ; Faces data offset (low)

 EQUB 69                ; Max. edge count          = (69 - 1) / 4 = 17
 EQUB 0                 ; Gun vertex               = 0
 EQUB 26                ; Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 72                ; Number of vertices       = 72 / 6 = 12
 EQUB 17                ; Number of edges          = 17
 EQUW 55                ; Bounty                   = 55
 EQUB 36                ; Number of faces          = 36 / 4 = 9
 EQUB 18                ; Visibility distance      = 18
 EQUB 70                ; Max. energy              = 70
 EQUB 30                ; Max. speed               = 30

 EQUB HI(SHIP_GECKO_EDGES - SHIP_GECKO)            ; Edges data offset (high)
 EQUB HI(SHIP_GECKO_FACES - SHIP_GECKO)            ; Faces data offset (high)

 EQUB 3                 ; Normals are scaled by    = 2^3 = 8
 EQUB %00010000         ; Laser power              = 2
                        ; Missiles                 = 0

.SHIP_GECKO_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -10,   -4,   47,     3,      0,    5,     4,         31    ; Vertex 0
 VERTEX   10,   -4,   47,     1,      0,    3,     2,         31    ; Vertex 1
 VERTEX  -16,    8,  -23,     5,      0,    7,     6,         31    ; Vertex 2
 VERTEX   16,    8,  -23,     1,      0,    8,     7,         31    ; Vertex 3
 VERTEX  -66,    0,   -3,     5,      4,    6,     6,         31    ; Vertex 4
 VERTEX   66,    0,   -3,     2,      1,    8,     8,         31    ; Vertex 5
 VERTEX  -20,  -14,  -23,     4,      3,    7,     6,         31    ; Vertex 6
 VERTEX   20,  -14,  -23,     3,      2,    8,     7,         31    ; Vertex 7
 VERTEX   -8,   -6,   33,     3,      3,    3,     3,         16    ; Vertex 8
 VERTEX    8,   -6,   33,     3,      3,    3,     3,         17    ; Vertex 9
 VERTEX   -8,  -13,  -16,     3,      3,    3,     3,         16    ; Vertex 10
 VERTEX    8,  -13,  -16,     3,      3,    3,     3,         17    ; Vertex 11

.SHIP_GECKO_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     3,     0,         31    ; Edge 0
 EDGE       1,       5,     2,     1,         31    ; Edge 1
 EDGE       5,       3,     8,     1,         31    ; Edge 2
 EDGE       3,       2,     7,     0,         31    ; Edge 3
 EDGE       2,       4,     6,     5,         31    ; Edge 4
 EDGE       4,       0,     5,     4,         31    ; Edge 5
 EDGE       5,       7,     8,     2,         31    ; Edge 6
 EDGE       7,       6,     7,     3,         31    ; Edge 7
 EDGE       6,       4,     6,     4,         31    ; Edge 8
 EDGE       0,       2,     5,     0,         29    ; Edge 9
 EDGE       1,       3,     1,     0,         30    ; Edge 10
 EDGE       0,       6,     4,     3,         29    ; Edge 11
 EDGE       1,       7,     3,     2,         30    ; Edge 12
 EDGE       2,       6,     7,     6,         20    ; Edge 13
 EDGE       3,       7,     8,     7,         20    ; Edge 14
 EDGE       8,      10,     3,     3,         16    ; Edge 15
 EDGE       9,      11,     3,     3,         17    ; Edge 16

.SHIP_GECKO_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       31,        5,         31    ; Face 0
 FACE        4,       45,        8,         31    ; Face 1
 FACE       25,     -108,       19,         31    ; Face 2
 FACE        0,      -84,       12,         31    ; Face 3
 FACE      -25,     -108,       19,         31    ; Face 4
 FACE       -4,       45,        8,         31    ; Face 5
 FACE      -88,       16,     -214,         31    ; Face 6
 FACE        0,        0,     -187,         31    ; Face 7
 FACE       88,       16,     -214,         31    ; Face 8

; ******************************************************************************
;
;       Name: SHIP_COBRA_MK_1
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Cobra Mk I
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_COBRA_MK_1

 EQUB 3                 ; Max. canisters on demise = 3
 EQUW 99 * 99           ; Targetable area          = 99 * 99

 EQUB LO(SHIP_COBRA_MK_1_EDGES - SHIP_COBRA_MK_1)  ; Edges data offset (low)
 EQUB LO(SHIP_COBRA_MK_1_FACES - SHIP_COBRA_MK_1)  ; Faces data offset (low)

 EQUB 73                ; Max. edge count          = (73 - 1) / 4 = 18
 EQUB 40                ; Gun vertex               = 40 / 4 = 10
 EQUB 26                ; Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 66                ; Number of vertices       = 66 / 6 = 11
 EQUB 18                ; Number of edges          = 18
 EQUW 75                ; Bounty                   = 75
 EQUB 40                ; Number of faces          = 40 / 4 = 10
 EQUB 19                ; Visibility distance      = 19
 EQUB 90                ; Max. energy              = 90
 EQUB 26                ; Max. speed               = 26

 EQUB HI(SHIP_COBRA_MK_1_EDGES - SHIP_COBRA_MK_1)  ; Edges data offset (high)
 EQUB HI(SHIP_COBRA_MK_1_FACES - SHIP_COBRA_MK_1)  ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00010010         ; Laser power              = 2
                        ; Missiles                 = 2

.SHIP_COBRA_MK_1_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX  -18,   -1,   50,     1,      0,    3,     2,         31    ; Vertex 0
 VERTEX   18,   -1,   50,     1,      0,    5,     4,         31    ; Vertex 1
 VERTEX  -66,    0,    7,     3,      2,    8,     8,         31    ; Vertex 2
 VERTEX   66,    0,    7,     5,      4,    9,     9,         31    ; Vertex 3
 VERTEX  -32,   12,  -38,     6,      2,    8,     7,         31    ; Vertex 4
 VERTEX   32,   12,  -38,     6,      4,    9,     7,         31    ; Vertex 5
 VERTEX  -54,  -12,  -38,     3,      1,    8,     7,         31    ; Vertex 6
 VERTEX   54,  -12,  -38,     5,      1,    9,     7,         31    ; Vertex 7
 VERTEX    0,   12,   -6,     2,      0,    6,     4,         20    ; Vertex 8
 VERTEX    0,   -1,   50,     1,      0,    1,     1,          2    ; Vertex 9
 VERTEX    0,   -1,   60,     1,      0,    1,     1,         31    ; Vertex 10

.SHIP_COBRA_MK_1_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       1,       0,     1,     0,         31    ; Edge 0
 EDGE       0,       2,     3,     2,         31    ; Edge 1
 EDGE       2,       6,     8,     3,         31    ; Edge 2
 EDGE       6,       7,     7,     1,         31    ; Edge 3
 EDGE       7,       3,     9,     5,         31    ; Edge 4
 EDGE       3,       1,     5,     4,         31    ; Edge 5
 EDGE       2,       4,     8,     2,         31    ; Edge 6
 EDGE       4,       5,     7,     6,         31    ; Edge 7
 EDGE       5,       3,     9,     4,         31    ; Edge 8
 EDGE       0,       8,     2,     0,         20    ; Edge 9
 EDGE       8,       1,     4,     0,         20    ; Edge 10
 EDGE       4,       8,     6,     2,         16    ; Edge 11
 EDGE       8,       5,     6,     4,         16    ; Edge 12
 EDGE       4,       6,     8,     7,         31    ; Edge 13
 EDGE       5,       7,     9,     7,         31    ; Edge 14
 EDGE       0,       6,     3,     1,         20    ; Edge 15
 EDGE       1,       7,     5,     1,         20    ; Edge 16
 EDGE      10,       9,     1,     0,          2    ; Edge 17

.SHIP_COBRA_MK_1_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       41,       10,         31    ; Face 0
 FACE        0,      -27,        3,         31    ; Face 1
 FACE       -8,       46,        8,         31    ; Face 2
 FACE      -12,      -57,       12,         31    ; Face 3
 FACE        8,       46,        8,         31    ; Face 4
 FACE       12,      -57,       12,         31    ; Face 5
 FACE        0,       49,        0,         31    ; Face 6
 FACE        0,        0,     -154,         31    ; Face 7
 FACE     -121,      111,      -62,         31    ; Face 8
 FACE      121,      111,      -62,         31    ; Face 9

; ******************************************************************************
;
;       Name: SHIP_WORM
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Worm
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_WORM

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 99 * 99           ; Targetable area          = 99 * 99

 EQUB LO(SHIP_WORM_EDGES - SHIP_WORM)              ; Edges data offset (low)
 EQUB LO(SHIP_WORM_FACES - SHIP_WORM)              ; Faces data offset (low)

 EQUB 77                ; Max. edge count          = (77 - 1) / 4 = 19
 EQUB 0                 ; Gun vertex               = 0
 EQUB 18                ; Explosion count          = 3, as (4 * n) + 6 = 18
 EQUB 60                ; Number of vertices       = 60 / 6 = 10
 EQUB 16                ; Number of edges          = 16
 EQUW 0                 ; Bounty                   = 0
 EQUB 32                ; Number of faces          = 32 / 4 = 8
 EQUB 19                ; Visibility distance      = 19
 EQUB 30                ; Max. energy              = 30
 EQUB 23                ; Max. speed               = 23

 EQUB HI(SHIP_WORM_EDGES - SHIP_WORM)              ; Edges data offset (high)
 EQUB HI(SHIP_WORM_FACES - SHIP_WORM)              ; Faces data offset (high)

 EQUB 3                 ; Normals are scaled by    = 2^3 = 8
 EQUB %00001000         ; Laser power              = 1
                        ; Missiles                 = 0

.SHIP_WORM_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   10,  -10,   35,     2,      0,    7,     7,         31    ; Vertex 0
 VERTEX  -10,  -10,   35,     3,      0,    7,     7,         31    ; Vertex 1
 VERTEX    5,    6,   15,     1,      0,    4,     2,         31    ; Vertex 2
 VERTEX   -5,    6,   15,     1,      0,    5,     3,         31    ; Vertex 3
 VERTEX   15,  -10,   25,     4,      2,    7,     7,         31    ; Vertex 4
 VERTEX  -15,  -10,   25,     5,      3,    7,     7,         31    ; Vertex 5
 VERTEX   26,  -10,  -25,     6,      4,    7,     7,         31    ; Vertex 6
 VERTEX  -26,  -10,  -25,     6,      5,    7,     7,         31    ; Vertex 7
 VERTEX    8,   14,  -25,     4,      1,    6,     6,         31    ; Vertex 8
 VERTEX   -8,   14,  -25,     5,      1,    6,     6,         31    ; Vertex 9

.SHIP_WORM_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     7,     0,         31    ; Edge 0
 EDGE       1,       5,     7,     3,         31    ; Edge 1
 EDGE       5,       7,     7,     5,         31    ; Edge 2
 EDGE       7,       6,     7,     6,         31    ; Edge 3
 EDGE       6,       4,     7,     4,         31    ; Edge 4
 EDGE       4,       0,     7,     2,         31    ; Edge 5
 EDGE       0,       2,     2,     0,         31    ; Edge 6
 EDGE       1,       3,     3,     0,         31    ; Edge 7
 EDGE       4,       2,     4,     2,         31    ; Edge 8
 EDGE       5,       3,     5,     3,         31    ; Edge 9
 EDGE       2,       8,     4,     1,         31    ; Edge 10
 EDGE       8,       6,     6,     4,         31    ; Edge 11
 EDGE       3,       9,     5,     1,         31    ; Edge 12
 EDGE       9,       7,     6,     5,         31    ; Edge 13
 EDGE       2,       3,     1,     0,         31    ; Edge 14
 EDGE       8,       9,     6,     1,         31    ; Edge 15

.SHIP_WORM_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       88,       70,         31    ; Face 0
 FACE        0,       69,       14,         31    ; Face 1
 FACE       70,       66,       35,         31    ; Face 2
 FACE      -70,       66,       35,         31    ; Face 3
 FACE       64,       49,       14,         31    ; Face 4
 FACE      -64,       49,       14,         31    ; Face 5
 FACE        0,        0,     -200,         31    ; Face 6
 FACE        0,      -80,        0,         31    ; Face 7

; ******************************************************************************
;
;       Name: SHIP_COBRA_MK_3_P
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Cobra Mk III (pirate)
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_COBRA_MK_3_P

 EQUB 1                 ; Max. canisters on demise = 1
 EQUW 95 * 95           ; Targetable area          = 95 * 95

 EQUB LO(SHIP_COBRA_MK_3_EDGES - SHIP_COBRA_MK_3_P)   ; Edges from Cobra Mk III
 EQUB LO(SHIP_COBRA_MK_3_FACES - SHIP_COBRA_MK_3_P)   ; Faces from Cobra Mk III

 EQUB 157               ; Max. edge count          = (157 - 1) / 4 = 39
 EQUB 84                ; Gun vertex               = 84 / 4 = 21
 EQUB 42                ; Explosion count          = 9, as (4 * n) + 6 = 42
 EQUB 168               ; Number of vertices       = 168 / 6 = 28
 EQUB 38                ; Number of edges          = 38
 EQUW 175               ; Bounty                   = 175
 EQUB 52                ; Number of faces          = 52 / 4 = 13
 EQUB 50                ; Visibility distance      = 50
 EQUB 150               ; Max. energy              = 150
 EQUB 28                ; Max. speed               = 28

 EQUB HI(SHIP_COBRA_MK_3_EDGES - SHIP_COBRA_MK_3_P)   ; Edges from Cobra Mk III
 EQUB HI(SHIP_COBRA_MK_3_FACES - SHIP_COBRA_MK_3_P)   ; Faces from Cobra Mk III

 EQUB 1                 ; Normals are scaled by    = 2^1 = 2
 EQUB %00010010         ; Laser power              = 2
                        ; Missiles                 = 2

.SHIP_COBRA_MK_3_P_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   32,    0,   76,    15,     15,   15,    15,         31    ; Vertex 0
 VERTEX  -32,    0,   76,    15,     15,   15,    15,         31    ; Vertex 1
 VERTEX    0,   26,   24,    15,     15,   15,    15,         31    ; Vertex 2
 VERTEX -120,   -3,   -8,     3,      7,   10,    10,         31    ; Vertex 3
 VERTEX  120,   -3,   -8,     4,      8,   12,    12,         31    ; Vertex 4
 VERTEX  -88,   16,  -40,    15,     15,   15,    15,         31    ; Vertex 5
 VERTEX   88,   16,  -40,    15,     15,   15,    15,         31    ; Vertex 6
 VERTEX  128,   -8,  -40,     8,      9,   12,    12,         31    ; Vertex 7
 VERTEX -128,   -8,  -40,     7,      9,   10,    10,         31    ; Vertex 8
 VERTEX    0,   26,  -40,     5,      6,    9,     9,         31    ; Vertex 9
 VERTEX  -32,  -24,  -40,     9,     10,   11,    11,         31    ; Vertex 10
 VERTEX   32,  -24,  -40,     9,     11,   12,    12,         31    ; Vertex 11
 VERTEX  -36,    8,  -40,     9,      9,    9,     9,         20    ; Vertex 12
 VERTEX   -8,   12,  -40,     9,      9,    9,     9,         20    ; Vertex 13
 VERTEX    8,   12,  -40,     9,      9,    9,     9,         20    ; Vertex 14
 VERTEX   36,    8,  -40,     9,      9,    9,     9,         20    ; Vertex 15
 VERTEX   36,  -12,  -40,     9,      9,    9,     9,         20    ; Vertex 16
 VERTEX    8,  -16,  -40,     9,      9,    9,     9,         20    ; Vertex 17
 VERTEX   -8,  -16,  -40,     9,      9,    9,     9,         20    ; Vertex 18
 VERTEX  -36,  -12,  -40,     9,      9,    9,     9,         20    ; Vertex 19
 VERTEX    0,    0,   76,     0,     11,   11,    11,          6    ; Vertex 20
 VERTEX    0,    0,   90,     0,     11,   11,    11,         31    ; Vertex 21
 VERTEX  -80,   -6,  -40,     9,      9,    9,     9,          8    ; Vertex 22
 VERTEX  -80,    6,  -40,     9,      9,    9,     9,          8    ; Vertex 23
 VERTEX  -88,    0,  -40,     9,      9,    9,     9,          6    ; Vertex 24
 VERTEX   80,    6,  -40,     9,      9,    9,     9,          8    ; Vertex 25
 VERTEX   88,    0,  -40,     9,      9,    9,     9,          6    ; Vertex 26
 VERTEX   80,   -6,  -40,     9,      9,    9,     9,          8    ; Vertex 27

; ******************************************************************************
;
;       Name: SHIP_ASP_MK_2
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for an Asp Mk II
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_ASP_MK_2

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 60 * 60           ; Targetable area          = 60 * 60

 EQUB LO(SHIP_ASP_MK_2_EDGES - SHIP_ASP_MK_2)      ; Edges data offset (low)
 EQUB LO(SHIP_ASP_MK_2_FACES - SHIP_ASP_MK_2)      ; Faces data offset (low)

 EQUB 105               ; Max. edge count          = (105 - 1) / 4 = 26
 EQUB 32                ; Gun vertex               = 32 / 4 = 8
 EQUB 26                ; Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 114               ; Number of vertices       = 114 / 6 = 19
 EQUB 28                ; Number of edges          = 28
 EQUW 200               ; Bounty                   = 200
 EQUB 48                ; Number of faces          = 48 / 4 = 12
 EQUB 40                ; Visibility distance      = 40
 EQUB 150               ; Max. energy              = 150
 EQUB 40                ; Max. speed               = 40

 EQUB HI(SHIP_ASP_MK_2_EDGES - SHIP_ASP_MK_2)      ; Edges data offset (high)
 EQUB HI(SHIP_ASP_MK_2_FACES - SHIP_ASP_MK_2)      ; Faces data offset (high)

 EQUB 1                 ; Normals are scaled by    = 2^1 = 2
 EQUB %00101001         ; Laser power              = 5
                        ; Missiles                 = 1

.SHIP_ASP_MK_2_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,  -18,    0,     1,      0,    2,     2,         22    ; Vertex 0
 VERTEX    0,   -9,  -45,     2,      1,   11,    11,         31    ; Vertex 1
 VERTEX   43,    0,  -45,     6,      1,   11,    11,         31    ; Vertex 2
 VERTEX   69,   -3,    0,     6,      1,    9,     7,         31    ; Vertex 3
 VERTEX   43,  -14,   28,     1,      0,    7,     7,         31    ; Vertex 4
 VERTEX  -43,    0,  -45,     5,      2,   11,    11,         31    ; Vertex 5
 VERTEX  -69,   -3,    0,     5,      2,   10,     8,         31    ; Vertex 6
 VERTEX  -43,  -14,   28,     2,      0,    8,     8,         31    ; Vertex 7
 VERTEX   26,   -7,   73,     4,      0,    9,     7,         31    ; Vertex 8
 VERTEX  -26,   -7,   73,     4,      0,   10,     8,         31    ; Vertex 9
 VERTEX   43,   14,   28,     4,      3,    9,     6,         31    ; Vertex 10
 VERTEX  -43,   14,   28,     4,      3,   10,     5,         31    ; Vertex 11
 VERTEX    0,    9,  -45,     5,      3,   11,     6,         31    ; Vertex 12
 VERTEX  -17,    0,  -45,    11,     11,   11,    11,         10    ; Vertex 13
 VERTEX   17,    0,  -45,    11,     11,   11,    11,          9    ; Vertex 14
 VERTEX    0,   -4,  -45,    11,     11,   11,    11,         10    ; Vertex 15
 VERTEX    0,    4,  -45,    11,     11,   11,    11,          8    ; Vertex 16
 VERTEX    0,   -7,   73,     4,      0,    4,     0,         10    ; Vertex 17
 VERTEX    0,   -7,   83,     4,      0,    4,     0,         10    ; Vertex 18

.SHIP_ASP_MK_2_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     2,     1,         22    ; Edge 0
 EDGE       0,       4,     1,     0,         22    ; Edge 1
 EDGE       0,       7,     2,     0,         22    ; Edge 2
 EDGE       1,       2,    11,     1,         31    ; Edge 3
 EDGE       2,       3,     6,     1,         31    ; Edge 4
 EDGE       3,       8,     9,     7,         16    ; Edge 5
 EDGE       8,       9,     4,     0,         31    ; Edge 6
 EDGE       6,       9,    10,     8,         16    ; Edge 7
 EDGE       5,       6,     5,     2,         31    ; Edge 8
 EDGE       1,       5,    11,     2,         31    ; Edge 9
 EDGE       3,       4,     7,     1,         31    ; Edge 10
 EDGE       4,       8,     7,     0,         31    ; Edge 11
 EDGE       6,       7,     8,     2,         31    ; Edge 12
 EDGE       7,       9,     8,     0,         31    ; Edge 13
 EDGE       2,      12,    11,     6,         31    ; Edge 14
 EDGE       5,      12,    11,     5,         31    ; Edge 15
 EDGE      10,      12,     6,     3,         22    ; Edge 16
 EDGE      11,      12,     5,     3,         22    ; Edge 17
 EDGE      10,      11,     4,     3,         22    ; Edge 18
 EDGE       6,      11,    10,     5,         31    ; Edge 19
 EDGE       9,      11,    10,     4,         31    ; Edge 20
 EDGE       3,      10,     9,     6,         31    ; Edge 21
 EDGE       8,      10,     9,     4,         31    ; Edge 22
 EDGE      13,      15,    11,    11,         10    ; Edge 23
 EDGE      15,      14,    11,    11,          9    ; Edge 24
 EDGE      14,      16,    11,    11,          8    ; Edge 25
 EDGE      16,      13,    11,    11,          8    ; Edge 26
 EDGE      18,      17,     4,     0,         10    ; Edge 27

.SHIP_ASP_MK_2_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,      -35,        5,         31    ; Face 0
 FACE        8,      -38,       -7,         31    ; Face 1
 FACE       -8,      -38,       -7,         31    ; Face 2
 FACE        0,       24,       -1,         22    ; Face 3
 FACE        0,       43,       19,         31    ; Face 4
 FACE       -6,       28,       -2,         31    ; Face 5
 FACE        6,       28,       -2,         31    ; Face 6
 FACE       59,      -64,       31,         31    ; Face 7
 FACE      -59,      -64,       31,         31    ; Face 8
 FACE       80,       46,       50,         31    ; Face 9
 FACE      -80,       46,       50,         31    ; Face 10
 FACE        0,        0,      -90,         31    ; Face 11

 EQUB $E7, $33          ; These bytes appear to be unused
 EQUB $53, $08

; ******************************************************************************
;
;       Name: SHIP_PYTHON_P
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Python (pirate)
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_PYTHON_P

 EQUB 2                 ; Max. canisters on demise = 2
 EQUW 80 * 80           ; Targetable area          = 80 * 80

 EQUB LO(SHIP_PYTHON_EDGES - SHIP_PYTHON_P)        ; Edges from Python
 EQUB LO(SHIP_PYTHON_FACES - SHIP_PYTHON_P)        ; Faces from Python

 EQUB 89                ; Max. edge count          = (89 - 1) / 4 = 22
 EQUB 0                 ; Gun vertex               = 0
 EQUB 42                ; Explosion count          = 9, as (4 * n) + 6 = 42
 EQUB 66                ; Number of vertices       = 66 / 6 = 11
 EQUB 26                ; Number of edges          = 26
 EQUW 200               ; Bounty                   = 200
 EQUB 52                ; Number of faces          = 52 / 4 = 13
 EQUB 40                ; Visibility distance      = 40
 EQUB 250               ; Max. energy              = 250
 EQUB 20                ; Max. speed               = 20

 EQUB HI(SHIP_PYTHON_EDGES - SHIP_PYTHON_P)        ; Edges from Python
 EQUB HI(SHIP_PYTHON_FACES - SHIP_PYTHON_P)        ; Faces from Python

 EQUB 0                 ; Normals are scaled by    = 2^0 = 1
 EQUB %00011011         ; Laser power              = 3
                        ; Missiles                 = 3

.SHIP_PYTHON_P_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,    0,  224,     0,      1,    2,     3,         31    ; Vertex 0
 VERTEX    0,   48,   48,     0,      1,    4,     5,         31    ; Vertex 1
 VERTEX   96,    0,  -16,    15,     15,   15,    15,         31    ; Vertex 2
 VERTEX  -96,    0,  -16,    15,     15,   15,    15,         31    ; Vertex 3
 VERTEX    0,   48,  -32,     4,      5,    8,     9,         31    ; Vertex 4
 VERTEX    0,   24, -112,     9,      8,   12,    12,         31    ; Vertex 5
 VERTEX  -48,    0, -112,     8,     11,   12,    12,         31    ; Vertex 6
 VERTEX   48,    0, -112,     9,     10,   12,    12,         31    ; Vertex 7
 VERTEX    0,  -48,   48,     2,      3,    6,     7,         31    ; Vertex 8
 VERTEX    0,  -48,  -32,     6,      7,   10,    11,         31    ; Vertex 9
 VERTEX    0,  -24, -112,    10,     11,   12,    12,         31    ; Vertex 10

; ******************************************************************************
;
;       Name: SHIP_FER_DE_LANCE
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Fer-de-Lance
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_FER_DE_LANCE

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 40 * 40           ; Targetable area          = 40 * 40

 EQUB LO(SHIP_FER_DE_LANCE_EDGES - SHIP_FER_DE_LANCE) ; Edges data offset (low)
 EQUB LO(SHIP_FER_DE_LANCE_FACES - SHIP_FER_DE_LANCE) ; Faces data offset (low)

 EQUB 109               ; Max. edge count          = (109 - 1) / 4 = 27
 EQUB 0                 ; Gun vertex               = 0
 EQUB 26                ; Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 114               ; Number of vertices       = 114 / 6 = 19
 EQUB 27                ; Number of edges          = 27
 EQUW 0                 ; Bounty                   = 0
 EQUB 40                ; Number of faces          = 40 / 4 = 10
 EQUB 40                ; Visibility distance      = 40
 EQUB 160               ; Max. energy              = 160
 EQUB 30                ; Max. speed               = 30

 EQUB HI(SHIP_FER_DE_LANCE_EDGES - SHIP_FER_DE_LANCE) ; Edges data offset (high)
 EQUB HI(SHIP_FER_DE_LANCE_FACES - SHIP_FER_DE_LANCE) ; Faces data offset (high)

 EQUB 1                 ; Normals are scaled by    = 2^1 = 2
 EQUB %00010010         ; Laser power              = 2
                        ; Missiles                 = 2

.SHIP_FER_DE_LANCE_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,  -14,  108,     1,      0,    9,     5,         31    ; Vertex 0
 VERTEX  -40,  -14,   -4,     2,      1,    9,     9,         31    ; Vertex 1
 VERTEX  -12,  -14,  -52,     3,      2,    9,     9,         31    ; Vertex 2
 VERTEX   12,  -14,  -52,     4,      3,    9,     9,         31    ; Vertex 3
 VERTEX   40,  -14,   -4,     5,      4,    9,     9,         31    ; Vertex 4
 VERTEX  -40,   14,   -4,     1,      0,    6,     2,         28    ; Vertex 5
 VERTEX  -12,    2,  -52,     3,      2,    7,     6,         28    ; Vertex 6
 VERTEX   12,    2,  -52,     4,      3,    8,     7,         28    ; Vertex 7
 VERTEX   40,   14,   -4,     4,      0,    8,     5,         28    ; Vertex 8
 VERTEX    0,   18,  -20,     6,      0,    8,     7,         15    ; Vertex 9
 VERTEX   -3,  -11,   97,     0,      0,    0,     0,         11    ; Vertex 10
 VERTEX  -26,    8,   18,     0,      0,    0,     0,          9    ; Vertex 11
 VERTEX  -16,   14,   -4,     0,      0,    0,     0,         11    ; Vertex 12
 VERTEX    3,  -11,   97,     0,      0,    0,     0,         11    ; Vertex 13
 VERTEX   26,    8,   18,     0,      0,    0,     0,          9    ; Vertex 14
 VERTEX   16,   14,   -4,     0,      0,    0,     0,         11    ; Vertex 15
 VERTEX    0,  -14,  -20,     9,      9,    9,     9,         12    ; Vertex 16
 VERTEX  -14,  -14,   44,     9,      9,    9,     9,         12    ; Vertex 17
 VERTEX   14,  -14,   44,     9,      9,    9,     9,         12    ; Vertex 18

.SHIP_FER_DE_LANCE_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     9,     1,         31    ; Edge 0
 EDGE       1,       2,     9,     2,         31    ; Edge 1
 EDGE       2,       3,     9,     3,         31    ; Edge 2
 EDGE       3,       4,     9,     4,         31    ; Edge 3
 EDGE       0,       4,     9,     5,         31    ; Edge 4
 EDGE       0,       5,     1,     0,         28    ; Edge 5
 EDGE       5,       6,     6,     2,         28    ; Edge 6
 EDGE       6,       7,     7,     3,         28    ; Edge 7
 EDGE       7,       8,     8,     4,         28    ; Edge 8
 EDGE       0,       8,     5,     0,         28    ; Edge 9
 EDGE       5,       9,     6,     0,         15    ; Edge 10
 EDGE       6,       9,     7,     6,         11    ; Edge 11
 EDGE       7,       9,     8,     7,         11    ; Edge 12
 EDGE       8,       9,     8,     0,         15    ; Edge 13
 EDGE       1,       5,     2,     1,         14    ; Edge 14
 EDGE       2,       6,     3,     2,         14    ; Edge 15
 EDGE       3,       7,     4,     3,         14    ; Edge 16
 EDGE       4,       8,     5,     4,         14    ; Edge 17
 EDGE      10,      11,     0,     0,          8    ; Edge 18
 EDGE      11,      12,     0,     0,          9    ; Edge 19
 EDGE      10,      12,     0,     0,         11    ; Edge 20
 EDGE      13,      14,     0,     0,          8    ; Edge 21
 EDGE      14,      15,     0,     0,          9    ; Edge 22
 EDGE      13,      15,     0,     0,         11    ; Edge 23
 EDGE      16,      17,     9,     9,         12    ; Edge 24
 EDGE      16,      18,     9,     9,         12    ; Edge 25
 EDGE      17,      18,     9,     9,          8    ; Edge 26

.SHIP_FER_DE_LANCE_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       24,        6,         28    ; Face 0
 FACE      -68,        0,       24,         31    ; Face 1
 FACE      -63,        0,      -37,         31    ; Face 2
 FACE        0,        0,     -104,         31    ; Face 3
 FACE       63,        0,      -37,         31    ; Face 4
 FACE       68,        0,       24,         31    ; Face 5
 FACE      -12,       46,      -19,         28    ; Face 6
 FACE        0,       45,      -22,         28    ; Face 7
 FACE       12,       46,      -19,         28    ; Face 8
 FACE        0,      -28,        0,         31    ; Face 9

; ******************************************************************************
;
;       Name: SHIP_MORAY
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Moray
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_MORAY

 EQUB 1                 ; Max. canisters on demise = 1
 EQUW 30 * 30           ; Targetable area          = 30 * 30

 EQUB LO(SHIP_MORAY_EDGES - SHIP_MORAY)            ; Edges data offset (low)
 EQUB LO(SHIP_MORAY_FACES - SHIP_MORAY)            ; Faces data offset (low)

 EQUB 73                ; Max. edge count          = (73 - 1) / 4 = 18
 EQUB 0                 ; Gun vertex               = 0
 EQUB 26                ; Explosion count          = 5, as (4 * n) + 6 = 26
 EQUB 84                ; Number of vertices       = 84 / 6 = 14
 EQUB 19                ; Number of edges          = 19
 EQUW 50                ; Bounty                   = 50
 EQUB 36                ; Number of faces          = 36 / 4 = 9
 EQUB 40                ; Visibility distance      = 40
 EQUB 100               ; Max. energy              = 100
 EQUB 25                ; Max. speed               = 25

 EQUB HI(SHIP_MORAY_EDGES - SHIP_MORAY)            ; Edges data offset (high)
 EQUB HI(SHIP_MORAY_FACES - SHIP_MORAY)            ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00010000         ; Laser power              = 2
                        ; Missiles                 = 0

.SHIP_MORAY_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   15,    0,   65,     2,      0,    8,     7,         31    ; Vertex 0
 VERTEX  -15,    0,   65,     1,      0,    7,     6,         31    ; Vertex 1
 VERTEX    0,   18,  -40,    15,     15,   15,    15,         17    ; Vertex 2
 VERTEX  -60,    0,    0,     3,      1,    6,     6,         31    ; Vertex 3
 VERTEX   60,    0,    0,     5,      2,    8,     8,         31    ; Vertex 4
 VERTEX   30,  -27,  -10,     5,      4,    8,     7,         24    ; Vertex 5
 VERTEX  -30,  -27,  -10,     4,      3,    7,     6,         24    ; Vertex 6
 VERTEX   -9,   -4,  -25,     4,      4,    4,     4,          7    ; Vertex 7
 VERTEX    9,   -4,  -25,     4,      4,    4,     4,          7    ; Vertex 8
 VERTEX    0,  -18,  -16,     4,      4,    4,     4,          7    ; Vertex 9
 VERTEX   13,    3,   49,     0,      0,    0,     0,          5    ; Vertex 10
 VERTEX    6,    0,   65,     0,      0,    0,     0,          5    ; Vertex 11
 VERTEX  -13,    3,   49,     0,      0,    0,     0,          5    ; Vertex 12
 VERTEX   -6,    0,   65,     0,      0,    0,     0,          5    ; Vertex 13

.SHIP_MORAY_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     7,     0,         31    ; Edge 0
 EDGE       1,       3,     6,     1,         31    ; Edge 1
 EDGE       3,       6,     6,     3,         24    ; Edge 2
 EDGE       5,       6,     7,     4,         24    ; Edge 3
 EDGE       4,       5,     8,     5,         24    ; Edge 4
 EDGE       0,       4,     8,     2,         31    ; Edge 5
 EDGE       1,       6,     7,     6,         15    ; Edge 6
 EDGE       0,       5,     8,     7,         15    ; Edge 7
 EDGE       0,       2,     2,     0,         15    ; Edge 8
 EDGE       1,       2,     1,     0,         15    ; Edge 9
 EDGE       2,       3,     3,     1,         17    ; Edge 10
 EDGE       2,       4,     5,     2,         17    ; Edge 11
 EDGE       2,       5,     5,     4,         13    ; Edge 12
 EDGE       2,       6,     4,     3,         13    ; Edge 13
 EDGE       7,       8,     4,     4,          5    ; Edge 14
 EDGE       7,       9,     4,     4,          7    ; Edge 15
 EDGE       8,       9,     4,     4,          7    ; Edge 16
 EDGE      10,      11,     0,     0,          5    ; Edge 17
 EDGE      12,      13,     0,     0,          5    ; Edge 18

.SHIP_MORAY_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       43,        7,         31    ; Face 0
 FACE      -10,       49,        7,         31    ; Face 1
 FACE       10,       49,        7,         31    ; Face 2
 FACE      -59,      -28,     -101,         24    ; Face 3
 FACE        0,      -52,      -78,         24    ; Face 4
 FACE       59,      -28,     -101,         24    ; Face 5
 FACE      -72,      -99,       50,         31    ; Face 6
 FACE        0,      -83,       30,         31    ; Face 7
 FACE       72,      -99,       50,         31    ; Face 8

; ******************************************************************************
;
;       Name: SHIP_THARGOID
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Thargoid mothership
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_THARGOID

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 99 * 99           ; Targetable area          = 99 * 99

 EQUB LO(SHIP_THARGOID_EDGES - SHIP_THARGOID)      ; Edges data offset (low)
 EQUB LO(SHIP_THARGOID_FACES - SHIP_THARGOID)      ; Faces data offset (low)

 EQUB 105               ; Max. edge count          = (105 - 1) / 4 = 26
 EQUB 60                ; Gun vertex               = 60 / 4 = 15
 EQUB 38                ; Explosion count          = 8, as (4 * n) + 6 = 38
 EQUB 120               ; Number of vertices       = 120 / 6 = 20
 EQUB 26                ; Number of edges          = 26
 EQUW 500               ; Bounty                   = 500
 EQUB 40                ; Number of faces          = 40 / 4 = 10
 EQUB 55                ; Visibility distance      = 55
 EQUB 240               ; Max. energy              = 240
 EQUB 39                ; Max. speed               = 39

 EQUB HI(SHIP_THARGOID_EDGES - SHIP_THARGOID)      ; Edges data offset (high)
 EQUB HI(SHIP_THARGOID_FACES - SHIP_THARGOID)      ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00010110         ; Laser power              = 2
                        ; Missiles                 = 6

.SHIP_THARGOID_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   32,  -48,   48,     0,      4,    8,     8,         31    ; Vertex 0
 VERTEX   32,  -68,    0,     0,      1,    4,     4,         31    ; Vertex 1
 VERTEX   32,  -48,  -48,     1,      2,    4,     4,         31    ; Vertex 2
 VERTEX   32,    0,  -68,     2,      3,    4,     4,         31    ; Vertex 3
 VERTEX   32,   48,  -48,     3,      4,    5,     5,         31    ; Vertex 4
 VERTEX   32,   68,    0,     4,      5,    6,     6,         31    ; Vertex 5
 VERTEX   32,   48,   48,     4,      6,    7,     7,         31    ; Vertex 6
 VERTEX   32,    0,   68,     4,      7,    8,     8,         31    ; Vertex 7
 VERTEX  -24, -116,  116,     0,      8,    9,     9,         31    ; Vertex 8
 VERTEX  -24, -164,    0,     0,      1,    9,     9,         31    ; Vertex 9
 VERTEX  -24, -116, -116,     1,      2,    9,     9,         31    ; Vertex 10
 VERTEX  -24,    0, -164,     2,      3,    9,     9,         31    ; Vertex 11
 VERTEX  -24,  116, -116,     3,      5,    9,     9,         31    ; Vertex 12
 VERTEX  -24,  164,    0,     5,      6,    9,     9,         31    ; Vertex 13
 VERTEX  -24,  116,  116,     6,      7,    9,     9,         31    ; Vertex 14
 VERTEX  -24,    0,  164,     7,      8,    9,     9,         31    ; Vertex 15
 VERTEX  -24,   64,   80,     9,      9,    9,     9,         30    ; Vertex 16
 VERTEX  -24,   64,  -80,     9,      9,    9,     9,         30    ; Vertex 17
 VERTEX  -24,  -64,  -80,     9,      9,    9,     9,         30    ; Vertex 18
 VERTEX  -24,  -64,   80,     9,      9,    9,     9,         30    ; Vertex 19

.SHIP_THARGOID_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       7,     4,     8,         31    ; Edge 0
 EDGE       0,       1,     0,     4,         31    ; Edge 1
 EDGE       1,       2,     1,     4,         31    ; Edge 2
 EDGE       2,       3,     2,     4,         31    ; Edge 3
 EDGE       3,       4,     3,     4,         31    ; Edge 4
 EDGE       4,       5,     4,     5,         31    ; Edge 5
 EDGE       5,       6,     4,     6,         31    ; Edge 6
 EDGE       6,       7,     4,     7,         31    ; Edge 7
 EDGE       0,       8,     0,     8,         31    ; Edge 8
 EDGE       1,       9,     0,     1,         31    ; Edge 9
 EDGE       2,      10,     1,     2,         31    ; Edge 10
 EDGE       3,      11,     2,     3,         31    ; Edge 11
 EDGE       4,      12,     3,     5,         31    ; Edge 12
 EDGE       5,      13,     5,     6,         31    ; Edge 13
 EDGE       6,      14,     6,     7,         31    ; Edge 14
 EDGE       7,      15,     7,     8,         31    ; Edge 15
 EDGE       8,      15,     8,     9,         31    ; Edge 16
 EDGE       8,       9,     0,     9,         31    ; Edge 17
 EDGE       9,      10,     1,     9,         31    ; Edge 18
 EDGE      10,      11,     2,     9,         31    ; Edge 19
 EDGE      11,      12,     3,     9,         31    ; Edge 20
 EDGE      12,      13,     5,     9,         31    ; Edge 21
 EDGE      13,      14,     6,     9,         31    ; Edge 22
 EDGE      14,      15,     7,     9,         31    ; Edge 23
 EDGE      16,      17,     9,     9,         30    ; Edge 24
 EDGE      18,      19,     9,     9,         30    ; Edge 25

.SHIP_THARGOID_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE      103,      -60,       25,         31    ; Face 0
 FACE      103,      -60,      -25,         31    ; Face 1
 FACE      103,      -25,      -60,         31    ; Face 2
 FACE      103,       25,      -60,         31    ; Face 3
 FACE       64,        0,        0,         31    ; Face 4
 FACE      103,       60,      -25,         31    ; Face 5
 FACE      103,       60,       25,         31    ; Face 6
 FACE      103,       25,       60,         31    ; Face 7
 FACE      103,      -25,       60,         31    ; Face 8
 FACE      -48,        0,        0,         31    ; Face 9

; ******************************************************************************
;
;       Name: SHIP_THARGON
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Thargon
;  Deep dive: Ship blueprints
;
; ------------------------------------------------------------------------------
;
; The ship blueprint for the Thargon reuses the edges data from the cargo
; canister, so the edges data offset is negative.
;
; ******************************************************************************

.SHIP_THARGON

 EQUB 0 + (15 << 4)     ; Max. canisters on demise = 0
                        ; Market item when scooped = 15 + 1 = 16 (alien items)
 EQUW 40 * 40           ; Targetable area          = 40 * 40

 EQUB LO(SHIP_CANISTER_EDGES - SHIP_THARGON)       ; Edges from canister
 EQUB LO(SHIP_THARGON_FACES - SHIP_THARGON)        ; Faces data offset (low)

 EQUB 69                ; Max. edge count          = (69 - 1) / 4 = 17
 EQUB 0                 ; Gun vertex               = 0
 EQUB 18                ; Explosion count          = 3, as (4 * n) + 6 = 18
 EQUB 60                ; Number of vertices       = 60 / 6 = 10
 EQUB 15                ; Number of edges          = 15
 EQUW 50                ; Bounty                   = 50
 EQUB 28                ; Number of faces          = 28 / 4 = 7
 EQUB 20                ; Visibility distance      = 20
 EQUB 20                ; Max. energy              = 20
 EQUB 30                ; Max. speed               = 30

 EQUB HI(SHIP_CANISTER_EDGES - SHIP_THARGON)       ; Edges from canister
 EQUB HI(SHIP_THARGON_FACES - SHIP_THARGON)        ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00010000         ; Laser power              = 2
                        ; Missiles                 = 0

.SHIP_THARGON_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   -9,    0,   40,     1,      0,    5,     5,         31    ; Vertex 0
 VERTEX   -9,  -38,   12,     1,      0,    2,     2,         31    ; Vertex 1
 VERTEX   -9,  -24,  -32,     2,      0,    3,     3,         31    ; Vertex 2
 VERTEX   -9,   24,  -32,     3,      0,    4,     4,         31    ; Vertex 3
 VERTEX   -9,   38,   12,     4,      0,    5,     5,         31    ; Vertex 4
 VERTEX    9,    0,   -8,     5,      1,    6,     6,         31    ; Vertex 5
 VERTEX    9,  -10,  -15,     2,      1,    6,     6,         31    ; Vertex 6
 VERTEX    9,   -6,  -26,     3,      2,    6,     6,         31    ; Vertex 7
 VERTEX    9,    6,  -26,     4,      3,    6,     6,         31    ; Vertex 8
 VERTEX    9,   10,  -15,     5,      4,    6,     6,         31    ; Vertex 9

.SHIP_THARGON_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE      -36,        0,        0,         31    ; Face 0
 FACE       20,       -5,        7,         31    ; Face 1
 FACE       46,      -42,      -14,         31    ; Face 2
 FACE       36,        0,     -104,         31    ; Face 3
 FACE       46,       42,      -14,         31    ; Face 4
 FACE       20,        5,        7,         31    ; Face 5
 FACE       36,        0,        0,         31    ; Face 6

; ******************************************************************************
;
;       Name: SHIP_CONSTRICTOR
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Constrictor
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_CONSTRICTOR

 EQUB 3                 ; Max. canisters on demise = 3
 EQUW 65 * 65           ; Targetable area          = 65 * 65

 EQUB LO(SHIP_CONSTRICTOR_EDGES - SHIP_CONSTRICTOR)   ; Edges data offset (low)
 EQUB LO(SHIP_CONSTRICTOR_FACES - SHIP_CONSTRICTOR)   ; Faces data offset (low)

 EQUB 81                ; Max. edge count          = (81 - 1) / 4 = 20
 EQUB 0                 ; Gun vertex               = 0
 EQUB 46                ; Explosion count          = 10, as (4 * n) + 6 = 46
 EQUB 102               ; Number of vertices       = 102 / 6 = 17
 EQUB 24                ; Number of edges          = 24
 EQUW 0                 ; Bounty                   = 0
 EQUB 40                ; Number of faces          = 40 / 4 = 10
 EQUB 45                ; Visibility distance      = 45
 EQUB 252               ; Max. energy              = 252
 EQUB 36                ; Max. speed               = 36

 EQUB HI(SHIP_CONSTRICTOR_EDGES - SHIP_CONSTRICTOR)   ; Edges data offset (high)
 EQUB HI(SHIP_CONSTRICTOR_FACES - SHIP_CONSTRICTOR)   ; Faces data offset (high)

 EQUB 2                 ; Normals are scaled by    = 2^2 = 4
 EQUB %00110100         ; Laser power              = 6
                        ; Missiles                 = 4

.SHIP_CONSTRICTOR_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX   20,   -7,   80,     2,      0,    9,     9,         31    ; Vertex 0
 VERTEX  -20,   -7,   80,     1,      0,    9,     9,         31    ; Vertex 1
 VERTEX  -54,   -7,   40,     4,      1,    9,     9,         31    ; Vertex 2
 VERTEX  -54,   -7,  -40,     5,      4,    9,     8,         31    ; Vertex 3
 VERTEX  -20,   13,  -40,     6,      5,    8,     8,         31    ; Vertex 4
 VERTEX   20,   13,  -40,     7,      6,    8,     8,         31    ; Vertex 5
 VERTEX   54,   -7,  -40,     7,      3,    9,     8,         31    ; Vertex 6
 VERTEX   54,   -7,   40,     3,      2,    9,     9,         31    ; Vertex 7
 VERTEX   20,   13,    5,    15,     15,   15,    15,         31    ; Vertex 8
 VERTEX  -20,   13,    5,    15,     15,   15,    15,         31    ; Vertex 9
 VERTEX   20,   -7,   62,     9,      9,    9,     9,         18    ; Vertex 10
 VERTEX  -20,   -7,   62,     9,      9,    9,     9,         18    ; Vertex 11
 VERTEX   25,   -7,  -25,     9,      9,    9,     9,         18    ; Vertex 12
 VERTEX  -25,   -7,  -25,     9,      9,    9,     9,         18    ; Vertex 13
 VERTEX   15,   -7,  -15,     9,      9,    9,     9,         10    ; Vertex 14
 VERTEX  -15,   -7,  -15,     9,      9,    9,     9,         10    ; Vertex 15
 VERTEX    0,   -7,    0,    15,      9,    1,     0,          0    ; Vertex 16

.SHIP_CONSTRICTOR_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     9,     0,         31    ; Edge 0
 EDGE       1,       2,     9,     1,         31    ; Edge 1
 EDGE       1,       9,     1,     0,         31    ; Edge 2
 EDGE       0,       8,     2,     0,         31    ; Edge 3
 EDGE       0,       7,     9,     2,         31    ; Edge 4
 EDGE       7,       8,     3,     2,         31    ; Edge 5
 EDGE       2,       9,     4,     1,         31    ; Edge 6
 EDGE       2,       3,     9,     4,         31    ; Edge 7
 EDGE       6,       7,     9,     3,         31    ; Edge 8
 EDGE       6,       8,     7,     3,         31    ; Edge 9
 EDGE       5,       8,     7,     6,         31    ; Edge 10
 EDGE       4,       9,     6,     5,         31    ; Edge 11
 EDGE       3,       9,     5,     4,         31    ; Edge 12
 EDGE       3,       4,     8,     5,         31    ; Edge 13
 EDGE       4,       5,     8,     6,         31    ; Edge 14
 EDGE       5,       6,     8,     7,         31    ; Edge 15
 EDGE       3,       6,     9,     8,         31    ; Edge 16
 EDGE       8,       9,     6,     0,         31    ; Edge 17
 EDGE      10,      12,     9,     9,         18    ; Edge 18
 EDGE      12,      14,     9,     9,          5    ; Edge 19
 EDGE      14,      10,     9,     9,         10    ; Edge 20
 EDGE      11,      15,     9,     9,         10    ; Edge 21
 EDGE      13,      15,     9,     9,          5    ; Edge 22
 EDGE      11,      13,     9,     9,         18    ; Edge 23

.SHIP_CONSTRICTOR_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,       55,       15,         31    ; Face 0
 FACE      -24,       75,       20,         31    ; Face 1
 FACE       24,       75,       20,         31    ; Face 2
 FACE       44,       75,        0,         31    ; Face 3
 FACE      -44,       75,        0,         31    ; Face 4
 FACE      -44,       75,        0,         31    ; Face 5
 FACE        0,       53,        0,         31    ; Face 6
 FACE       44,       75,        0,         31    ; Face 7
 FACE        0,        0,     -160,         31    ; Face 8
 FACE        0,      -27,        0,         31    ; Face 9

; ******************************************************************************
;
;       Name: SHIP_DODO
;       Type: Variable
;   Category: Drawing ships
;    Summary: Ship blueprint for a Dodecahedron ("Dodo") space station
;  Deep dive: Ship blueprints
;
; ******************************************************************************

.SHIP_DODO

 EQUB 0                 ; Max. canisters on demise = 0
 EQUW 180 * 180         ; Targetable area          = 180 * 180

 EQUB LO(SHIP_DODO_EDGES - SHIP_DODO)              ; Edges data offset (low)
 EQUB LO(SHIP_DODO_FACES - SHIP_DODO)              ; Faces data offset (low)

 EQUB 101               ; Max. edge count          = (101 - 1) / 4 = 25
 EQUB 0                 ; Gun vertex               = 0
 EQUB 54                ; Explosion count          = 12, as (4 * n) + 6 = 54
 EQUB 144               ; Number of vertices       = 144 / 6 = 24
 EQUB 34                ; Number of edges          = 34
 EQUW 0                 ; Bounty                   = 0
 EQUB 48                ; Number of faces          = 48 / 4 = 12
 EQUB 125               ; Visibility distance      = 125
 EQUB 240               ; Max. energy              = 240
 EQUB 0                 ; Max. speed               = 0

 EQUB HI(SHIP_DODO_EDGES - SHIP_DODO)              ; Edges data offset (high)
 EQUB HI(SHIP_DODO_FACES - SHIP_DODO)              ; Faces data offset (high)

 EQUB 0                 ; Normals are scaled by    = 2^0 = 1
 EQUB %00000000         ; Laser power              = 0
                        ; Missiles                 = 0

.SHIP_DODO_VERTICES

      ;    x,    y,    z, face1, face2, face3, face4, visibility
 VERTEX    0,  150,  196,     1,      0,    5,     5,         31    ; Vertex 0
 VERTEX  143,   46,  196,     1,      0,    2,     2,         31    ; Vertex 1
 VERTEX   88, -121,  196,     2,      0,    3,     3,         31    ; Vertex 2
 VERTEX  -88, -121,  196,     3,      0,    4,     4,         31    ; Vertex 3
 VERTEX -143,   46,  196,     4,      0,    5,     5,         31    ; Vertex 4
 VERTEX    0,  243,   46,     5,      1,    6,     6,         31    ; Vertex 5
 VERTEX  231,   75,   46,     2,      1,    7,     7,         31    ; Vertex 6
 VERTEX  143, -196,   46,     3,      2,    8,     8,         31    ; Vertex 7
 VERTEX -143, -196,   46,     4,      3,    9,     9,         31    ; Vertex 8
 VERTEX -231,   75,   46,     5,      4,   10,    10,         31    ; Vertex 9
 VERTEX  143,  196,  -46,     6,      1,    7,     7,         31    ; Vertex 10
 VERTEX  231,  -75,  -46,     7,      2,    8,     8,         31    ; Vertex 11
 VERTEX    0, -243,  -46,     8,      3,    9,     9,         31    ; Vertex 12
 VERTEX -231,  -75,  -46,     9,      4,   10,    10,         31    ; Vertex 13
 VERTEX -143,  196,  -46,     6,      5,   10,    10,         31    ; Vertex 14
 VERTEX   88,  121, -196,     7,      6,   11,    11,         31    ; Vertex 15
 VERTEX  143,  -46, -196,     8,      7,   11,    11,         31    ; Vertex 16
 VERTEX    0, -150, -196,     9,      8,   11,    11,         31    ; Vertex 17
 VERTEX -143,  -46, -196,    10,      9,   11,    11,         31    ; Vertex 18
 VERTEX  -88,  121, -196,    10,      6,   11,    11,         31    ; Vertex 19
 VERTEX  -16,   32,  196,     0,      0,    0,     0,         30    ; Vertex 20
 VERTEX  -16,  -32,  196,     0,      0,    0,     0,         30    ; Vertex 21
 VERTEX   16,   32,  196,     0,      0,    0,     0,         23    ; Vertex 22
 VERTEX   16,  -32,  196,     0,      0,    0,     0,         23    ; Vertex 23

.SHIP_DODO_EDGES

    ; vertex1, vertex2, face1, face2, visibility
 EDGE       0,       1,     1,     0,         31    ; Edge 0
 EDGE       1,       2,     2,     0,         31    ; Edge 1
 EDGE       2,       3,     3,     0,         31    ; Edge 2
 EDGE       3,       4,     4,     0,         31    ; Edge 3
 EDGE       4,       0,     5,     0,         31    ; Edge 4
 EDGE       5,      10,     6,     1,         31    ; Edge 5
 EDGE      10,       6,     7,     1,         31    ; Edge 6
 EDGE       6,      11,     7,     2,         31    ; Edge 7
 EDGE      11,       7,     8,     2,         31    ; Edge 8
 EDGE       7,      12,     8,     3,         31    ; Edge 9
 EDGE      12,       8,     9,     3,         31    ; Edge 10
 EDGE       8,      13,     9,     4,         31    ; Edge 11
 EDGE      13,       9,    10,     4,         31    ; Edge 12
 EDGE       9,      14,    10,     5,         31    ; Edge 13
 EDGE      14,       5,     6,     5,         31    ; Edge 14
 EDGE      15,      16,    11,     7,         31    ; Edge 15
 EDGE      16,      17,    11,     8,         31    ; Edge 16
 EDGE      17,      18,    11,     9,         31    ; Edge 17
 EDGE      18,      19,    11,    10,         31    ; Edge 18
 EDGE      19,      15,    11,     6,         31    ; Edge 19
 EDGE       0,       5,     5,     1,         31    ; Edge 20
 EDGE       1,       6,     2,     1,         31    ; Edge 21
 EDGE       2,       7,     3,     2,         31    ; Edge 22
 EDGE       3,       8,     4,     3,         31    ; Edge 23
 EDGE       4,       9,     5,     4,         31    ; Edge 24
 EDGE      10,      15,     7,     6,         31    ; Edge 25
 EDGE      11,      16,     8,     7,         31    ; Edge 26
 EDGE      12,      17,     9,     8,         31    ; Edge 27
 EDGE      13,      18,    10,     9,         31    ; Edge 28
 EDGE      14,      19,    10,     6,         31    ; Edge 29
 EDGE      20,      21,     0,     0,         30    ; Edge 30
 EDGE      21,      23,     0,     0,         20    ; Edge 31
 EDGE      23,      22,     0,     0,         23    ; Edge 32
 EDGE      22,      20,     0,     0,         20    ; Edge 33

.SHIP_DODO_FACES

    ; normal_x, normal_y, normal_z, visibility
 FACE        0,        0,      196,         31    ; Face 0
 FACE      103,      142,       88,         31    ; Face 1
 FACE      169,      -55,       89,         31    ; Face 2
 FACE        0,     -176,       88,         31    ; Face 3
 FACE     -169,      -55,       89,         31    ; Face 4
 FACE     -103,      142,       88,         31    ; Face 5
 FACE        0,      176,      -88,         31    ; Face 6
 FACE      169,       55,      -89,         31    ; Face 7
 FACE      103,     -142,      -88,         31    ; Face 8
 FACE     -103,     -142,      -88,         31    ; Face 9
 FACE     -169,       55,      -89,         31    ; Face 10
 FACE        0,        0,     -196,         31    ; Face 11

 EQUB $08, $08          ; These bytes appear to be unused
 EQUB $03, $FE

; ******************************************************************************
;
; Save SHIPS.bin
;
; ******************************************************************************

 PRINT "SHIPS"
 PRINT "Assembled at ", ~CODE_SHIPS%
 PRINT "Ends at ", ~P%
 PRINT "Code size is ", ~(P% - CODE_SHIPS%)
 PRINT "Execute at ", ~LOAD%
 PRINT "Reload at ", ~LOAD_SHIPS%

 PRINT "S.SHIPS ", ~CODE_SHIPS%, " ", ~P%, " ", ~LOAD%, " ", ~LOAD_SHIPS%
 SAVE "3-assembled-output/SHIPS.bin", CODE_SHIPS%, P%, LOAD%
